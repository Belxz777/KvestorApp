/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Ccode%5CTelegram-App%5Cminiapp%5Cnode_modules%5C.pnpm%5Cnext%4014.0.4_react-dom%4018.2.0_react%4018.2.0%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22src%5C%5Capp%5C%5Clayout.tsx%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=C%3A%5Ccode%5CTelegram-App%5Cminiapp%5Csrc%5Capp%5Cglobals.css&modules=C%3A%5Ccode%5CTelegram-App%5Cminiapp%5Csrc%5Capp%5CTmaSDKLoader.tsx&server=false!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Ccode%5CTelegram-App%5Cminiapp%5Cnode_modules%5C.pnpm%5Cnext%4014.0.4_react-dom%4018.2.0_react%4018.2.0%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22src%5C%5Capp%5C%5Clayout.tsx%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=C%3A%5Ccode%5CTelegram-App%5Cminiapp%5Csrc%5Capp%5Cglobals.css&modules=C%3A%5Ccode%5CTelegram-App%5Cminiapp%5Csrc%5Capp%5CTmaSDKLoader.tsx&server=false! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/font/google/target.css?{\"path\":\"src\\\\app\\\\layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"} */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/font/google/target.css?{\\\"path\\\":\\\"src\\\\\\\\app\\\\\\\\layout.tsx\\\",\\\"import\\\":\\\"Inter\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"inter\\\"}\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/globals.css */ \"(app-pages-browser)/./src/app/globals.css\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/TmaSDKLoader.tsx */ \"(app-pages-browser)/./src/app/TmaSDKLoader.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjAuNF9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9QyUzQSU1Q2NvZGUlNUNUZWxlZ3JhbS1BcHAlNUNtaW5pYXBwJTVDbm9kZV9tb2R1bGVzJTVDLnBucG0lNUNuZXh0JTQwMTQuMC40X3JlYWN0LWRvbSU0MDE4LjIuMF9yZWFjdCU0MDE4LjIuMCU1Q25vZGVfbW9kdWxlcyU1Q25leHQlNUNmb250JTVDZ29vZ2xlJTVDdGFyZ2V0LmNzcyUzRiU3QiUyMnBhdGglMjIlM0ElMjJzcmMlNUMlNUNhcHAlNUMlNUNsYXlvdXQudHN4JTIyJTJDJTIyaW1wb3J0JTIyJTNBJTIySW50ZXIlMjIlMkMlMjJhcmd1bWVudHMlMjIlM0ElNUIlN0IlMjJzdWJzZXRzJTIyJTNBJTVCJTIybGF0aW4lMjIlNUQlN0QlNUQlMkMlMjJ2YXJpYWJsZU5hbWUlMjIlM0ElMjJpbnRlciUyMiU3RCZtb2R1bGVzPUMlM0ElNUNjb2RlJTVDVGVsZWdyYW0tQXBwJTVDbWluaWFwcCU1Q3NyYyU1Q2FwcCU1Q2dsb2JhbHMuY3NzJm1vZHVsZXM9QyUzQSU1Q2NvZGUlNUNUZWxlZ3JhbS1BcHAlNUNtaW5pYXBwJTVDc3JjJTVDYXBwJTVDVG1hU0RLTG9hZGVyLnRzeCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLDRqQkFBb1Q7QUFDcFQsb0tBQTJGO0FBQzNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/ZDFmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXGNvZGVcXFxcVGVsZWdyYW0tQXBwXFxcXG1pbmlhcHBcXFxcbm9kZV9tb2R1bGVzXFxcXC5wbnBtXFxcXG5leHRAMTQuMC40X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGZvbnRcXFxcZ29vZ2xlXFxcXHRhcmdldC5jc3M/e1xcXCJwYXRoXFxcIjpcXFwic3JjXFxcXFxcXFxhcHBcXFxcXFxcXGxheW91dC50c3hcXFwiLFxcXCJpbXBvcnRcXFwiOlxcXCJJbnRlclxcXCIsXFxcImFyZ3VtZW50c1xcXCI6W3tcXFwic3Vic2V0c1xcXCI6W1xcXCJsYXRpblxcXCJdfV0sXFxcInZhcmlhYmxlTmFtZVxcXCI6XFxcImludGVyXFxcIn1cIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXGNvZGVcXFxcVGVsZWdyYW0tQXBwXFxcXG1pbmlhcHBcXFxcc3JjXFxcXGFwcFxcXFxnbG9iYWxzLmNzc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcY29kZVxcXFxUZWxlZ3JhbS1BcHBcXFxcbWluaWFwcFxcXFxzcmNcXFxcYXBwXFxcXFRtYVNES0xvYWRlci50c3hcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Ccode%5CTelegram-App%5Cminiapp%5Cnode_modules%5C.pnpm%5Cnext%4014.0.4_react-dom%4018.2.0_react%4018.2.0%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22src%5C%5Capp%5C%5Clayout.tsx%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=C%3A%5Ccode%5CTelegram-App%5Cminiapp%5Csrc%5Capp%5Cglobals.css&modules=C%3A%5Ccode%5CTelegram-App%5Cminiapp%5Csrc%5Capp%5CTmaSDKLoader.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"9276ae47fb44\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvZ2xvYmFscy5jc3M/ZWViOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjkyNzZhZTQ3ZmI0NFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/TmaSDKLoader.tsx":
/*!**********************************!*\
  !*** ./src/app/TmaSDKLoader.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TmaSDKLoader: function() { return /* binding */ TmaSDKLoader; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _tma_js_sdk_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tma.js/sdk-react */ \"(app-pages-browser)/./node_modules/.pnpm/@tma.js+sdk-react@1.1.0_@types+react@18.2.45_react@18.2.0/node_modules/@tma.js/sdk-react/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ TmaSDKLoader auto */ \n\nfunction SDKProviderError(param) {\n    let { error } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                className: \" text-center font-extrabold text-scin-base text-xl  \",\n                children: [\n                    \"Ууп что то пошло не так  ... \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                        fileName: \"C:\\\\code\\\\Telegram-App\\\\miniapp\\\\src\\\\app\\\\TmaSDKLoader.tsx\",\n                        lineNumber: 15,\n                        columnNumber: 30\n                    }, this),\n                    \"Если что приложение запукается только через telegram)\"\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\code\\\\Telegram-App\\\\miniapp\\\\src\\\\app\\\\TmaSDKLoader.tsx\",\n                lineNumber: 14,\n                columnNumber: 3\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"blockquote\", {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"code\", {\n                    className: \" text-center font-extrabold text-scin-base text-xl  \",\n                    children: error instanceof Error ? error.message : JSON.stringify(error)\n                }, void 0, false, {\n                    fileName: \"C:\\\\code\\\\Telegram-App\\\\miniapp\\\\src\\\\app\\\\TmaSDKLoader.tsx\",\n                    lineNumber: 20,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\code\\\\Telegram-App\\\\miniapp\\\\src\\\\app\\\\TmaSDKLoader.tsx\",\n                lineNumber: 19,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\code\\\\Telegram-App\\\\miniapp\\\\src\\\\app\\\\TmaSDKLoader.tsx\",\n        lineNumber: 12,\n        columnNumber: 5\n    }, this);\n}\n_c = SDKProviderError;\nfunction SDKProviderLoading() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n        className: \" text-center font-extrabold text-scin-base text-xl  \",\n        children: \"Загрузка ...\"\n    }, void 0, false, {\n        fileName: \"C:\\\\code\\\\Telegram-App\\\\miniapp\\\\src\\\\app\\\\TmaSDKLoader.tsx\",\n        lineNumber: 32,\n        columnNumber: 5\n    }, this);\n}\n_c1 = SDKProviderLoading;\nfunction SDKInitialState() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n        className: \" text-center font-extrabold text-scin-base text-xl  \",\n        children: \"Ждем инициализации для начала ...\"\n    }, void 0, false, {\n        fileName: \"C:\\\\code\\\\Telegram-App\\\\miniapp\\\\src\\\\app\\\\TmaSDKLoader.tsx\",\n        lineNumber: 39,\n        columnNumber: 3\n    }, this);\n}\n_c2 = SDKInitialState;\n/**\r\n * Root component of the whole project.\r\n */ function TmaSDKLoader(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_tma_js_sdk_react__WEBPACK_IMPORTED_MODULE_1__.SDKProvider, {\n        options: {\n            cssVars: true,\n            acceptCustomStyles: true,\n            async: true\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_tma_js_sdk_react__WEBPACK_IMPORTED_MODULE_1__.DisplayGate, {\n            error: SDKProviderError,\n            loading: SDKProviderLoading,\n            initial: SDKInitialState,\n            children: children\n        }, void 0, false, {\n            fileName: \"C:\\\\code\\\\Telegram-App\\\\miniapp\\\\src\\\\app\\\\TmaSDKLoader.tsx\",\n            lineNumber: 50,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\code\\\\Telegram-App\\\\miniapp\\\\src\\\\app\\\\TmaSDKLoader.tsx\",\n        lineNumber: 49,\n        columnNumber: 5\n    }, this);\n}\n_c3 = TmaSDKLoader;\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"SDKProviderError\");\n$RefreshReg$(_c1, \"SDKProviderLoading\");\n$RefreshReg$(_c2, \"SDKInitialState\");\n$RefreshReg$(_c3, \"TmaSDKLoader\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvVG1hU0RLTG9hZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRzZEO0FBTTdELFNBQVNFLGlCQUFpQixLQUFnQztRQUFoQyxFQUFFQyxLQUFLLEVBQXlCLEdBQWhDO0lBQ3hCLHFCQUNFLDhEQUFDQzs7MEJBRUgsOERBQUNDO2dCQUFHQyxXQUFVOztvQkFBdUQ7a0NBQzFDLDhEQUFDQzs7Ozs7b0JBQUk7Ozs7Ozs7MEJBSTVCLDhEQUFDQzswQkFDQyw0RUFBQ0M7b0JBQUtILFdBQVU7OEJBQ2JILGlCQUFpQk8sUUFDZFAsTUFBTVEsT0FBTyxHQUNiQyxLQUFLQyxTQUFTLENBQUNWOzs7Ozs7Ozs7Ozs7Ozs7OztBQUs3QjtLQWxCU0Q7QUFvQlQsU0FBU1k7SUFDUCxxQkFDRSw4REFBQ1Q7UUFBR0MsV0FBVTtrQkFBdUQ7Ozs7OztBQUd6RTtNQUxTUTtBQU9ULFNBQVNDO0lBQ1AscUJBQ0EsOERBQUNWO1FBQUdDLFdBQVU7a0JBQXVEOzs7Ozs7QUFHdkU7TUFMU1M7QUFPVDs7Q0FFQyxHQUNNLFNBQVNDLGFBQWEsS0FBK0I7UUFBL0IsRUFBRUMsUUFBUSxFQUFxQixHQUEvQjtJQUMzQixxQkFDRSw4REFBQ2pCLDBEQUFXQTtRQUFDa0IsU0FBUztZQUFFQyxTQUFTO1lBQU1DLG9CQUFvQjtZQUFNQyxPQUFPO1FBQUs7a0JBQzNFLDRFQUFDcEIsMERBQVdBO1lBQ1ZFLE9BQU9EO1lBQ1BvQixTQUFTUjtZQUNUUyxTQUFTUjtzQkFFUkU7Ozs7Ozs7Ozs7O0FBSVQ7TUFaZ0JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvVG1hU0RLTG9hZGVyLnRzeD9lMjgxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCB0eXBlIHsgUHJvcHNXaXRoQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IFNES1Byb3ZpZGVyLCBEaXNwbGF5R2F0ZSB9IGZyb20gJ0B0bWEuanMvc2RrLXJlYWN0JztcclxuXHJcbmludGVyZmFjZSBTREtQcm92aWRlckVycm9yUHJvcHMge1xyXG4gIGVycm9yOiB1bmtub3duO1xyXG59XHJcblxyXG5mdW5jdGlvbiBTREtQcm92aWRlckVycm9yKHsgZXJyb3IgfTogU0RLUHJvdmlkZXJFcnJvclByb3BzKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXY+XHJcblxyXG4gIDxoMSBjbGFzc05hbWU9JyB0ZXh0LWNlbnRlciBmb250LWV4dHJhYm9sZCB0ZXh0LXNjaW4tYmFzZSB0ZXh0LXhsICAnPlxyXG7Qo9GD0L8g0YfRgtC+INGC0L4g0L/QvtGI0LvQviDQvdC1INGC0LDQuiAgLi4uIDxici8+XHJcbtCV0YHQu9C4INGH0YLQviDQv9GA0LjQu9C+0LbQtdC90LjQtSDQt9Cw0L/Rg9C60LDQtdGC0YHRjyDRgtC+0LvRjNC60L4g0YfQtdGA0LXQtyB0ZWxlZ3JhbSlcclxuXHJcbjwvaDE+XHJcbiAgICAgIDxibG9ja3F1b3RlPlxyXG4gICAgICAgIDxjb2RlIGNsYXNzTmFtZT0nIHRleHQtY2VudGVyIGZvbnQtZXh0cmFib2xkIHRleHQtc2Npbi1iYXNlIHRleHQteGwgICc+XHJcbiAgICAgICAgICB7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxyXG4gICAgICAgICAgICA/IGVycm9yLm1lc3NhZ2VcclxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShlcnJvcil9XHJcbiAgICAgICAgPC9jb2RlPlxyXG4gICAgICA8L2Jsb2NrcXVvdGU+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBTREtQcm92aWRlckxvYWRpbmcoKSB7XHJcbiAgcmV0dXJuKFxyXG4gICAgPGgxIGNsYXNzTmFtZT0nIHRleHQtY2VudGVyIGZvbnQtZXh0cmFib2xkIHRleHQtc2Npbi1iYXNlIHRleHQteGwgICc+XHJcbiAgICAgINCX0LDQs9GA0YPQt9C60LAgLi4uXHJcbiAgPC9oMT4pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIFNES0luaXRpYWxTdGF0ZSgpIHtcclxuICByZXR1cm4oXHJcbiAgPGgxIGNsYXNzTmFtZT0nIHRleHQtY2VudGVyIGZvbnQtZXh0cmFib2xkIHRleHQtc2Npbi1iYXNlIHRleHQteGwgICc+XHJcbtCW0LTQtdC8INC40L3QuNGG0LjQsNC70LjQt9Cw0YbQuNC4INC00LvRjyDQvdCw0YfQsNC70LAgLi4uXHJcbjwvaDE+KVxyXG59XHJcblxyXG4vKipcclxuICogUm9vdCBjb21wb25lbnQgb2YgdGhlIHdob2xlIHByb2plY3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gVG1hU0RLTG9hZGVyKHsgY2hpbGRyZW4gfTogUHJvcHNXaXRoQ2hpbGRyZW4pIHtcclxuICByZXR1cm4gKFxyXG4gICAgPFNES1Byb3ZpZGVyIG9wdGlvbnM9e3sgY3NzVmFyczogdHJ1ZSwgYWNjZXB0Q3VzdG9tU3R5bGVzOiB0cnVlLCBhc3luYzogdHJ1ZSB9fT5cclxuICAgICAgPERpc3BsYXlHYXRlXHJcbiAgICAgICAgZXJyb3I9e1NES1Byb3ZpZGVyRXJyb3J9XHJcbiAgICAgICAgbG9hZGluZz17U0RLUHJvdmlkZXJMb2FkaW5nfVxyXG4gICAgICAgIGluaXRpYWw9e1NES0luaXRpYWxTdGF0ZX1cclxuICAgICAgPlxyXG4gICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgPC9EaXNwbGF5R2F0ZT5cclxuICAgIDwvU0RLUHJvdmlkZXI+XHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiU0RLUHJvdmlkZXIiLCJEaXNwbGF5R2F0ZSIsIlNES1Byb3ZpZGVyRXJyb3IiLCJlcnJvciIsImRpdiIsImgxIiwiY2xhc3NOYW1lIiwiYnIiLCJibG9ja3F1b3RlIiwiY29kZSIsIkVycm9yIiwibWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJTREtQcm92aWRlckxvYWRpbmciLCJTREtJbml0aWFsU3RhdGUiLCJUbWFTREtMb2FkZXIiLCJjaGlsZHJlbiIsIm9wdGlvbnMiLCJjc3NWYXJzIiwiYWNjZXB0Q3VzdG9tU3R5bGVzIiwiYXN5bmMiLCJsb2FkaW5nIiwiaW5pdGlhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/TmaSDKLoader.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!**********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \**********************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={686:(e,r,t)=>{var n=t(808);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},808:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(686);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjAuNF9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxhQUFhLE9BQU8sY0FBYyxhQUFhLDBCQUEwQixvQ0FBb0MsOEJBQThCLHVCQUF1QixRQUFRLGtCQUFrQixXQUFXLGdCQUFnQiw4QkFBOEIscUJBQXFCLGdCQUFnQixtQkFBbUIsaUJBQWlCLGdDQUFnQyxXQUFXLE9BQU8sMkJBQTJCLDZCQUE2QixLQUFLLDhDQUE4QyxvQkFBb0IsTUFBTSxTQUFTLE9BQU8sbUJBQW1CLE9BQU8sWUFBWSxnQ0FBZ0MsY0FBYyxPQUFPLGdDQUFnQyxPQUFPLGdDQUFnQyxxQ0FBcUMsNENBQTRDLDJDQUEyQyxTQUFTLGdCQUFnQixJQUFJLHdCQUF3QixPQUFPLFlBQVksT0FBTyx1QkFBdUIscUJBQXFCLE9BQU8sdUJBQXVCLE9BQU8sZ0NBQWdDLE9BQU8sZUFBZSxvQkFBb0IsaUJBQWlCLHNDQUFzQyxlQUFlLE9BQU8sZ0JBQWdCLDRCQUE0QixHQUFHLHVDQUF1QyxlQUFlLE9BQU8sZ0JBQWdCLDRCQUE0QixHQUFHLDJDQUEyQyxrQkFBa0IsMkNBQTJDLEtBQUssNkJBQTZCLDJCQUEyQixNQUFNLE9BQU8sZUFBZSxFQUFFLG9CQUFvQixvQkFBb0IsS0FBSyxHQUFHLFNBQVMsd0JBQXdCLE9BQU8sYUFBYSx3Q0FBd0MsWUFBWSxzQkFBc0IsWUFBWSxPQUFPLDZCQUE2QixxQkFBcUIsT0FBTyxxQkFBcUIsT0FBTyxNQUFNLGVBQWUsUUFBUSxHQUFHLFNBQVMscUJBQXFCLHdDQUF3QyxzQkFBc0IscUJBQXFCLE9BQU8sYUFBYSxHQUFHLHlCQUF5Qix5Q0FBeUMsYUFBYSxZQUFZLHdCQUF3QixNQUFNLDBEQUEwRCxZQUFZLDZCQUE2QixrQkFBa0Isb0JBQW9CLHFCQUFxQixhQUFhLGdFQUFnRSxZQUFZLE9BQU8sTUFBTSwrQ0FBK0MsS0FBSyxvQ0FBb0MsYUFBYSw0QkFBNEIsU0FBUyx5QkFBeUIsK0JBQStCLFVBQVUsaUJBQWlCLE1BQU0sY0FBYyxrQkFBa0IsU0FBUyxnQkFBZ0Isc0JBQXNCLFdBQVcsc0JBQXNCLFNBQVMsb0RBQW9ELGlEQUFpRCwyQ0FBMkMsUUFBUSxzQkFBc0IsZ0JBQWdCLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMC40X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzPzc1OTEiXSwic291cmNlc0NvbnRlbnQiOlsiKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezY4NjooZSxyLHQpPT57dmFyIG49dCg4MDgpO3ZhciBpPU9iamVjdC5jcmVhdGUobnVsbCk7dmFyIGE9dHlwZW9mIGRvY3VtZW50PT09XCJ1bmRlZmluZWRcIjt2YXIgbz1BcnJheS5wcm90b3R5cGUuZm9yRWFjaDtmdW5jdGlvbiBkZWJvdW5jZShlLHIpe3ZhciB0PTA7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49dGhpczt2YXIgaT1hcmd1bWVudHM7dmFyIGE9ZnVuY3Rpb24gZnVuY3Rpb25DYWxsKCl7cmV0dXJuIGUuYXBwbHkobixpKX07Y2xlYXJUaW1lb3V0KHQpO3Q9c2V0VGltZW91dChhLHIpfX1mdW5jdGlvbiBub29wKCl7fWZ1bmN0aW9uIGdldEN1cnJlbnRTY3JpcHRVcmwoZSl7dmFyIHI9aVtlXTtpZighcil7aWYoZG9jdW1lbnQuY3VycmVudFNjcmlwdCl7cj1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY31lbHNle3ZhciB0PWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO3ZhciBhPXRbdC5sZW5ndGgtMV07aWYoYSl7cj1hLnNyY319aVtlXT1yfXJldHVybiBmdW5jdGlvbihlKXtpZighcil7cmV0dXJuIG51bGx9dmFyIHQ9ci5zcGxpdCgvKFteXFxcXC9dKylcXC5qcyQvKTt2YXIgaT10JiZ0WzFdO2lmKCFpKXtyZXR1cm5bci5yZXBsYWNlKFwiLmpzXCIsXCIuY3NzXCIpXX1pZighZSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19cmV0dXJuIGUuc3BsaXQoXCIsXCIpLm1hcCgoZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFJlZ0V4cChcIlwiLmNvbmNhdChpLFwiXFxcXC5qcyRcIiksXCJnXCIpO3JldHVybiBuKHIucmVwbGFjZSh0LFwiXCIuY29uY2F0KGUucmVwbGFjZSgve2ZpbGVOYW1lfS9nLGkpLFwiLmNzc1wiKSkpfSkpfX1mdW5jdGlvbiB1cGRhdGVDc3MoZSxyKXtpZighcil7aWYoIWUuaHJlZil7cmV0dXJufXI9ZS5ocmVmLnNwbGl0KFwiP1wiKVswXX1pZighaXNVcmxSZXF1ZXN0KHIpKXtyZXR1cm59aWYoZS5pc0xvYWRlZD09PWZhbHNlKXtyZXR1cm59aWYoIXJ8fCEoci5pbmRleE9mKFwiLmNzc1wiKT4tMSkpe3JldHVybn1lLnZpc2l0ZWQ9dHJ1ZTt2YXIgdD1lLmNsb25lTm9kZSgpO3QuaXNMb2FkZWQ9ZmFsc2U7dC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsKGZ1bmN0aW9uKCl7aWYodC5pc0xvYWRlZCl7cmV0dXJufXQuaXNMb2FkZWQ9dHJ1ZTtlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSl9KSk7dC5ocmVmPVwiXCIuY29uY2F0KHIsXCI/XCIpLmNvbmNhdChEYXRlLm5vdygpKTtpZihlLm5leHRTaWJsaW5nKXtlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsZS5uZXh0U2libGluZyl9ZWxzZXtlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodCl9fWZ1bmN0aW9uIGdldFJlbG9hZFVybChlLHIpe3ZhciB0O2U9bihlLHtzdHJpcFdXVzpmYWxzZX0pO3Iuc29tZSgoZnVuY3Rpb24obil7aWYoZS5pbmRleE9mKHIpPi0xKXt0PW59fSkpO3JldHVybiB0fWZ1bmN0aW9uIHJlbG9hZFN0eWxlKGUpe2lmKCFlKXtyZXR1cm4gZmFsc2V9dmFyIHI9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7dmFyIHQ9ZmFsc2U7by5jYWxsKHIsKGZ1bmN0aW9uKHIpe2lmKCFyLmhyZWYpe3JldHVybn12YXIgbj1nZXRSZWxvYWRVcmwoci5ocmVmLGUpO2lmKCFpc1VybFJlcXVlc3Qobikpe3JldHVybn1pZihyLnZpc2l0ZWQ9PT10cnVlKXtyZXR1cm59aWYobil7dXBkYXRlQ3NzKHIsbik7dD10cnVlfX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRBbGwoKXt2YXIgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1wiKTtvLmNhbGwoZSwoZnVuY3Rpb24oZSl7aWYoZS52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufXVwZGF0ZUNzcyhlKX0pKX1mdW5jdGlvbiBpc1VybFJlcXVlc3QoZSl7aWYoIS9eW2EtekEtWl1bYS16QS1aXFxkK1xcLS5dKjovLnRlc3QoZSkpe3JldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXtpZihhKXtjb25zb2xlLmxvZyhcIm5vIHdpbmRvdy5kb2N1bWVudCBmb3VuZCwgd2lsbCBub3QgSE1SIENTU1wiKTtyZXR1cm4gbm9vcH12YXIgdD1nZXRDdXJyZW50U2NyaXB0VXJsKGUpO2Z1bmN0aW9uIHVwZGF0ZSgpe3ZhciBlPXQoci5maWxlbmFtZSk7dmFyIG49cmVsb2FkU3R5bGUoZSk7aWYoci5sb2NhbHMpe2NvbnNvbGUubG9nKFwiW0hNUl0gRGV0ZWN0ZWQgbG9jYWwgY3NzIG1vZHVsZXMuIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpO3JldHVybn1pZihuKXtjb25zb2xlLmxvZyhcIltITVJdIGNzcyByZWxvYWQgJXNcIixlLmpvaW4oXCIgXCIpKX1lbHNle2NvbnNvbGUubG9nKFwiW0hNUl0gUmVsb2FkIGFsbCBjc3NcIik7cmVsb2FkQWxsKCl9fXJldHVybiBkZWJvdW5jZSh1cGRhdGUsNTApfX0sODA4OmU9PntmdW5jdGlvbiBub3JtYWxpemVVcmwoZSl7cmV0dXJuIGUucmVkdWNlKChmdW5jdGlvbihlLHIpe3N3aXRjaChyKXtjYXNlXCIuLlwiOmUucG9wKCk7YnJlYWs7Y2FzZVwiLlwiOmJyZWFrO2RlZmF1bHQ6ZS5wdXNoKHIpfXJldHVybiBlfSksW10pLmpvaW4oXCIvXCIpfWUuZXhwb3J0cz1mdW5jdGlvbihlKXtlPWUudHJpbSgpO2lmKC9eZGF0YTovaS50ZXN0KGUpKXtyZXR1cm4gZX12YXIgcj1lLmluZGV4T2YoXCIvL1wiKSE9PS0xP2Uuc3BsaXQoXCIvL1wiKVswXStcIi8vXCI6XCJcIjt2YXIgdD1lLnJlcGxhY2UobmV3IFJlZ0V4cChyLFwiaVwiKSxcIlwiKS5zcGxpdChcIi9cIik7dmFyIG49dFswXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcLiQvLFwiXCIpO3RbMF09XCJcIjt2YXIgaT1ub3JtYWxpemVVcmwodCk7cmV0dXJuIHIrbitpfX19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIG49clt0XTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXJbdF09e2V4cG9ydHM6e319O3ZhciBhPXRydWU7dHJ5e2VbdF0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7YT1mYWxzZX1maW5hbGx5e2lmKGEpZGVsZXRlIHJbdF19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXyg2ODYpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/font/google/target.css?{\"path\":\"src\\\\app\\\\layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"}":
/*!***************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/font/google/target.css?{"path":"src\\app\\layout.tsx","import":"Inter","arguments":[{"subsets":["latin"]}],"variableName":"inter"} ***!
  \***************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Inter_e66fe9', '__Inter_Fallback_e66fe9'\",\"fontStyle\":\"normal\"},\"className\":\"__className_e66fe9\"};\n    if(true) {\n      // 1703705633788\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjAuNF9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP3tcInBhdGhcIjpcInNyY1xcXFxhcHBcXFxcbGF5b3V0LnRzeFwiLFwiaW1wb3J0XCI6XCJJbnRlclwiLFwiYXJndW1lbnRzXCI6W3tcInN1YnNldHNcIjpbXCJsYXRpblwiXX1dLFwidmFyaWFibGVOYW1lXCI6XCJpbnRlclwifSIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixTQUFTLGdGQUFnRjtBQUMzRyxPQUFPLElBQVU7QUFDakI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxrVUFBK0ssY0FBYyxzREFBc0Q7QUFDalIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4wLjRfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz8xZDUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJzdHlsZVwiOntcImZvbnRGYW1pbHlcIjpcIidfX0ludGVyX2U2NmZlOScsICdfX0ludGVyX0ZhbGxiYWNrX2U2NmZlOSdcIixcImZvbnRTdHlsZVwiOlwibm9ybWFsXCJ9LFwiY2xhc3NOYW1lXCI6XCJfX2NsYXNzTmFtZV9lNjZmZTlcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTcwMzcwNTYzMzc4OFxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9jb2RlL1RlbGVncmFtLUFwcC9taW5pYXBwL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjAuNF9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/font/google/target.css?{\"path\":\"src\\\\app\\\\layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*****************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV = jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjAuNF9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsbUtBQTBCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGVBQWU7QUFDaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EscUNBQXFDOztBQUVyQyxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0Es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VUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvRUFBb0U7O0FBRXBFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FB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QUFDaEIsY0FBYztBQUNkLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4wLjRfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzPzMyNGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBjYXNlIFJFQUNUX0NBQ0hFX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiAnQ2FjaGUnO1xuICAgICAgfVxuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFViQxKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFViQxKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdrZXknKSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIGsgIT09ICdrZXknO1xuICAgICAgfSk7XG4gICAgICB2YXIgYmVmb3JlRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7a2V5OiBzb21lS2V5LCAnICsga2V5cy5qb2luKCc6IC4uLiwgJykgKyAnOiAuLi59JyA6ICd7a2V5OiBzb21lS2V5fSc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0S2V5U3ByZWFkW2NvbXBvbmVudE5hbWUgKyBiZWZvcmVFeGFtcGxlXSkge1xuICAgICAgICB2YXIgYWZ0ZXJFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3snICsga2V5cy5qb2luKCc6IC4uLiwgJykgKyAnOiAuLi59JyA6ICd7fSc7XG5cbiAgICAgICAgZXJyb3IoJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbicgKyAnICBsZXQgcHJvcHMgPSAlcztcXG4nICsgJyAgPCVzIHsuLi5wcm9wc30gLz5cXG4nICsgJ1JlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbicgKyAnICBsZXQgcHJvcHMgPSAlcztcXG4nICsgJyAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsIGJlZm9yZUV4YW1wbGUsIGNvbXBvbmVudE5hbWUsIGFmdGVyRXhhbXBsZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NvbXBvbmVudE5hbWUgKyBiZWZvcmVFeGFtcGxlXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYgPSBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3hERVYgPSBqc3hERVY7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \*******************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjAuNF9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsMlBBQXNFO0FBQ3hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjAuNF9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz81NDRiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tma.js+sdk-react@1.1.0_@types+react@18.2.45_react@18.2.0/node_modules/@tma.js/sdk-react/dist/index.mjs":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tma.js+sdk-react@1.1.0_@types+react@18.2.45_react@18.2.0/node_modules/@tma.js/sdk-react/dist/index.mjs ***!
  \************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DisplayGate: function() { return /* binding */ pt; },\n/* harmony export */   SDKProvider: function() { return /* binding */ G; },\n/* harmony export */   useBackButton: function() { return /* binding */ k; },\n/* harmony export */   useClosingBehavior: function() { return /* binding */ x; },\n/* harmony export */   useCloudStorage: function() { return /* binding */ I; },\n/* harmony export */   useHapticFeedback: function() { return /* binding */ O; },\n/* harmony export */   useInitData: function() { return /* binding */ A; },\n/* harmony export */   useInitDataRaw: function() { return /* binding */ M; },\n/* harmony export */   useInvoice: function() { return /* binding */ j; },\n/* harmony export */   useLaunchParams: function() { return /* binding */ F; },\n/* harmony export */   useMainButton: function() { return /* binding */ H; },\n/* harmony export */   useMiniApp: function() { return /* binding */ K; },\n/* harmony export */   usePopup: function() { return /* binding */ L; },\n/* harmony export */   usePostEvent: function() { return /* binding */ U; },\n/* harmony export */   useQRScanner: function() { return /* binding */ W; },\n/* harmony export */   useSDKContext: function() { return /* binding */ w; },\n/* harmony export */   useSettingsButton: function() { return /* binding */ V; },\n/* harmony export */   useThemeParams: function() { return /* binding */ $; },\n/* harmony export */   useUtils: function() { return /* binding */ q; },\n/* harmony export */   useViewport: function() { return /* binding */ Q; },\n/* harmony export */   withBackButton: function() { return /* binding */ J; },\n/* harmony export */   withClosingBehavior: function() { return /* binding */ X; },\n/* harmony export */   withCloudStorage: function() { return /* binding */ Y; },\n/* harmony export */   withHapticFeedback: function() { return /* binding */ Z; },\n/* harmony export */   withInitData: function() { return /* binding */ _; },\n/* harmony export */   withInitDataRaw: function() { return /* binding */ tt; },\n/* harmony export */   withInvoice: function() { return /* binding */ et; },\n/* harmony export */   withLaunchParams: function() { return /* binding */ nt; },\n/* harmony export */   withMainButton: function() { return /* binding */ ot; },\n/* harmony export */   withMiniApp: function() { return /* binding */ rt; },\n/* harmony export */   withPopup: function() { return /* binding */ it; },\n/* harmony export */   withPostEvent: function() { return /* binding */ ct; },\n/* harmony export */   withQRScanner: function() { return /* binding */ at; },\n/* harmony export */   withSDKContext: function() { return /* binding */ N; },\n/* harmony export */   withSettingsButton: function() { return /* binding */ st; },\n/* harmony export */   withThemeParams: function() { return /* binding */ ut; },\n/* harmony export */   withUtils: function() { return /* binding */ lt; },\n/* harmony export */   withViewport: function() { return /* binding */ ht; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _tma_js_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tma.js/sdk */ \"(app-pages-browser)/./node_modules/.pnpm/@tma.js+sdk@1.2.0/node_modules/@tma.js/sdk/dist/index.mjs\");\n\n\nfunction o(t, e) {\n  return (i) => {\n    function n(s) {\n      const l = {\n        ...s,\n        [t]: e()\n      };\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(i, { ...l });\n    }\n    return Object.defineProperty(n, \"name\", {\n      value: `With${t[0].toUpperCase()}${t.slice(1)}`\n    }), n;\n  };\n}\nconst u = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  loading: !1\n});\nu.displayName = \"SDKContext\";\nfunction C({ options: t, children: e }) {\n  const [i, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [s, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), [h, D] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    n(!0), (0,_tma_js_sdk__WEBPACK_IMPORTED_MODULE_1__.init)({ ...t, async: !0 }).then(D).catch(l).finally(() => n(!1));\n  }, []);\n  const S = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const p = { loading: i };\n    return s && (p.error = s), h && (p.initResult = h), p;\n  }, [i, h, s]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(u.Provider, { value: S }, e);\n}\nfunction R({ options: t = {}, children: e }) {\n  const i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const n = { loading: !1 };\n    try {\n      n.initResult = (0,_tma_js_sdk__WEBPACK_IMPORTED_MODULE_1__.init)({ ...t, async: !1 });\n    } catch (s) {\n      n.error = s;\n    }\n    return n;\n  }, []);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(u.Provider, { value: i }, e);\n}\nfunction G(t) {\n  var e;\n  return (e = t.options) != null && e.async ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(C, { ...t }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(R, { ...t });\n}\nfunction w() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(u);\n}\nfunction P(t) {\n  const { initResult: e } = w();\n  if (!e)\n    throw new Error(`Unable to get init result key \"${t}\" as long as SDK is not initialized`);\n  return e[t];\n}\nfunction m(t) {\n  return Object.create(\n    Object.getPrototypeOf(t),\n    Object.getOwnPropertyDescriptors(t)\n  );\n}\nfunction b(t) {\n  const e = P(t), [i, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(m(e));\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => e.on(\"change\", () => {\n    n(m(e));\n  }), [e]), i;\n}\nfunction N(t) {\n  return function(i) {\n    const n = {\n      ...i,\n      sdk: w()\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(t, { ...n });\n  };\n}\nfunction r(t, e) {\n  return e ? () => b(t) : () => P(t);\n}\nconst k = r(\"backButton\", !0), J = o(\"backButton\", k), x = r(\"closingBehavior\", !0), X = o(\"closingBehavior\", x), I = r(\"cloudStorage\"), Y = o(\"cloudStorage\", I), O = r(\"hapticFeedback\"), Z = o(\"hapticFeedback\", O), A = r(\"initData\"), _ = o(\"initData\", A), M = r(\"initDataRaw\"), tt = o(\"initDataRaw\", M), j = r(\"invoice\", !0), et = o(\"invoice\", j);\nfunction F() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_tma_js_sdk__WEBPACK_IMPORTED_MODULE_1__.retrieveLaunchData)().launchParams, []);\n}\nfunction nt(t) {\n  return function(i) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(t, { ...i, launchParams: F() });\n  };\n}\nconst H = r(\"mainButton\", !0), ot = o(\"mainButton\", H), K = r(\"miniApp\", !0), rt = o(\"miniApp\", K), L = r(\"popup\", !0), it = o(\"popup\", L), U = r(\"postEvent\"), ct = o(\"postEvent\", U), V = r(\"settingsButton\", !0), st = o(\"settingsButton\", V), W = r(\"qrScanner\", !0), at = o(\"qrScanner\", W), $ = r(\"themeParams\", !0), ut = o(\"themeParams\", $), q = r(\"utils\"), lt = o(\"utils\", q), Q = r(\"viewport\", !0), ht = o(\"viewport\", Q);\nfunction d(t, e = {}) {\n  return typeof t == \"function\" ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(t, { ...e }) : t;\n}\nfunction pt(t) {\n  const { loading: e, initResult: i, error: n } = w();\n  return i ? t.children : n ? d(t.error, { error: n }) : d(e ? t.loading : t.initial);\n}\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdG1hLmpzK3Nkay1yZWFjdEAxLjEuMF9AdHlwZXMrcmVhY3RAMTguMi40NV9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0B0bWEuanMvc2RrLXJlYWN0L2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEc7QUFDM0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0RBQWUsTUFBTSxNQUFNO0FBQ3hEO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CLEVBQUUsV0FBVztBQUNwRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLFVBQVUsb0RBQUM7QUFDWDtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDLGlCQUFpQiwrQ0FBQyxlQUFlLCtDQUFDLGFBQWEsK0NBQUM7QUFDaEQsRUFBRSxnREFBQztBQUNILFdBQVcsaURBQUMsR0FBRyxpQkFBaUI7QUFDaEMsR0FBRztBQUNILFlBQVksOENBQUM7QUFDYixnQkFBZ0I7QUFDaEI7QUFDQSxHQUFHO0FBQ0gseUJBQXlCLGdEQUFlLGVBQWUsVUFBVTtBQUNqRTtBQUNBLGFBQWEsZUFBZSxlQUFlO0FBQzNDLFlBQVksOENBQUM7QUFDYixnQkFBZ0I7QUFDaEI7QUFDQSxxQkFBcUIsaURBQUMsR0FBRyxpQkFBaUI7QUFDMUMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsZ0RBQWUsZUFBZSxVQUFVO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnREFBZSxNQUFNLE1BQU0sb0JBQW9CLGdEQUFlLE1BQU0sTUFBTTtBQUN4STtBQUNBO0FBQ0EsU0FBUyxpREFBQztBQUNWO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBLHNEQUFzRCxFQUFFO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrQ0FBQztBQUM1QixTQUFTLGdEQUFDO0FBQ1Y7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQWUsTUFBTSxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4Q0FBQyxPQUFPLCtEQUFDO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnREFBZSxNQUFNLHlCQUF5QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsa0RBQWtELGdEQUFlLE1BQU0sTUFBTTtBQUM3RTtBQUNBO0FBQ0EsVUFBVSxzQ0FBc0M7QUFDaEQsMkNBQTJDLFVBQVU7QUFDckQ7QUF3Q0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRtYS5qcytzZGstcmVhY3RAMS4xLjBfQHR5cGVzK3JlYWN0QDE4LjIuNDVfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AdG1hLmpzL3Nkay1yZWFjdC9kaXN0L2luZGV4Lm1qcz83YjMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjLCB7IGNyZWF0ZUNvbnRleHQgYXMgQiwgdXNlU3RhdGUgYXMgYSwgdXNlRWZmZWN0IGFzIGcsIHVzZU1lbW8gYXMgZiwgdXNlQ29udGV4dCBhcyBFIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBpbml0IGFzIHYsIHJldHJpZXZlTGF1bmNoRGF0YSBhcyB5IH0gZnJvbSBcIkB0bWEuanMvc2RrXCI7XG5mdW5jdGlvbiBvKHQsIGUpIHtcbiAgcmV0dXJuIChpKSA9PiB7XG4gICAgZnVuY3Rpb24gbihzKSB7XG4gICAgICBjb25zdCBsID0ge1xuICAgICAgICAuLi5zLFxuICAgICAgICBbdF06IGUoKVxuICAgICAgfTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gYy5jcmVhdGVFbGVtZW50KGksIHsgLi4ubCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIm5hbWVcIiwge1xuICAgICAgdmFsdWU6IGBXaXRoJHt0WzBdLnRvVXBwZXJDYXNlKCl9JHt0LnNsaWNlKDEpfWBcbiAgICB9KSwgbjtcbiAgfTtcbn1cbmNvbnN0IHUgPSBCKHtcbiAgbG9hZGluZzogITFcbn0pO1xudS5kaXNwbGF5TmFtZSA9IFwiU0RLQ29udGV4dFwiO1xuZnVuY3Rpb24gQyh7IG9wdGlvbnM6IHQsIGNoaWxkcmVuOiBlIH0pIHtcbiAgY29uc3QgW2ksIG5dID0gYSghMSksIFtzLCBsXSA9IGEoKSwgW2gsIERdID0gYSgpO1xuICBnKCgpID0+IHtcbiAgICBuKCEwKSwgdih7IC4uLnQsIGFzeW5jOiAhMCB9KS50aGVuKEQpLmNhdGNoKGwpLmZpbmFsbHkoKCkgPT4gbighMSkpO1xuICB9LCBbXSk7XG4gIGNvbnN0IFMgPSBmKCgpID0+IHtcbiAgICBjb25zdCBwID0geyBsb2FkaW5nOiBpIH07XG4gICAgcmV0dXJuIHMgJiYgKHAuZXJyb3IgPSBzKSwgaCAmJiAocC5pbml0UmVzdWx0ID0gaCksIHA7XG4gIH0sIFtpLCBoLCBzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gYy5jcmVhdGVFbGVtZW50KHUuUHJvdmlkZXIsIHsgdmFsdWU6IFMgfSwgZSk7XG59XG5mdW5jdGlvbiBSKHsgb3B0aW9uczogdCA9IHt9LCBjaGlsZHJlbjogZSB9KSB7XG4gIGNvbnN0IGkgPSBmKCgpID0+IHtcbiAgICBjb25zdCBuID0geyBsb2FkaW5nOiAhMSB9O1xuICAgIHRyeSB7XG4gICAgICBuLmluaXRSZXN1bHQgPSB2KHsgLi4udCwgYXN5bmM6ICExIH0pO1xuICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgIG4uZXJyb3IgPSBzO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfSwgW10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGMuY3JlYXRlRWxlbWVudCh1LlByb3ZpZGVyLCB7IHZhbHVlOiBpIH0sIGUpO1xufVxuZnVuY3Rpb24gRyh0KSB7XG4gIHZhciBlO1xuICByZXR1cm4gKGUgPSB0Lm9wdGlvbnMpICE9IG51bGwgJiYgZS5hc3luYyA/IC8qIEBfX1BVUkVfXyAqLyBjLmNyZWF0ZUVsZW1lbnQoQywgeyAuLi50IH0pIDogLyogQF9fUFVSRV9fICovIGMuY3JlYXRlRWxlbWVudChSLCB7IC4uLnQgfSk7XG59XG5mdW5jdGlvbiB3KCkge1xuICByZXR1cm4gRSh1KTtcbn1cbmZ1bmN0aW9uIFAodCkge1xuICBjb25zdCB7IGluaXRSZXN1bHQ6IGUgfSA9IHcoKTtcbiAgaWYgKCFlKVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGdldCBpbml0IHJlc3VsdCBrZXkgXCIke3R9XCIgYXMgbG9uZyBhcyBTREsgaXMgbm90IGluaXRpYWxpemVkYCk7XG4gIHJldHVybiBlW3RdO1xufVxuZnVuY3Rpb24gbSh0KSB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKFxuICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSxcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KVxuICApO1xufVxuZnVuY3Rpb24gYih0KSB7XG4gIGNvbnN0IGUgPSBQKHQpLCBbaSwgbl0gPSBhKG0oZSkpO1xuICByZXR1cm4gZygoKSA9PiBlLm9uKFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICBuKG0oZSkpO1xuICB9KSwgW2VdKSwgaTtcbn1cbmZ1bmN0aW9uIE4odCkge1xuICByZXR1cm4gZnVuY3Rpb24oaSkge1xuICAgIGNvbnN0IG4gPSB7XG4gICAgICAuLi5pLFxuICAgICAgc2RrOiB3KClcbiAgICB9O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gYy5jcmVhdGVFbGVtZW50KHQsIHsgLi4ubiB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHIodCwgZSkge1xuICByZXR1cm4gZSA/ICgpID0+IGIodCkgOiAoKSA9PiBQKHQpO1xufVxuY29uc3QgayA9IHIoXCJiYWNrQnV0dG9uXCIsICEwKSwgSiA9IG8oXCJiYWNrQnV0dG9uXCIsIGspLCB4ID0gcihcImNsb3NpbmdCZWhhdmlvclwiLCAhMCksIFggPSBvKFwiY2xvc2luZ0JlaGF2aW9yXCIsIHgpLCBJID0gcihcImNsb3VkU3RvcmFnZVwiKSwgWSA9IG8oXCJjbG91ZFN0b3JhZ2VcIiwgSSksIE8gPSByKFwiaGFwdGljRmVlZGJhY2tcIiksIFogPSBvKFwiaGFwdGljRmVlZGJhY2tcIiwgTyksIEEgPSByKFwiaW5pdERhdGFcIiksIF8gPSBvKFwiaW5pdERhdGFcIiwgQSksIE0gPSByKFwiaW5pdERhdGFSYXdcIiksIHR0ID0gbyhcImluaXREYXRhUmF3XCIsIE0pLCBqID0gcihcImludm9pY2VcIiwgITApLCBldCA9IG8oXCJpbnZvaWNlXCIsIGopO1xuZnVuY3Rpb24gRigpIHtcbiAgcmV0dXJuIGYoKCkgPT4geSgpLmxhdW5jaFBhcmFtcywgW10pO1xufVxuZnVuY3Rpb24gbnQodCkge1xuICByZXR1cm4gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gYy5jcmVhdGVFbGVtZW50KHQsIHsgLi4uaSwgbGF1bmNoUGFyYW1zOiBGKCkgfSk7XG4gIH07XG59XG5jb25zdCBIID0gcihcIm1haW5CdXR0b25cIiwgITApLCBvdCA9IG8oXCJtYWluQnV0dG9uXCIsIEgpLCBLID0gcihcIm1pbmlBcHBcIiwgITApLCBydCA9IG8oXCJtaW5pQXBwXCIsIEspLCBMID0gcihcInBvcHVwXCIsICEwKSwgaXQgPSBvKFwicG9wdXBcIiwgTCksIFUgPSByKFwicG9zdEV2ZW50XCIpLCBjdCA9IG8oXCJwb3N0RXZlbnRcIiwgVSksIFYgPSByKFwic2V0dGluZ3NCdXR0b25cIiwgITApLCBzdCA9IG8oXCJzZXR0aW5nc0J1dHRvblwiLCBWKSwgVyA9IHIoXCJxclNjYW5uZXJcIiwgITApLCBhdCA9IG8oXCJxclNjYW5uZXJcIiwgVyksICQgPSByKFwidGhlbWVQYXJhbXNcIiwgITApLCB1dCA9IG8oXCJ0aGVtZVBhcmFtc1wiLCAkKSwgcSA9IHIoXCJ1dGlsc1wiKSwgbHQgPSBvKFwidXRpbHNcIiwgcSksIFEgPSByKFwidmlld3BvcnRcIiwgITApLCBodCA9IG8oXCJ2aWV3cG9ydFwiLCBRKTtcbmZ1bmN0aW9uIGQodCwgZSA9IHt9KSB7XG4gIHJldHVybiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyAvKiBAX19QVVJFX18gKi8gYy5jcmVhdGVFbGVtZW50KHQsIHsgLi4uZSB9KSA6IHQ7XG59XG5mdW5jdGlvbiBwdCh0KSB7XG4gIGNvbnN0IHsgbG9hZGluZzogZSwgaW5pdFJlc3VsdDogaSwgZXJyb3I6IG4gfSA9IHcoKTtcbiAgcmV0dXJuIGkgPyB0LmNoaWxkcmVuIDogbiA/IGQodC5lcnJvciwgeyBlcnJvcjogbiB9KSA6IGQoZSA/IHQubG9hZGluZyA6IHQuaW5pdGlhbCk7XG59XG5leHBvcnQge1xuICBwdCBhcyBEaXNwbGF5R2F0ZSxcbiAgRyBhcyBTREtQcm92aWRlcixcbiAgayBhcyB1c2VCYWNrQnV0dG9uLFxuICB4IGFzIHVzZUNsb3NpbmdCZWhhdmlvcixcbiAgSSBhcyB1c2VDbG91ZFN0b3JhZ2UsXG4gIE8gYXMgdXNlSGFwdGljRmVlZGJhY2ssXG4gIEEgYXMgdXNlSW5pdERhdGEsXG4gIE0gYXMgdXNlSW5pdERhdGFSYXcsXG4gIGogYXMgdXNlSW52b2ljZSxcbiAgRiBhcyB1c2VMYXVuY2hQYXJhbXMsXG4gIEggYXMgdXNlTWFpbkJ1dHRvbixcbiAgSyBhcyB1c2VNaW5pQXBwLFxuICBMIGFzIHVzZVBvcHVwLFxuICBVIGFzIHVzZVBvc3RFdmVudCxcbiAgVyBhcyB1c2VRUlNjYW5uZXIsXG4gIHcgYXMgdXNlU0RLQ29udGV4dCxcbiAgViBhcyB1c2VTZXR0aW5nc0J1dHRvbixcbiAgJCBhcyB1c2VUaGVtZVBhcmFtcyxcbiAgcSBhcyB1c2VVdGlscyxcbiAgUSBhcyB1c2VWaWV3cG9ydCxcbiAgSiBhcyB3aXRoQmFja0J1dHRvbixcbiAgWCBhcyB3aXRoQ2xvc2luZ0JlaGF2aW9yLFxuICBZIGFzIHdpdGhDbG91ZFN0b3JhZ2UsXG4gIFogYXMgd2l0aEhhcHRpY0ZlZWRiYWNrLFxuICBfIGFzIHdpdGhJbml0RGF0YSxcbiAgdHQgYXMgd2l0aEluaXREYXRhUmF3LFxuICBldCBhcyB3aXRoSW52b2ljZSxcbiAgbnQgYXMgd2l0aExhdW5jaFBhcmFtcyxcbiAgb3QgYXMgd2l0aE1haW5CdXR0b24sXG4gIHJ0IGFzIHdpdGhNaW5pQXBwLFxuICBpdCBhcyB3aXRoUG9wdXAsXG4gIGN0IGFzIHdpdGhQb3N0RXZlbnQsXG4gIGF0IGFzIHdpdGhRUlNjYW5uZXIsXG4gIE4gYXMgd2l0aFNES0NvbnRleHQsXG4gIHN0IGFzIHdpdGhTZXR0aW5nc0J1dHRvbixcbiAgdXQgYXMgd2l0aFRoZW1lUGFyYW1zLFxuICBsdCBhcyB3aXRoVXRpbHMsXG4gIGh0IGFzIHdpdGhWaWV3cG9ydFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tma.js+sdk-react@1.1.0_@types+react@18.2.45_react@18.2.0/node_modules/@tma.js/sdk-react/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tma.js+sdk@1.2.0/node_modules/@tma.js/sdk/dist/index.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tma.js+sdk@1.2.0/node_modules/@tma.js/sdk/dist/index.mjs ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackButton: function() { return /* binding */ ve; },\n/* harmony export */   ClosingBehavior: function() { return /* binding */ ke; },\n/* harmony export */   CloudStorage: function() { return /* binding */ xe; },\n/* harmony export */   HapticFeedback: function() { return /* binding */ qe; },\n/* harmony export */   HashNavigator: function() { return /* binding */ Lt; },\n/* harmony export */   InitData: function() { return /* binding */ Ut; },\n/* harmony export */   Invoice: function() { return /* binding */ ze; },\n/* harmony export */   MainButton: function() { return /* binding */ Ie; },\n/* harmony export */   MethodUnsupportedError: function() { return /* binding */ tt; },\n/* harmony export */   MiniApp: function() { return /* binding */ Te; },\n/* harmony export */   Navigator: function() { return /* binding */ Xe; },\n/* harmony export */   ParameterUnsupportedError: function() { return /* binding */ et; },\n/* harmony export */   Popup: function() { return /* binding */ Qe; },\n/* harmony export */   QRScanner: function() { return /* binding */ Ze; },\n/* harmony export */   SettingsButton: function() { return /* binding */ We; },\n/* harmony export */   ThemeParams: function() { return /* binding */ Ft; },\n/* harmony export */   TimeoutError: function() { return /* binding */ J; },\n/* harmony export */   Utils: function() { return /* binding */ Ke; },\n/* harmony export */   Viewport: function() { return /* binding */ G; },\n/* harmony export */   chatParser: function() { return /* binding */ Ht; },\n/* harmony export */   classNames: function() { return /* binding */ Pe; },\n/* harmony export */   compareVersions: function() { return /* binding */ me; },\n/* harmony export */   createPostEvent: function() { return /* binding */ ye; },\n/* harmony export */   getHash: function() { return /* binding */ pr; },\n/* harmony export */   init: function() { return /* binding */ ur; },\n/* harmony export */   initDataParser: function() { return /* binding */ wt; },\n/* harmony export */   invokeCustomMethod: function() { return /* binding */ N; },\n/* harmony export */   isColorDark: function() { return /* binding */ ft; },\n/* harmony export */   isIframe: function() { return /* binding */ vt; },\n/* harmony export */   isRGB: function() { return /* binding */ lt; },\n/* harmony export */   isRGBShort: function() { return /* binding */ Ot; },\n/* harmony export */   isRecord: function() { return /* binding */ H; },\n/* harmony export */   isTMA: function() { return /* binding */ sr; },\n/* harmony export */   isTimeoutError: function() { return /* binding */ cr; },\n/* harmony export */   launchParamsParser: function() { return /* binding */ mt; },\n/* harmony export */   mergeClassNames: function() { return /* binding */ hr; },\n/* harmony export */   off: function() { return /* binding */ I; },\n/* harmony export */   on: function() { return /* binding */ y; },\n/* harmony export */   once: function() { return /* binding */ or; },\n/* harmony export */   parseInitData: function() { return /* binding */ er; },\n/* harmony export */   parseLaunchParams: function() { return /* binding */ yt; },\n/* harmony export */   parseThemeParams: function() { return /* binding */ bt; },\n/* harmony export */   postEvent: function() { return /* binding */ f; },\n/* harmony export */   request: function() { return /* binding */ m; },\n/* harmony export */   requestThemeParams: function() { return /* binding */ rr; },\n/* harmony export */   requestViewport: function() { return /* binding */ At; },\n/* harmony export */   retrieveLaunchData: function() { return /* binding */ Ct; },\n/* harmony export */   serializeLaunchParams: function() { return /* binding */ Zt; },\n/* harmony export */   serializeThemeParams: function() { return /* binding */ Gt; },\n/* harmony export */   setDebug: function() { return /* binding */ nr; },\n/* harmony export */   setTargetOrigin: function() { return /* binding */ ir; },\n/* harmony export */   subscribe: function() { return /* binding */ ar; },\n/* harmony export */   supports: function() { return /* binding */ A; },\n/* harmony export */   themeParamsParser: function() { return /* binding */ _t; },\n/* harmony export */   toRGB: function() { return /* binding */ dt; },\n/* harmony export */   unsubscribe: function() { return /* binding */ be; },\n/* harmony export */   userParser: function() { return /* binding */ rt; },\n/* harmony export */   withTimeout: function() { return /* binding */ xt; }\n/* harmony export */ });\nvar $t = Object.defineProperty;\nvar Tt = (r, t, e) => t in r ? $t(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;\nvar o = (r, t, e) => (Tt(r, typeof t != \"symbol\" ? t + \"\" : t, e), e);\nfunction H(r) {\n  return typeof r == \"object\" && r !== null && !Array.isArray(r);\n}\nfunction ht() {\n  return performance.getEntriesByType(\"navigation\")[0] || null;\n}\nfunction Bt() {\n  const r = ht();\n  return r ? r.type === \"reload\" : null;\n}\nfunction R() {\n  return new TypeError(\"Value has unexpected type\");\n}\nclass F extends Error {\n  constructor(e, { cause: s, type: n } = {}) {\n    super(`Unable to parse value${n ? ` as ${n}` : \"\"}`, { cause: s });\n    /**\n     * Parser name.\n     */\n    o(this, \"type\");\n    this.value = e, Object.setPrototypeOf(this, F.prototype), this.type = n;\n  }\n}\nclass z {\n  constructor(t, e, s) {\n    this.parser = t, this.isOptional = e, this.type = s;\n  }\n  parse(t) {\n    if (!(this.isOptional && t === void 0))\n      try {\n        return this.parser(t);\n      } catch (e) {\n        throw new F(t, { type: this.type, cause: e });\n      }\n  }\n  optional() {\n    return this.isOptional = !0, this;\n  }\n}\nfunction Dt(r) {\n  if (Array.isArray(r))\n    return r;\n  if (typeof r == \"string\")\n    try {\n      const t = JSON.parse(r);\n      if (Array.isArray(t))\n        return t;\n    } catch {\n    }\n  throw R();\n}\nclass Wt extends z {\n  constructor(e, s, n) {\n    super(Dt, s, n);\n    o(this, \"itemParser\");\n    this.itemParser = typeof e == \"function\" ? e : e.parse.bind(e);\n  }\n  parse(e) {\n    const s = super.parse(e);\n    return s === void 0 ? s : s.map(this.itemParser);\n  }\n  of(e) {\n    return this.itemParser = typeof e == \"function\" ? e : e.parse.bind(e), this;\n  }\n}\nfunction V(r, t) {\n  return () => new z(r, !1, t);\n}\nclass j extends Error {\n  constructor(t, { cause: e, type: s } = {}) {\n    super(`Unable to parse field \"${t}\"${s ? ` as ${s}` : \"\"}`, { cause: e }), Object.setPrototypeOf(this, j.prototype);\n  }\n}\nfunction ut(r, t) {\n  const e = {};\n  for (const s in r) {\n    const n = r[s];\n    if (!n)\n      continue;\n    let i, a;\n    if (typeof n == \"function\" || \"parse\" in n)\n      i = s, a = typeof n == \"function\" ? n : n.parse.bind(n);\n    else {\n      const { type: p } = n;\n      i = n.from || s, a = typeof p == \"function\" ? p : p.parse.bind(p);\n    }\n    let c;\n    const u = t(i);\n    try {\n      c = a(u);\n    } catch (p) {\n      throw p instanceof F ? new j(i, {\n        type: p.type,\n        cause: p\n      }) : new j(i, { cause: p });\n    }\n    c !== void 0 && (e[s] = c);\n  }\n  return e;\n}\nfunction Nt(r) {\n  return new Wt((t) => t, !1, r);\n}\nconst P = V((r) => {\n  if (typeof r == \"boolean\")\n    return r;\n  const t = String(r);\n  if (t === \"1\" || t === \"true\")\n    return !0;\n  if (t === \"0\" || t === \"false\")\n    return !1;\n  throw R();\n}, \"boolean\"), k = V((r) => {\n  if (typeof r == \"number\")\n    return r;\n  if (typeof r == \"string\") {\n    const t = Number(r);\n    if (!Number.isNaN(t))\n      return t;\n  }\n  throw R();\n}, \"number\"), pt = V((r) => r instanceof Date ? r : new Date(k().parse(r) * 1e3), \"Date\");\nfunction Y(r) {\n  let t = r;\n  if (typeof t == \"string\" && (t = JSON.parse(t)), typeof t != \"object\" || t === null || Array.isArray(t))\n    throw R();\n  return t;\n}\nfunction g(r, t) {\n  return new z((e) => {\n    const s = Y(e);\n    return ut(r, (n) => s[n]);\n  }, !1, t);\n}\nfunction lt(r) {\n  return /^#[\\da-f]{6}$/i.test(r);\n}\nfunction Ot(r) {\n  return /^#[\\da-f]{3}$/i.test(r);\n}\nfunction dt(r) {\n  const t = r.replace(/\\s/g, \"\").toLowerCase();\n  if (lt(t))\n    return t;\n  if (Ot(t)) {\n    let s = \"#\";\n    for (let n = 0; n < 3; n += 1)\n      s += t[1 + n].repeat(2);\n    return s;\n  }\n  const e = t.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || t.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (e === null)\n    throw new Error(`Value \"${r}\" does not satisfy any of known RGB formats.`);\n  return e.slice(1).reduce((s, n) => {\n    const i = parseInt(n, 10).toString(16);\n    return s + (i.length === 1 ? \"0\" : \"\") + i;\n  }, \"#\");\n}\nfunction ft(r) {\n  const t = dt(r);\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce((s, n, i) => {\n      const a = parseInt(t.slice(1 + i * 2, 1 + (i + 1) * 2), 16);\n      return s + a * a * n;\n    }, 0)\n  ) < 120;\n}\nconst h = V((r) => {\n  if (typeof r == \"string\" || typeof r == \"number\")\n    return r.toString();\n  throw R();\n}, \"string\"), gt = V((r) => dt(h().parse(r)), \"rgb\");\nfunction X(r, t) {\n  return new z((e) => {\n    if (typeof e != \"string\" && !(e instanceof URLSearchParams))\n      throw R();\n    const s = typeof e == \"string\" ? new URLSearchParams(e) : e;\n    return ut(r, (n) => {\n      const i = s.get(n);\n      return i === null ? void 0 : i;\n    });\n  }, !1, t);\n}\nfunction Ht() {\n  return g({\n    id: k(),\n    type: h(),\n    title: h(),\n    photoUrl: {\n      type: h().optional(),\n      from: \"photo_url\"\n    },\n    username: h().optional()\n  }, \"Chat\");\n}\nclass Ut {\n  constructor(t) {\n    this.initData = t;\n  }\n  /**\n   * @see InitDataParsed.authDate\n   */\n  get authDate() {\n    return this.initData.authDate;\n  }\n  /**\n   * @see InitDataParsed.canSendAfter\n   */\n  get canSendAfter() {\n    return this.initData.canSendAfter;\n  }\n  /**\n   * Date after which it is allowed to call\n   * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n   */\n  get canSendAfterDate() {\n    const { canSendAfter: t } = this;\n    return t === void 0 ? void 0 : new Date(this.authDate.getTime() + t * 1e3);\n  }\n  /**\n   * @see InitDataParsed.chat\n   */\n  get chat() {\n    return this.initData.chat;\n  }\n  /**\n   * @see InitDataParsed.chatType\n   */\n  get chatType() {\n    return this.initData.chatType;\n  }\n  /**\n   * @see InitDataParsed.chatInstance\n   */\n  get chatInstance() {\n    return this.initData.chatInstance;\n  }\n  /**\n   * @see InitDataParsed.hash\n   */\n  get hash() {\n    return this.initData.hash;\n  }\n  /**\n   * @see InitDataParsed.queryId\n   */\n  get queryId() {\n    return this.initData.queryId;\n  }\n  /**\n   * @see InitDataParsed.receiver\n   */\n  get receiver() {\n    return this.initData.receiver;\n  }\n  /**\n   * @see InitDataParsed.startParam\n   */\n  get startParam() {\n    return this.initData.startParam;\n  }\n  /**\n   * @see InitDataParsed.user\n   */\n  get user() {\n    return this.initData.user;\n  }\n}\nfunction rt() {\n  return g({\n    addedToAttachmentMenu: {\n      type: P().optional(),\n      from: \"added_to_attachment_menu\"\n    },\n    allowsWriteToPm: {\n      type: P().optional(),\n      from: \"allows_write_to_pm\"\n    },\n    firstName: {\n      type: h(),\n      from: \"first_name\"\n    },\n    id: k(),\n    isBot: {\n      type: P().optional(),\n      from: \"is_bot\"\n    },\n    isPremium: {\n      type: P().optional(),\n      from: \"is_premium\"\n    },\n    languageCode: {\n      type: h().optional(),\n      from: \"language_code\"\n    },\n    lastName: {\n      type: h().optional(),\n      from: \"last_name\"\n    },\n    photoUrl: {\n      type: h().optional(),\n      from: \"photo_url\"\n    },\n    username: h().optional()\n  }, \"User\");\n}\nfunction wt() {\n  return X({\n    authDate: {\n      type: pt(),\n      from: \"auth_date\"\n    },\n    canSendAfter: {\n      type: k().optional(),\n      from: \"can_send_after\"\n    },\n    chat: Ht().optional(),\n    chatInstance: {\n      type: h().optional(),\n      from: \"chat_instance\"\n    },\n    chatType: {\n      type: h().optional(),\n      from: \"chat_type\"\n    },\n    hash: h(),\n    queryId: {\n      type: h().optional(),\n      from: \"query_id\"\n    },\n    receiver: rt().optional(),\n    startParam: {\n      type: h().optional(),\n      from: \"start_param\"\n    },\n    user: rt().optional()\n  }, \"InitData\");\n}\nfunction er(r) {\n  return wt().parse(r);\n}\nfunction Mt(r) {\n  return r.replace(/(^|_)bg/, (t, e) => `${e}background`).replace(/_([a-z])/g, (t, e) => e.toUpperCase());\n}\nfunction jt(r) {\n  return r.replace(/[A-Z]/g, (t) => `_${t.toLowerCase()}`).replace(/(^|_)background/, (t, e) => `${e}bg`);\n}\nconst _t = V(\n  (r) => {\n    const t = gt().optional();\n    return Object.entries(Y(r)).reduce((e, [s, n]) => (e[Mt(s)] = t.parse(n), e), {});\n  },\n  \"ThemeParams\"\n);\nfunction bt(r) {\n  return _t().parse(r);\n}\nfunction rr(r = {}) {\n  return m(\"web_app_request_theme\", \"theme_changed\", r).then(bt);\n}\nfunction Gt(r) {\n  return JSON.stringify(\n    Object.entries(r).reduce((t, [e, s]) => (s && (t[jt(e)] = s), t), {})\n  );\n}\nclass w {\n  constructor() {\n    o(this, \"listeners\", /* @__PURE__ */ new Map());\n    o(this, \"subscribeListeners\", []);\n  }\n  /**\n   * Adds specified event listener.\n   * @param event - event name.\n   * @param listener - event listener.\n   * @param once - should listener called only once.\n   */\n  addListener(t, e, s) {\n    let n = this.listeners.get(t);\n    return n || (n = [], this.listeners.set(t, n)), n.push([e, s]), () => this.off(t, e);\n  }\n  emit(t, ...e) {\n    this.subscribeListeners.forEach((n) => n(t, ...e));\n    const s = this.listeners.get(t);\n    s && s.forEach(([n, i], a) => {\n      n(...e), i && s.splice(a, 1);\n    });\n  }\n  /**\n   * Adds event listener.\n   * @param event - event name.\n   * @param listener - event listener.\n   * @returns Function to remove event listener.\n   */\n  on(t, e) {\n    return this.addListener(t, e, !1);\n  }\n  /**\n   * Adds event listener following the logic, described in `on` method, but calls specified\n   * listener only once, removing it after.\n   * @param event - event name.\n   * @param listener - event listener.\n   * @returns Function to remove event listener.\n   * @see on\n   */\n  once(t, e) {\n    return this.addListener(t, e, !0);\n  }\n  /**\n   * Removes event listener. In case, specified listener was bound several times, it removes\n   * only a single one.\n   * @param event - event name.\n   * @param listener - event listener.\n   */\n  off(t, e) {\n    const s = this.listeners.get(t);\n    if (s) {\n      for (let n = 0; n < s.length; n += 1)\n        if (e === s[n][0]) {\n          s.splice(n, 1);\n          return;\n        }\n    }\n  }\n  /**\n   * Adds event listener to all events.\n   * @param listener - events listener.\n   * @returns Function to remove event listener.\n   * @see on\n   * @see once\n   */\n  subscribe(t) {\n    return this.subscribeListeners.push(t), () => this.unsubscribe(t);\n  }\n  /**\n   * Removes global event listener. In case, specified listener was bound several times, it removes\n   * only a single one.\n   * @param listener - events listener.\n   * @returns Function to remove event listener.\n   */\n  unsubscribe(t) {\n    for (let e = 0; e < this.subscribeListeners.length; e += 1)\n      if (this.subscribeListeners[e] === t) {\n        this.subscribeListeners.splice(e, 1);\n        return;\n      }\n  }\n}\nclass _ {\n  constructor(t, e) {\n    this.state = t, this.ee = e;\n  }\n  internalSet(t, e) {\n    return this.state[t] === e || e === void 0 ? !1 : (this.state[t] = e, this.ee.emit(`change:${t}`, e), !0);\n  }\n  /**\n   * Returns copy of current state.\n   */\n  clone() {\n    return { ...this.state };\n  }\n  set(t, e) {\n    let s = !1;\n    if (typeof t == \"string\")\n      s = this.internalSet(t, e);\n    else\n      for (const n in t)\n        this.internalSet(n, t[n]) && (s = !0);\n    s && this.ee.emit(\"change\");\n  }\n  /**\n   * Returns value by specified key.\n   * @param key - state key.\n   */\n  get(t) {\n    return this.state[t];\n  }\n}\nclass Ft {\n  constructor(t) {\n    o(this, \"ee\", new w());\n    o(this, \"state\");\n    /**\n     * Adds new event listener.\n     */\n    o(this, \"on\", this.ee.on.bind(this.ee));\n    /**\n     * Removes event listener.\n     */\n    o(this, \"off\", this.ee.off.bind(this.ee));\n    this.state = new _(t, this.ee);\n  }\n  /**\n   * @since v6.10\n   */\n  get accentTextColor() {\n    return this.get(\"accentTextColor\");\n  }\n  get backgroundColor() {\n    return this.get(\"backgroundColor\");\n  }\n  get buttonColor() {\n    return this.get(\"buttonColor\");\n  }\n  get buttonTextColor() {\n    return this.get(\"buttonTextColor\");\n  }\n  get destructiveTextColor() {\n    return this.get(\"destructiveTextColor\");\n  }\n  /**\n   * Retrieves palette color value by its name.\n   * @param key - palette key name.\n   */\n  get(t) {\n    return this.state.get(t);\n  }\n  /**\n   * Returns the copy of the internal state of the current component instance.\n   */\n  getState() {\n    return this.state.clone();\n  }\n  /**\n   * @since v6.10\n   */\n  get headerBackgroundColor() {\n    return this.get(\"headerBackgroundColor\");\n  }\n  get hintColor() {\n    return this.get(\"hintColor\");\n  }\n  /**\n   * Returns true in case, current color scheme is recognized as dark. This\n   * value is calculated according to theme background color.\n   */\n  get isDark() {\n    return !this.backgroundColor || ft(this.backgroundColor);\n  }\n  get linkColor() {\n    return this.get(\"linkColor\");\n  }\n  get secondaryBackgroundColor() {\n    return this.get(\"secondaryBackgroundColor\");\n  }\n  /**\n   * @since v6.10\n   */\n  get sectionBackgroundColor() {\n    return this.get(\"sectionBackgroundColor\");\n  }\n  /**\n   * @since v6.10\n   */\n  get sectionHeaderTextColor() {\n    return this.get(\"sectionHeaderTextColor\");\n  }\n  /**\n   * Starts listening to theme changes and applies them.\n   * @returns Function to stop listening.\n   */\n  listen() {\n    return y(\"theme_changed\", (t) => {\n      this.state.set(bt(t.theme_params));\n    });\n  }\n  /**\n   * @since v6.10\n   */\n  get subtitleTextColor() {\n    return this.get(\"subtitleTextColor\");\n  }\n  get textColor() {\n    return this.get(\"textColor\");\n  }\n}\nfunction mt() {\n  return X({\n    botInline: {\n      type: P().optional(),\n      from: \"tgWebAppBotInline\"\n    },\n    initData: {\n      type: wt().optional(),\n      from: \"tgWebAppData\"\n    },\n    initDataRaw: {\n      type: h().optional(),\n      from: \"tgWebAppData\"\n    },\n    platform: {\n      type: h(),\n      from: \"tgWebAppPlatform\"\n    },\n    showSettings: {\n      type: P().optional(),\n      from: \"tgWebAppShowSettings\"\n    },\n    themeParams: {\n      type: _t(),\n      from: \"tgWebAppThemeParams\"\n    },\n    version: {\n      type: h(),\n      from: \"tgWebAppVersion\"\n    }\n  }, \"LaunchParams\");\n}\nfunction yt(r) {\n  return mt().parse(r);\n}\nfunction zt() {\n  return yt(window.location.hash.slice(1));\n}\nfunction Jt() {\n  const r = ht();\n  if (!r)\n    throw new Error(\"Unable to get first navigation entry.\");\n  const t = r.name.match(/#(.*)/);\n  if (!t)\n    throw new Error(\"First navigation entry does not contain hash part.\");\n  return yt(t[1]);\n}\nfunction Qt() {\n  try {\n    return Jt();\n  } catch {\n  }\n  try {\n    return zt();\n  } catch {\n  }\n  return null;\n}\nfunction Zt(r) {\n  const {\n    initDataRaw: t,\n    themeParams: e,\n    platform: s,\n    version: n,\n    showSettings: i,\n    botInline: a\n  } = r, c = new URLSearchParams();\n  return t && c.set(\"tgWebAppData\", t), c.set(\"tgWebAppPlatform\", s), c.set(\"tgWebAppThemeParams\", Gt(e)), c.set(\"tgWebAppVersion\", n), typeof i == \"boolean\" && c.set(\"tgWebAppShowSettings\", i ? \"1\" : \"0\"), typeof a == \"boolean\" && c.set(\"tgWebAppBotInline\", a ? \"1\" : \"0\"), c.toString();\n}\nconst Et = \"telegram-mini-apps-launch-params\";\nfunction Kt() {\n  const r = sessionStorage.getItem(Et);\n  return r ? mt().parse(r) : null;\n}\nfunction Yt(r) {\n  sessionStorage.setItem(Et, Zt(r));\n}\nfunction Xt() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nfunction te() {\n  const r = Kt(), t = Qt(), e = Bt();\n  if (r) {\n    if (t)\n      return {\n        launchParams: t,\n        isPageReload: Xt() ? e || r.initDataRaw === t.initDataRaw : !0\n      };\n    if (e)\n      return {\n        launchParams: r,\n        isPageReload: e\n      };\n    throw new Error(\"Unable to retrieve current launch parameters, which must exist.\");\n  }\n  if (t)\n    return {\n      launchParams: t,\n      isPageReload: !1\n    };\n  throw new Error(\"Unable to retrieve any launch parameters.\");\n}\nconst st = \"tmajsLaunchData\";\nfunction Ct() {\n  const r = window[st];\n  if (r)\n    return r;\n  const t = te();\n  return window[st] = t, Yt(t.launchParams), t;\n}\nfunction sr() {\n  try {\n    return Ct(), !0;\n  } catch {\n    return !1;\n  }\n}\nfunction ee(r) {\n  return \"external\" in r && H(r.external) && \"notify\" in r.external && typeof r.external.notify == \"function\";\n}\nfunction re(r) {\n  return \"TelegramWebviewProxy\" in r && H(r.TelegramWebviewProxy) && \"postEvent\" in r.TelegramWebviewProxy && typeof r.TelegramWebviewProxy.postEvent == \"function\";\n}\nfunction vt() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nclass tt extends Error {\n  constructor(t, e) {\n    super(`Method \"${t}\" is unsupported in the Mini Apps version ${e}.`), Object.setPrototypeOf(this, tt.prototype);\n  }\n}\nclass et extends Error {\n  constructor(t, e, s) {\n    super(`Parameter \"${e}\" in method \"${t}\" is unsupported in the Mini Apps version ${s}.`), Object.setPrototypeOf(this, et.prototype);\n  }\n}\nclass Pt {\n  constructor(t, e) {\n    this.prefix = t, this.enabled = e;\n  }\n  /**\n   * Prints message into a console in case, logger is currently enabled.\n   * @param level - log level.\n   * @param args - arguments.\n   */\n  print(t, ...e) {\n    if (!this.enabled)\n      return;\n    const s = /* @__PURE__ */ new Date(), n = Intl.DateTimeFormat(\"en-GB\", {\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      fractionalSecondDigits: 3,\n      timeZone: \"UTC\"\n    }).format(s);\n    console[t](`[${n}]`, this.prefix, ...e);\n  }\n  /**\n   * Disables the logger.\n   */\n  disable() {\n    this.enabled = !1;\n  }\n  /**\n   * Prints error message into a console.\n   * @param args\n   */\n  error(...t) {\n    this.print(\"error\", ...t);\n  }\n  /**\n   * Enables the logger.\n   */\n  enable() {\n    this.enabled = !0;\n  }\n  /**\n   * Prints log message into a console.\n   * @param args\n   */\n  log(...t) {\n    this.print(\"log\", ...t);\n  }\n  /**\n   * Prints warning message into a console.\n   * @param args\n   */\n  warn(...t) {\n    this.print(\"warn\", ...t);\n  }\n}\nlet St = \"https://web.telegram.org\";\nconst q = new Pt(\"[SDK]\", !1);\nfunction nr(r) {\n  if (r) {\n    q.enable();\n    return;\n  }\n  q.disable();\n}\nfunction ir(r) {\n  St = r;\n}\nfunction se() {\n  return St;\n}\nconst ne = g({\n  eventType: h(),\n  eventData: (r) => r\n});\nfunction ie(r, t) {\n  window.dispatchEvent(new MessageEvent(\"message\", {\n    data: JSON.stringify({ eventType: r, eventData: t })\n  }));\n}\nfunction oe() {\n  const r = window;\n  \"TelegramGameProxy_receiveEvent\" in r || [\n    [\"TelegramGameProxy_receiveEvent\"],\n    // Windows Phone.\n    [\"TelegramGameProxy\", \"receiveEvent\"],\n    // Desktop.\n    [\"Telegram\", \"WebView\", \"receiveEvent\"]\n    // Android and iOS.\n  ].forEach((t) => {\n    let e = r;\n    t.forEach((s, n, i) => {\n      if (n === i.length - 1) {\n        e[s] = ie;\n        return;\n      }\n      s in e || (e[s] = {}), e = e[s];\n    });\n  });\n}\nfunction ae(r) {\n  oe(), window.addEventListener(\"message\", (t) => {\n    try {\n      const { eventType: e, eventData: s } = ne.parse(t.data);\n      r(e, s);\n    } catch {\n    }\n  });\n}\nfunction ce() {\n  return g({\n    req_id: h(),\n    data: (r) => r === null ? r : h().optional().parse(r)\n  });\n}\nfunction he() {\n  return g({\n    req_id: h(),\n    result: (r) => r,\n    error: h().optional()\n  });\n}\nfunction ue() {\n  return g({\n    slug: h(),\n    status: h()\n  });\n}\nfunction pe() {\n  return g({ status: h() });\n}\nfunction le() {\n  return g({\n    button_id: (r) => r == null ? void 0 : h().parse(r)\n  });\n}\nfunction de() {\n  return g({\n    data: h().optional()\n  });\n}\nfunction fe() {\n  return g({\n    theme_params: (r) => {\n      const t = gt().optional();\n      return Object.entries(Y(r)).reduce((e, [s, n]) => (e[s] = t.parse(n), e), {});\n    }\n  });\n}\nfunction ge() {\n  return g({\n    height: k(),\n    width: (r) => r == null ? window.innerWidth : k().parse(r),\n    is_state_stable: P(),\n    is_expanded: P()\n  });\n}\nfunction we() {\n  return g({ status: h() });\n}\nfunction _e() {\n  const r = new w(), t = (e, ...s) => {\n    q.log(\"Emitting processed event:\", e, ...s), r.emit(e, ...s);\n  };\n  return window.addEventListener(\"resize\", () => {\n    t(\"viewport_changed\", {\n      width: window.innerWidth,\n      height: window.innerHeight,\n      is_state_stable: !0,\n      is_expanded: !0\n    });\n  }), ae((e, s) => {\n    q.log(\"Received raw event:\", e, s);\n    try {\n      switch (e) {\n        case \"viewport_changed\":\n          return t(e, ge().parse(s));\n        case \"theme_changed\":\n          return t(e, fe().parse(s));\n        case \"popup_closed\":\n          return (\n            // Sent on desktop.\n            s == null ? t(e, {}) : t(e, le().parse(s))\n          );\n        case \"set_custom_style\":\n          return t(e, h().parse(s));\n        case \"qr_text_received\":\n          return t(e, de().parse(s));\n        case \"clipboard_text_received\":\n          return t(e, ce().parse(s));\n        case \"invoice_closed\":\n          return t(e, ue().parse(s));\n        case \"phone_requested\":\n          return t(\"phone_requested\", pe().parse(s));\n        case \"custom_method_invoked\":\n          return t(\"custom_method_invoked\", he().parse(s));\n        case \"write_access_requested\":\n          return t(\"write_access_requested\", we().parse(s));\n        case \"main_button_pressed\":\n        case \"back_button_pressed\":\n        case \"settings_button_pressed\":\n        case \"scan_qr_popup_closed\":\n        case \"reload_iframe\":\n          return t(e);\n        default:\n          return t(e, s);\n      }\n    } catch (n) {\n      q.error(\"Error processing event:\", n);\n    }\n  }), r;\n}\nconst Q = \"telegram-mini-apps-cached-emitter\";\nfunction U() {\n  const r = window;\n  return r[Q] === void 0 && (r[Q] = _e()), r[Q];\n}\nfunction I(r, t) {\n  U().off(r, t);\n}\nfunction y(r, t) {\n  return U().on(r, t), () => I(r, t);\n}\nfunction or(r, t) {\n  return U().once(r, t), () => I(r, t);\n}\nfunction be(r) {\n  U().unsubscribe(r);\n}\nfunction ar(r) {\n  return U().subscribe(r), () => be(r);\n}\nfunction me(r, t) {\n  const e = r.split(\".\"), s = t.split(\".\"), n = Math.max(e.length, s.length);\n  for (let i = 0; i < n; i += 1) {\n    const a = parseInt(e[i] || \"0\", 10), c = parseInt(s[i] || \"0\", 10);\n    if (a !== c)\n      return a > c ? 1 : -1;\n  }\n  return 0;\n}\nfunction v(r, t) {\n  return me(r, t) <= 0;\n}\nfunction A(r, t, e) {\n  if (typeof e == \"string\") {\n    if (r === \"web_app_open_link\" && t === \"try_instant_view\")\n      return v(\"6.4\", e);\n    if (r === \"web_app_set_header_color\" && t === \"color\")\n      return v(\"6.9\", e);\n  }\n  switch (r) {\n    case \"web_app_open_tg_link\":\n    case \"web_app_open_invoice\":\n    case \"web_app_setup_back_button\":\n    case \"web_app_set_background_color\":\n    case \"web_app_set_header_color\":\n    case \"web_app_trigger_haptic_feedback\":\n      return v(\"6.1\", t);\n    case \"web_app_open_popup\":\n      return v(\"6.2\", t);\n    case \"web_app_close_scan_qr_popup\":\n    case \"web_app_open_scan_qr_popup\":\n    case \"web_app_read_text_from_clipboard\":\n      return v(\"6.4\", t);\n    case \"web_app_switch_inline_query\":\n      return v(\"6.7\", t);\n    case \"web_app_invoke_custom_method\":\n    case \"web_app_request_write_access\":\n    case \"web_app_request_phone\":\n      return v(\"6.9\", t);\n    case \"web_app_setup_settings_button\":\n      return v(\"6.10\", t);\n    default:\n      return !0;\n  }\n}\nfunction E(r, t) {\n  return (e) => A(t[e], r);\n}\nfunction kt(r, t) {\n  return (e) => {\n    const [s, n] = t[e];\n    return A(s, n, r);\n  };\n}\nfunction f(r, t, e) {\n  let s = {}, n;\n  t === void 0 && e === void 0 ? s = {} : t !== void 0 && e !== void 0 ? (s = e, n = t) : t !== void 0 && (\"targetOrigin\" in t ? s = t : n = t);\n  const { targetOrigin: i = se() } = s;\n  if (q.log(`Calling method \"${r}\"`, n), vt()) {\n    window.parent.postMessage(JSON.stringify({\n      eventType: r,\n      eventData: n\n    }), i);\n    return;\n  }\n  if (ee(window)) {\n    window.external.notify(JSON.stringify({ eventType: r, eventData: n }));\n    return;\n  }\n  if (re(window)) {\n    window.TelegramWebviewProxy.postEvent(r, JSON.stringify(n));\n    return;\n  }\n  throw new Error(\n    \"Unable to determine current environment and possible way to send event.\"\n  );\n}\nfunction ye(r) {\n  return (t, e) => {\n    if (!A(t, r))\n      throw new tt(t, r);\n    if (H(e)) {\n      let s;\n      if (t === \"web_app_open_link\" && \"try_instant_view\" in e ? s = \"try_instant_view\" : t === \"web_app_set_header_color\" && \"color\" in e && (s = \"color\"), s && !A(t, s, r))\n        throw new et(t, s, r);\n    }\n    return f(t, e);\n  };\n}\nclass J extends Error {\n  constructor(t) {\n    super(`Async call timeout exceeded. Timeout: ${t}`), Object.setPrototypeOf(this, J.prototype);\n  }\n}\nfunction cr(r) {\n  return r instanceof J;\n}\nfunction Ee(r) {\n  return new Promise((t) => {\n    setTimeout(t, r);\n  });\n}\nfunction Ce(r) {\n  return new Promise((t, e) => {\n    setTimeout(e, r, new J(r));\n  });\n}\nfunction xt(r, t) {\n  return Promise.race([\n    r(),\n    Ce(t)\n  ]);\n}\nfunction m(r, t, e, s) {\n  let n, i, a, c;\n  typeof t == \"string\" || Array.isArray(t) ? (a = Array.isArray(t) ? t : [t], n = e) : (i = t, a = Array.isArray(e) ? e : [e], n = s), H(i) && typeof i.req_id == \"string\" && (c = i.req_id);\n  const { postEvent: u = f, timeout: p } = n || {}, l = n && \"capture\" in n ? n.capture : null, b = () => new Promise((d, C) => {\n    const x = a.map((B) => y(B, (M) => {\n      c && (!H(M) || M.req_id !== c) || typeof l == \"function\" && !l(M) || (T(), d(M));\n    })), T = () => x.forEach((B) => B());\n    try {\n      u(r, i);\n    } catch (B) {\n      T(), C(B);\n    }\n  });\n  return typeof p == \"number\" ? xt(b, p) : b();\n}\nasync function N(r, t, e, s = {}) {\n  const { result: n, error: i } = await m(\n    \"web_app_invoke_custom_method\",\n    {\n      method: r,\n      params: t,\n      req_id: e\n    },\n    \"custom_method_invoked\",\n    s\n  );\n  if (i)\n    throw new Error(i);\n  return n;\n}\nclass ve {\n  constructor(t, e, s = f) {\n    o(this, \"ee\", new w());\n    o(this, \"state\");\n    /**\n     * Adds event listener.\n     * @param event - event name.\n     * @param listener - event listener.\n     */\n    o(this, \"on\", (t, e) => t === \"click\" ? y(\"back_button_pressed\", e) : this.ee.on(t, e));\n    /**\n     * Removes event listener.\n     * @param event - event name.\n     * @param listener - event listener.\n     */\n    o(this, \"off\", (t, e) => t === \"click\" ? I(\"back_button_pressed\", e) : this.ee.off(t, e));\n    /**\n     * Checks if specified method is supported by current component.\n     */\n    o(this, \"supports\");\n    this.postEvent = s, this.state = new _({ isVisible: t }, this.ee), this.supports = E(e, {\n      show: \"web_app_setup_back_button\",\n      hide: \"web_app_setup_back_button\"\n    });\n  }\n  set isVisible(t) {\n    this.state.set(\"isVisible\", t), this.postEvent(\"web_app_setup_back_button\", { is_visible: t });\n  }\n  /**\n   * True if BackButton is currently visible.\n   */\n  get isVisible() {\n    return this.state.get(\"isVisible\");\n  }\n  /**\n   * Hides the BackButton.\n   */\n  hide() {\n    this.isVisible = !1;\n  }\n  /**\n   * Shows the BackButton.\n   */\n  show() {\n    this.isVisible = !0;\n  }\n}\nfunction nt(r, t) {\n  return r + (r.length > 0 && t.length > 0 ? ` ${t}` : t);\n}\nfunction Pe(...r) {\n  return r.reduce((t, e) => {\n    let s = \"\";\n    return typeof e == \"string\" ? s = e : typeof e == \"object\" && e !== null && (s = Object.entries(e).reduce((n, [i, a]) => a ? nt(n, i) : n, \"\")), nt(t, s);\n  }, \"\");\n}\nfunction Se(r) {\n  return typeof r == \"object\" && r !== null && !Array.isArray(null);\n}\nfunction hr(...r) {\n  return r.reduce((t, e) => (Se(e) && Object.entries(e).forEach(([s, n]) => {\n    const i = Pe(t[s], n);\n    i.length > 0 && (t[s] = i);\n  }), t), {});\n}\nclass ke {\n  constructor(t, e = f) {\n    o(this, \"ee\", new w());\n    o(this, \"state\");\n    /**\n     * Adds new event listener.\n     */\n    o(this, \"on\", this.ee.on.bind(this.ee));\n    /**\n     * Removes event listener.\n     */\n    o(this, \"off\", this.ee.off.bind(this.ee));\n    this.postEvent = e, this.state = new _({ isConfirmationNeeded: t }, this.ee);\n  }\n  set isConfirmationNeeded(t) {\n    this.state.set(\"isConfirmationNeeded\", t), this.postEvent(\"web_app_setup_closing_behavior\", { need_confirmation: t });\n  }\n  /**\n   * Returns true, if the confirmation dialog enabled while the user is trying\n   * to close the Mini App.\n   */\n  get isConfirmationNeeded() {\n    return this.state.get(\"isConfirmationNeeded\");\n  }\n  /**\n   * Disables the confirmation dialog while the user is trying to close the\n   * Mini App.\n   */\n  disableConfirmation() {\n    this.isConfirmationNeeded = !1;\n  }\n  /**\n   * Enables the confirmation dialog while the user is trying to close the\n   * Mini App.\n   */\n  enableConfirmation() {\n    this.isConfirmationNeeded = !0;\n  }\n}\nfunction it(r, t) {\n  return r.reduce((e, s) => (e[s] = t, e), {});\n}\nclass xe {\n  constructor(t, e, s = f) {\n    /**\n     * Checks if specified method is supported by current component.\n     */\n    o(this, \"supports\");\n    this.createRequestId = e, this.postEvent = s, this.supports = E(t, {\n      delete: \"web_app_invoke_custom_method\",\n      get: \"web_app_invoke_custom_method\",\n      getKeys: \"web_app_invoke_custom_method\",\n      set: \"web_app_invoke_custom_method\"\n    });\n  }\n  /**\n   * Deletes specified key or keys from the cloud storage.\n   * @param keyOrKeys - key or keys to delete.\n   * @param options - request execution options.\n   */\n  async delete(t, e = {}) {\n    const s = Array.isArray(t) ? t : [t];\n    s.length !== 0 && await N(\n      \"deleteStorageValues\",\n      { keys: s },\n      this.createRequestId(),\n      { ...e, postEvent: this.postEvent }\n    );\n  }\n  /**\n   * Returns list of all keys presented in the cloud storage.\n   * @param options - request execution options.\n   */\n  async getKeys(t = {}) {\n    const e = await N(\n      \"getStorageKeys\",\n      {},\n      this.createRequestId(),\n      { ...t, postEvent: this.postEvent }\n    );\n    return Nt().of(h()).parse(e);\n  }\n  async get(t, e = {}) {\n    const s = Array.isArray(t) ? t : [t];\n    if (s.length === 0)\n      return it(s, \"\");\n    const n = g(\n      it(s, h())\n    ), i = await N(\n      \"getStorageValues\",\n      { keys: s },\n      this.createRequestId(),\n      { ...e, postEvent: this.postEvent }\n    ).then((a) => n.parse(a));\n    return Array.isArray(t) ? i : i[t];\n  }\n  /**\n   * Saves specified value by key.\n   * @param key - storage key.\n   * @param value - storage value.\n   * @param options - request execution options.\n   */\n  async set(t, e, s = {}) {\n    await N(\n      \"saveStorageValue\",\n      { key: t, value: e },\n      this.createRequestId(),\n      { ...s, postEvent: this.postEvent }\n    );\n  }\n}\nclass qe {\n  constructor(t, e = f) {\n    /**\n     * Checks if specified method is supported by current component.\n     */\n    o(this, \"supports\");\n    this.postEvent = e, this.supports = E(t, {\n      impactOccurred: \"web_app_trigger_haptic_feedback\",\n      notificationOccurred: \"web_app_trigger_haptic_feedback\",\n      selectionChanged: \"web_app_trigger_haptic_feedback\"\n    });\n  }\n  /**\n   * A method tells that an impact occurred. The Telegram app may play the\n   * appropriate haptics based on style value passed.\n   * @param style - impact style.\n   */\n  impactOccurred(t) {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", {\n      type: \"impact\",\n      impact_style: t\n    });\n  }\n  /**\n   * A method tells that a task or action has succeeded, failed, or produced\n   * a warning. The Telegram app may play the appropriate haptics based on\n   * type value passed.\n   * @param type - notification type.\n   */\n  notificationOccurred(t) {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", {\n      type: \"notification\",\n      notification_type: t\n    });\n  }\n  /**\n   * A method tells that the user has changed a selection. The Telegram app\n   * may play the appropriate haptics.\n   *\n   * Do not use this feedback when the user makes or confirms a selection;\n   * use it only when the selection changes.\n   */\n  selectionChanged() {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", { type: \"selection_change\" });\n  }\n}\nfunction Ae() {\n  const r = document.createElement(\"style\");\n  r.id = \"telegram-custom-styles\", document.head.appendChild(r), y(\"set_custom_style\", (t) => {\n    r.innerHTML = t;\n  });\n}\nfunction qt(r) {\n  return `telegram-mini-apps-${r}`;\n}\nfunction L(r, t) {\n  sessionStorage.setItem(qt(r), JSON.stringify(t));\n}\nfunction $(r) {\n  const t = sessionStorage.getItem(qt(r));\n  return t ? JSON.parse(t) : null;\n}\nfunction Re(r, t, e) {\n  const { isVisible: s = !1 } = r ? $(\"back-button\") || {} : {}, n = new ve(s, t, e);\n  return n.on(\"change\", () => {\n    L(\"back-button\", { isVisible: n.isVisible });\n  }), n;\n}\nfunction Ve(r, t) {\n  const { isConfirmationNeeded: e = !1 } = r ? $(\"closing-behavior\") || {} : {}, s = new ke(e, t);\n  return s.on(\"change\", () => L(\"closing-behavior\", {\n    isConfirmationNeeded: s.isConfirmationNeeded\n  })), s;\n}\nclass Ie {\n  constructor(t) {\n    o(this, \"ee\", new w());\n    o(this, \"state\");\n    o(this, \"postEvent\");\n    /**\n     * Adds new event listener.\n     * @param event - event name.\n     * @param listener - event listener.\n     */\n    o(this, \"on\", (t, e) => (\n      // FIXME: Event 'main_button_pressed' is still being received on Android\n      //  even if the main button is disabled.\n      //  Issue: https://github.com/Telegram-Mini-Apps/tma.js/issues/3\n      t === \"click\" ? y(\"main_button_pressed\", e) : this.ee.on(t, e)\n    ));\n    /**\n     * Removes event listener.\n     * @param event - event name.\n     * @param listener - event listener.\n     */\n    o(this, \"off\", (t, e) => t === \"click\" ? I(\"main_button_pressed\", e) : this.ee.off(t, e));\n    const {\n      postEvent: e = f,\n      text: s,\n      textColor: n,\n      backgroundColor: i,\n      isEnabled: a,\n      isVisible: c,\n      isLoaderVisible: u\n    } = t;\n    this.postEvent = e, this.state = new _({\n      backgroundColor: i,\n      isEnabled: a,\n      isVisible: c,\n      isLoaderVisible: u,\n      text: s,\n      textColor: n\n    }, this.ee);\n  }\n  /**\n   * Sends current local state to Telegram application.\n   */\n  commit() {\n    this.text !== \"\" && this.postEvent(\"web_app_setup_main_button\", {\n      is_visible: this.isVisible,\n      is_active: this.isEnabled,\n      is_progress_visible: this.isLoaderVisible,\n      text: this.text,\n      color: this.backgroundColor,\n      text_color: this.textColor\n    });\n  }\n  set isEnabled(t) {\n    this.setParams({ isEnabled: t });\n  }\n  /**\n   * True if the Main Button is currently enabled.\n   */\n  get isEnabled() {\n    return this.state.get(\"isEnabled\");\n  }\n  set isLoaderVisible(t) {\n    this.setParams({ isLoaderVisible: t });\n  }\n  /**\n   * True if the Main Button loader is currently visible.\n   */\n  get isLoaderVisible() {\n    return this.state.get(\"isLoaderVisible\");\n  }\n  set isVisible(t) {\n    this.setParams({ isVisible: t });\n  }\n  /**\n   * True if the Main Button is currently visible.\n   */\n  get isVisible() {\n    return this.state.get(\"isVisible\");\n  }\n  /**\n   * The Main Button background color.\n   */\n  get backgroundColor() {\n    return this.state.get(\"backgroundColor\");\n  }\n  /**\n   * The Main Button text.\n   */\n  get text() {\n    return this.state.get(\"text\");\n  }\n  /**\n   * The Main Button text color.\n   */\n  get textColor() {\n    return this.state.get(\"textColor\");\n  }\n  /**\n   * Disables the Main Button.\n   */\n  disable() {\n    return this.isEnabled = !1, this;\n  }\n  /**\n   * Enables the Main Button.\n   */\n  enable() {\n    return this.isEnabled = !0, this;\n  }\n  /**\n   * Hides the Main Button.\n   */\n  hide() {\n    return this.isVisible = !1, this;\n  }\n  /**\n   * Hides the Main Button loader.\n   */\n  hideLoader() {\n    return this.isLoaderVisible = !1, this;\n  }\n  /**\n   * Shows the Main Button. Note that opening the Mini App from the attachment menu hides the\n   * main button until the user interacts with the Mini App interface.\n   */\n  show() {\n    return this.isVisible = !0, this;\n  }\n  /**\n   * A method to show a loading indicator on the Main Button. It is recommended to display\n   * loader if the action tied to the button may take a long time.\n   */\n  showLoader() {\n    return this.isLoaderVisible = !0, this;\n  }\n  /**\n   * Sets new Main Button text. Minimal length for text is 1 symbol, and maximum is 64 symbols.\n   * @param text - new text.\n   */\n  setText(t) {\n    return this.setParams({ text: t });\n  }\n  /**\n   * Sets new Main Button text color.\n   * @param textColor - new text color.\n   */\n  setTextColor(t) {\n    return this.setParams({ textColor: t });\n  }\n  /**\n   * Updates current Main Button color.\n   * @param backgroundColor - color to set.\n   */\n  setBackgroundColor(t) {\n    return this.setParams({ backgroundColor: t });\n  }\n  /**\n   * Allows setting multiple Main Button parameters.\n   * @param params - Main Button parameters.\n   */\n  setParams(t) {\n    return this.state.set(t), this.commit(), this;\n  }\n}\nfunction Le(r, t, e, s) {\n  const {\n    backgroundColor: n = t,\n    isEnabled: i = !1,\n    isVisible: a = !1,\n    isLoaderVisible: c = !1,\n    textColor: u = e,\n    text: p = \"\"\n  } = r ? $(\"main-button\") || {} : {}, l = new Ie({\n    backgroundColor: n,\n    isEnabled: i,\n    isLoaderVisible: c,\n    isVisible: a,\n    postEvent: s,\n    text: p,\n    textColor: u\n  }), b = () => L(\"main-button\", {\n    backgroundColor: l.backgroundColor,\n    isEnabled: l.isEnabled,\n    isLoaderVisible: l.isLoaderVisible,\n    isVisible: l.isVisible,\n    text: l.text,\n    textColor: l.textColor\n  });\n  return l.on(\"change\", b), l;\n}\nconst $e = X({\n  contact: g({\n    userId: {\n      type: k(),\n      from: \"user_id\"\n    },\n    phoneNumber: {\n      type: h(),\n      from: \"phone_number\"\n    },\n    firstName: {\n      type: h(),\n      from: \"first_name\"\n    },\n    lastName: {\n      type: h(),\n      from: \"last_name\"\n    }\n  }),\n  authDate: {\n    type: pt(),\n    from: \"auth_date\"\n  },\n  hash: h()\n});\nclass Te {\n  constructor(t) {\n    o(this, \"ee\", new w());\n    o(this, \"state\");\n    o(this, \"botInline\");\n    o(this, \"postEvent\");\n    o(this, \"createRequestId\");\n    o(this, \"requestingPhoneAccess\", !1);\n    o(this, \"requestingWriteAccess\", !1);\n    /**\n     * Adds new event listener.\n     */\n    o(this, \"on\", this.ee.on.bind(this.ee));\n    /**\n     * Removes event listener.\n     */\n    o(this, \"off\", this.ee.off.bind(this.ee));\n    /**\n     * Checks if specified method is supported by current component.\n     */\n    o(this, \"supports\");\n    /**\n     * Checks if specified method parameter is supported by current component.\n     */\n    o(this, \"supportsParam\");\n    const {\n      postEvent: e = f,\n      headerColor: s,\n      backgroundColor: n,\n      version: i,\n      botInline: a,\n      createRequestId: c\n    } = t, u = E(i, {\n      requestPhoneAccess: \"web_app_request_phone\",\n      requestWriteAccess: \"web_app_request_write_access\",\n      switchInlineQuery: \"web_app_switch_inline_query\",\n      setHeaderColor: \"web_app_set_header_color\",\n      setBackgroundColor: \"web_app_set_background_color\"\n    });\n    this.postEvent = e, this.botInline = a, this.createRequestId = c, this.supports = (p) => !(!u(p) || p === \"switchInlineQuery\" && !a), this.state = new _({ backgroundColor: n, headerColor: s }, this.ee), this.supportsParam = kt(i, {\n      \"setHeaderColor.color\": [\"web_app_set_header_color\", \"color\"]\n    });\n  }\n  /**\n   * Attempts to get requested contact.\n   */\n  async getRequestedContact() {\n    return N(\n      \"getRequestedContact\",\n      {},\n      this.createRequestId(),\n      {\n        postEvent: this.postEvent,\n        timeout: 1e4\n      }\n    ).then((t) => $e.parse(t));\n  }\n  /**\n   * The Mini App background color.\n   */\n  get backgroundColor() {\n    return this.state.get(\"backgroundColor\");\n  }\n  /**\n   * Closes the Mini App.\n   */\n  close() {\n    this.postEvent(\"web_app_close\");\n  }\n  /**\n   * The Mini App header color. Could either be a header color key or RGB color.\n   */\n  get headerColor() {\n    return this.state.get(\"headerColor\");\n  }\n  /**\n   * True if Mini App is currently launched in bot inline mode.\n   */\n  get isBotInline() {\n    return this.botInline;\n  }\n  /**\n   * True if current Mini App background color recognized as dark.\n   */\n  get isDark() {\n    return ft(this.backgroundColor);\n  }\n  /**\n   * True if phone access is currently being requested.\n   */\n  get isRequestingPhoneAccess() {\n    return this.requestingPhoneAccess;\n  }\n  /**\n   * True if write access is currently being requested.\n   */\n  get isRequestingWriteAccess() {\n    return this.requestingWriteAccess;\n  }\n  /**\n   * Informs the Telegram app that the Mini App is ready to be displayed.\n   *\n   * It is recommended to call this method as early as possible, as soon as all essential\n   * interface elements loaded. Once this method called, the loading placeholder is hidden\n   * and the Mini App shown.\n   *\n   * If the method not called, the placeholder will be hidden only when the page fully loaded.\n   */\n  ready() {\n    this.postEvent(\"web_app_ready\");\n  }\n  /**\n   * Requests current user contact information. In contrary to requestPhoneAccess, this method\n   * returns promise with contact information that rejects in case, user denied access, or request\n   * failed.\n   * @param options - additional options.\n   */\n  async requestContact({ timeout: t = 5e3 } = {}) {\n    try {\n      return await this.getRequestedContact();\n    } catch {\n    }\n    if (await this.requestPhoneAccess() !== \"sent\")\n      throw new Error(\"Access denied.\");\n    const s = Date.now() + t;\n    let n = 50;\n    return xt(async () => {\n      for (; Date.now() < s; ) {\n        try {\n          return await this.getRequestedContact();\n        } catch {\n        }\n        await Ee(n), n += 50;\n      }\n      throw new Error(\"Unable to retrieve requested contact.\");\n    }, t);\n  }\n  /**\n   * Requests current user phone access. Method returns promise, which resolves\n   * status of the request. In case, user accepted the request, Mini App bot will receive\n   * the according notification.\n   *\n   * To obtain the retrieved information instead, utilize the requestContact method.\n   * @param options - additional options.\n   * @see requestContact\n   */\n  requestPhoneAccess(t = {}) {\n    if (this.requestingPhoneAccess)\n      throw new Error(\"Phone access is already being requested.\");\n    return this.requestingPhoneAccess = !0, m(\"web_app_request_phone\", \"phone_requested\", {\n      ...t,\n      postEvent: this.postEvent\n    }).then((e) => e.status).finally(() => {\n      this.requestingPhoneAccess = !1;\n    });\n  }\n  /**\n   * Requests write message access to current user.\n   * @param options - additional options.\n   */\n  requestWriteAccess(t = {}) {\n    if (this.requestingWriteAccess)\n      throw new Error(\"Write access is already being requested.\");\n    return this.requestingWriteAccess = !0, m(\"web_app_request_write_access\", \"write_access_requested\", {\n      ...t,\n      postEvent: this.postEvent\n    }).then((e) => e.status).finally(() => {\n      this.requestingWriteAccess = !1;\n    });\n  }\n  /**\n   * A method used to send data to the bot. When this method called, a service message sent to\n   * the bot containing the data of the length up to 4096 bytes, and the Mini App closed. See the\n   * field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n   *\n   * This method is only available for Mini Apps launched via a Keyboard button.\n   * @param data - data to send to bot.\n   * @throws {Error} data has incorrect size.\n   */\n  sendData(t) {\n    const { size: e } = new Blob([t]);\n    if (e === 0 || e > 4096)\n      throw new Error(`Passed data has incorrect size: ${e}`);\n    this.postEvent(\"web_app_data_send\", { data: t });\n  }\n  /**\n   * Updates current Mini App header color.\n   * @param color - color key or RGB color.\n   */\n  setHeaderColor(t) {\n    this.postEvent(\"web_app_set_header_color\", lt(t) ? { color: t } : { color_key: t }), this.state.set(\"headerColor\", t);\n  }\n  /**\n   * Updates current Mini App background color.\n   * @param color - RGB color.\n   */\n  setBackgroundColor(t) {\n    this.postEvent(\"web_app_set_background_color\", { color: t }), this.state.set(\"backgroundColor\", t);\n  }\n  /**\n   * Inserts the bot's username and the specified inline query in the current chat's input field.\n   * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n   * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n   * the specified inline query in the input field.\n   * @param text - text which should be inserted in the input after the current bot name. Max\n   * length is 256 symbols.\n   * @param chatTypes - List of chat types which could be chosen to send the message. Could be\n   * empty list.\n   */\n  switchInlineQuery(t, e = []) {\n    if (!this.supports(\"switchInlineQuery\") && !this.isBotInline)\n      throw new Error(\"Method is unsupported because Mini App should be launched in inline mode.\");\n    this.postEvent(\"web_app_switch_inline_query\", {\n      query: t,\n      chat_types: e\n    });\n  }\n}\nfunction Be(r, t, e, s, n, i) {\n  const {\n    backgroundColor: a = t,\n    headerColor: c = \"bg_color\"\n  } = r ? $(\"mini-app\") || {} : {}, u = new Te({\n    headerColor: c,\n    backgroundColor: a,\n    version: e,\n    botInline: s,\n    createRequestId: n,\n    postEvent: i\n  }), p = () => L(\"mini-app\", {\n    backgroundColor: u.backgroundColor,\n    headerColor: u.headerColor\n  });\n  return u.on(\"change\", p), u;\n}\nfunction De() {\n  let r = 0;\n  return () => (r += 1, r.toString());\n}\nclass We {\n  constructor(t, e, s = f) {\n    o(this, \"ee\", new w());\n    o(this, \"state\");\n    /**\n     * Adds event listener.\n     * @param event - event name.\n     * @param listener - event listener.\n     */\n    o(this, \"on\", (t, e) => t === \"click\" ? y(\"settings_button_pressed\", e) : this.ee.on(t, e));\n    /**\n     * Removes event listener.\n     * @param event - event name.\n     * @param listener - event listener.\n     */\n    o(this, \"off\", (t, e) => t === \"click\" ? I(\"settings_button_pressed\", e) : this.ee.off(t, e));\n    /**\n     * Checks if specified method is supported by current component.\n     */\n    o(this, \"supports\");\n    this.postEvent = s, this.state = new _({ isVisible: t }, this.ee), this.supports = E(e, {\n      show: \"web_app_setup_settings_button\",\n      hide: \"web_app_setup_settings_button\"\n    });\n  }\n  set isVisible(t) {\n    this.state.set(\"isVisible\", t), this.postEvent(\"web_app_setup_settings_button\", { is_visible: t });\n  }\n  /**\n   * True if SettingsButton is currently visible.\n   */\n  get isVisible() {\n    return this.state.get(\"isVisible\");\n  }\n  /**\n   * Hides the SettingsButton.\n   */\n  hide() {\n    this.isVisible = !1;\n  }\n  /**\n   * Shows the SettingsButton.\n   */\n  show() {\n    this.isVisible = !0;\n  }\n}\nfunction Ne(r, t, e) {\n  const { isVisible: s = !1 } = r ? $(\"settings-button\") || {} : {}, n = new We(s, t, e);\n  return n.on(\"change\", () => {\n    L(\"settings-button\", { isVisible: n.isVisible });\n  }), n;\n}\nfunction Oe(r) {\n  const t = new Ft(r);\n  return t.listen(), t;\n}\nasync function At(r) {\n  const t = await m(\"web_app_request_viewport\", \"viewport_changed\", r);\n  return {\n    height: t.height,\n    width: t.width,\n    isExpanded: t.is_expanded,\n    isStateStable: t.is_state_stable\n  };\n}\nfunction D(r) {\n  return r < 0 ? 0 : r;\n}\nclass G {\n  constructor(t) {\n    o(this, \"ee\", new w());\n    o(this, \"state\");\n    o(this, \"postEvent\");\n    /**\n     * Adds new event listener.\n     */\n    o(this, \"on\", this.ee.on.bind(this.ee));\n    /**\n     * Removes event listener.\n     */\n    o(this, \"off\", this.ee.off.bind(this.ee));\n    const {\n      height: e,\n      isExpanded: s,\n      width: n,\n      stableHeight: i,\n      postEvent: a = f\n    } = t;\n    this.postEvent = a, this.state = new _({\n      height: D(e),\n      isExpanded: s,\n      stableHeight: D(i),\n      width: D(n)\n    }, this.ee);\n  }\n  /**\n   * Request viewport information from the Telegram application and updates current Viewport\n   * instance.\n   * @param options - options to request fresh data.\n   */\n  sync(t) {\n    return At(t).then(({ height: e, isExpanded: s, width: n, isStateStable: i }) => {\n      this.state.set({\n        height: e,\n        width: n,\n        isExpanded: s,\n        stableHeight: i ? e : this.state.get(\"stableHeight\")\n      });\n    });\n  }\n  /**\n   * The current height of the visible area of the Mini App.\n   *\n   * The application can display just the top part of the Mini App, with its\n   * lower part remaining outside the screen area. From this position, the\n   * user can \"pull\" the Mini App to its maximum height, while the bot can do\n   * the same by calling `expand` method. As the position of the Mini App\n   * changes, the current height value of the visible area will be updated\n   * in real time.\n   *\n   * Please note that the refresh rate of this value is not sufficient\n   * to smoothly follow the lower border of the window. It should not be\n   * used to pin interface elements to the bottom of the visible area. It's\n   * more appropriate to use the value of the `stableHeight`\n   * field for this purpose.\n   */\n  get height() {\n    return this.state.get(\"height\");\n  }\n  /**\n   * The height of the visible area of the Mini App in its last stable state.\n   *\n   * The application can display just the top part of the Mini App, with its\n   * lower part remaining outside the screen area. From this position,\n   * the user can \"pull\" the Mini App to its maximum height, while the bot can\n   * do the same by calling `expand` method.\n   *\n   * Unlike the value of `height`, the value of `stableHeight`\n   * does not change as the position of the Mini App changes with user\n   * gestures or during animations. The value of `stableHeight`\n   * will be updated after all gestures and animations are completed and\n   * the Mini App reaches its final size.\n   */\n  get stableHeight() {\n    return this.state.get(\"stableHeight\");\n  }\n  /**\n   * Starts listening to viewport changes and applies them.\n   * @returns Function to stop listening.\n   */\n  listen() {\n    return y(\"viewport_changed\", (t) => {\n      const {\n        height: e,\n        width: s,\n        is_expanded: n,\n        is_state_stable: i\n      } = t, a = {\n        height: D(e),\n        isExpanded: n,\n        width: D(s)\n      };\n      i && (a.stableHeight = a.height), this.state.set(a);\n    });\n  }\n  /**\n   * Returns true if the Mini App is expanded to the maximum available height.\n   * Otherwise, if the Mini App occupies part of the screen and can be expanded\n   * to the full height using `expand` method.\n   * @see expand\n   */\n  get isExpanded() {\n    return this.state.get(\"isExpanded\");\n  }\n  /**\n   * Current viewport width.\n   */\n  get width() {\n    return this.state.get(\"width\");\n  }\n  /**\n   * A method that expands the Mini App to the maximum available height. To\n   * find out if the Mini App is expanded to the maximum height, refer to the\n   * value of the `isExpanded`.\n   * @see isExpanded\n   */\n  expand() {\n    this.postEvent(\"web_app_expand\"), this.state.set(\"isExpanded\", !0);\n  }\n  /**\n   * Returns true in case current viewport height is stable and is not going to\n   * change in the next moment.\n   */\n  get isStable() {\n    return this.stableHeight === this.height;\n  }\n}\nfunction Rt(r) {\n  return ![\"macos\", \"web\", \"weba\"].includes(r);\n}\nfunction Vt(r, t, e) {\n  if (r || !Rt(t))\n    return new G({\n      height: window.innerHeight,\n      isExpanded: !0,\n      postEvent: e,\n      stableHeight: window.innerHeight,\n      width: window.innerWidth\n    });\n  const s = $(\"viewport\");\n  return s ? new G({ ...s, postEvent: e }) : null;\n}\nfunction It(r) {\n  return r.listen(), r.on(\"change\", () => L(\"viewport\", {\n    height: r.height,\n    isExpanded: r.isExpanded,\n    stableHeight: r.stableHeight,\n    width: r.width\n  })), r;\n}\nfunction He(r, t, e) {\n  const s = It(\n    Vt(r, t, e) || new G({\n      width: 0,\n      height: 0,\n      isExpanded: !1,\n      postEvent: e,\n      stableHeight: 0\n    })\n  );\n  return Rt(t) && s.sync({ postEvent: e, timeout: 100 }).catch((n) => {\n    console.error(\"Unable to actualize viewport state\", n);\n  }), s;\n}\nasync function Ue(r, t, e) {\n  return It(\n    Vt(r, t, e) || await At({ postEvent: e, timeout: 100 }).then(({ height: s, isStateStable: n, ...i }) => new G({\n      ...i,\n      height: s,\n      stableHeight: n ? s : 0\n    }))\n  );\n}\nfunction S(r, t) {\n  document.documentElement.style.setProperty(r, t);\n}\nfunction Me(r, t) {\n  const e = () => {\n    S(\"--tg-background-color\", r.backgroundColor);\n  }, s = () => {\n    const {\n      backgroundColor: n,\n      secondaryBackgroundColor: i\n    } = t;\n    r.headerColor === \"bg_color\" ? n && S(\"--tg-header-color\", n) : r.headerColor === \"secondary_bg_color\" ? i && S(\"--tg-header-color\", i) : S(\"--tg-header-color\", r.headerColor);\n  };\n  t.on(\"change\", s), r.on(\"change:backgroundColor\", e), r.on(\"change:headerColor\", s), e(), s();\n}\nfunction je(r) {\n  const t = () => {\n    const e = r.getState();\n    Object.entries(e).forEach(([s, n]) => {\n      if (n) {\n        const i = s.replace(/[A-Z]/g, (a) => `-${a.toLowerCase()}`);\n        S(`--tg-theme-${i}`, n);\n      }\n    });\n  };\n  r.on(\"change\", t), t();\n}\nfunction ot(r) {\n  const t = () => S(\"--tg-viewport-height\", `${r.height}px`), e = () => S(\"--tg-viewport-width\", `${r.width}px`), s = () => S(\"--tg-viewport-height\", `${r.stableHeight}px`);\n  r.on(\"change:height\", t), r.on(\"change:width\", e), r.on(\"change:stableHeight\", s), t(), e(), s();\n}\nfunction Ge(r) {\n  return typeof r == \"object\" ? r : r ? {\n    themeParams: !0,\n    viewport: !0,\n    miniApp: !0\n  } : {};\n}\nfunction at(r, t, e, s) {\n  const n = Ge(r);\n  n.miniApp && Me(t, e), n.themeParams && je(e), n.viewport && (s instanceof Promise ? s.then(ot) : ot(s));\n}\nfunction Fe(r) {\n  const { hostname: t, pathname: e } = new URL(r, window.location.href);\n  if (t !== \"t.me\")\n    throw new Error(`Incorrect hostname: ${t}`);\n  const s = e.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n  if (s === null)\n    throw new Error('Link pathname has incorrect format. Expected to receive \"/invoice/{slug}\" or \"/${slug}\"');\n  return s[2];\n}\nclass ze {\n  constructor(t, e = f) {\n    o(this, \"ee\", new w());\n    o(this, \"state\");\n    /**\n     * Adds new event listener.\n     */\n    o(this, \"on\", this.ee.on.bind(this.ee));\n    /**\n     * Removes event listener.\n     */\n    o(this, \"off\", this.ee.off.bind(this.ee));\n    /**\n     * Checks if specified method is supported by current component.\n     */\n    o(this, \"supports\");\n    this.postEvent = e, this.state = new _({ isOpened: !1 }, this.ee), this.supports = E(t, { open: \"web_app_open_invoice\" });\n  }\n  set isOpened(t) {\n    this.state.set(\"isOpened\", t);\n  }\n  /**\n   * True if invoice is currently opened.\n   */\n  get isOpened() {\n    return this.state.get(\"isOpened\");\n  }\n  async open(t, e) {\n    if (this.isOpened)\n      throw new Error(\"Invoice is already opened\");\n    const s = e ? Fe(t) : t;\n    this.isOpened = !0;\n    try {\n      return (await m(\n        \"web_app_open_invoice\",\n        { slug: s },\n        \"invoice_closed\",\n        {\n          postEvent: this.postEvent,\n          capture(i) {\n            return s === i.slug;\n          }\n        }\n      )).status;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n}\nfunction Je(r) {\n  const t = r.message.trim(), e = (r.title || \"\").trim(), s = r.buttons || [];\n  let n;\n  if (e.length > 64)\n    throw new Error(`Title has incorrect size: ${e.length}`);\n  if (t.length === 0 || t.length > 256)\n    throw new Error(`Message has incorrect size: ${t.length}`);\n  if (s.length > 3)\n    throw new Error(`Buttons have incorrect size: ${s.length}`);\n  return s.length === 0 ? n = [{ type: \"close\", id: \"\" }] : n = s.map((i) => {\n    const { id: a = \"\" } = i;\n    if (a.length > 64)\n      throw new Error(`Button ID has incorrect size: ${a}`);\n    if (i.type === void 0 || i.type === \"default\" || i.type === \"destructive\") {\n      const c = i.text.trim();\n      if (c.length === 0 || c.length > 64) {\n        const u = i.type || \"default\";\n        throw new Error(`Button text with type \"${u}\" has incorrect size: ${i.text.length}`);\n      }\n      return { ...i, text: c, id: a };\n    }\n    return { ...i, id: a };\n  }), { title: e, message: t, buttons: n };\n}\nclass Qe {\n  constructor(t, e = f) {\n    o(this, \"ee\", new w());\n    o(this, \"state\");\n    /**\n     * Adds new event listener.\n     */\n    o(this, \"on\", this.ee.on.bind(this.ee));\n    /**\n     * Removes event listener.\n     */\n    o(this, \"off\", this.ee.off.bind(this.ee));\n    /**\n     * Checks if specified method is supported by current component.\n     */\n    o(this, \"supports\");\n    this.postEvent = e, this.state = new _({ isOpened: !1 }, this.ee), this.supports = E(t, { open: \"web_app_open_popup\" });\n  }\n  set isOpened(t) {\n    this.state.set(\"isOpened\", t);\n  }\n  /**\n   * True if popup is currently opened.\n   */\n  get isOpened() {\n    return this.state.get(\"isOpened\");\n  }\n  /**\n   * A method that shows a native popup described by the `params` argument.\n   * Promise will be resolved when popup is closed. Resolved value will have\n   * an identifier of pressed button.\n   *\n   * In case, user clicked outside the popup or clicked top right popup close\n   * button, null will be returned.\n   *\n   * FIXME: In desktop, this function may work incorrectly.\n   *  Issue: https://github.com/Telegram-Mini-Apps/tma.js/issues/7\n   * @param options - popup parameters.\n   * @throws {Error} Popup is already opened.\n   */\n  open(t) {\n    if (this.isOpened)\n      throw new Error(\"Popup is already opened.\");\n    return this.isOpened = !0, m(\n      \"web_app_open_popup\",\n      Je(t),\n      \"popup_closed\",\n      { postEvent: this.postEvent }\n    ).then(({ button_id: e = null }) => e).finally(() => {\n      this.isOpened = !1;\n    });\n  }\n}\nclass Ze {\n  constructor(t, e = f) {\n    o(this, \"ee\", new w());\n    o(this, \"state\");\n    /**\n     * Adds new event listener.\n     */\n    o(this, \"on\", this.ee.on.bind(this.ee));\n    /**\n     * Removes event listener.\n     */\n    o(this, \"off\", this.ee.off.bind(this.ee));\n    /**\n     * Checks if specified method is supported by current component.\n     */\n    o(this, \"supports\");\n    this.postEvent = e, this.state = new _({ isOpened: !1 }, this.ee), this.supports = E(t, {\n      close: \"web_app_close_scan_qr_popup\",\n      open: \"web_app_open_scan_qr_popup\"\n    });\n  }\n  /**\n   * Closes scanner.\n   */\n  close() {\n    this.postEvent(\"web_app_close_scan_qr_popup\"), this.isOpened = !1;\n  }\n  set isOpened(t) {\n    this.state.set(\"isOpened\", t);\n  }\n  /**\n   * Returns true in case, QR scanner is currently opened.\n   */\n  get isOpened() {\n    return this.state.get(\"isOpened\");\n  }\n  /**\n   * Opens scanner with specified title shown to user. Method returns promise\n   * with scanned QR content in case, it was scanned. It will contain null in\n   * case, scanner was closed.\n   * @param text - title to display.\n   */\n  async open(t) {\n    if (this.isOpened)\n      throw new Error(\"QR scanner is already opened.\");\n    this.isOpened = !0;\n    try {\n      const e = await m(\n        \"web_app_open_scan_qr_popup\",\n        { text: t },\n        [\"qr_text_received\", \"scan_qr_popup_closed\"],\n        { postEvent: this.postEvent }\n      );\n      return typeof e == \"object\" && typeof e.data == \"string\" ? e.data : null;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n}\nclass Ke {\n  constructor(t, e, s = f) {\n    /**\n     * Checks if specified method is supported by current component.\n     */\n    o(this, \"supports\");\n    /**\n     * Checks if specified method parameter is supported by current component.\n     */\n    o(this, \"supportsParam\");\n    this.version = t, this.createRequestId = e, this.postEvent = s, this.supports = E(t, {\n      readTextFromClipboard: \"web_app_read_text_from_clipboard\"\n    }), this.supportsParam = kt(t, {\n      \"openLink.tryInstantView\": [\"web_app_open_link\", \"try_instant_view\"]\n    });\n  }\n  /**\n   * Opens a link in an external browser. The Mini App will not be closed.\n   *\n   * Note that this method can be called only in response to the user\n   * interaction with the Mini App interface (e.g. click inside the Mini App\n   * or on the main button).\n   * @param url - URL to be opened.\n   * @param tryInstantView\n   */\n  openLink(t, e) {\n    const s = new URL(t, window.location.href).toString();\n    if (!A(\"web_app_open_link\", this.version)) {\n      window.open(s, \"_blank\");\n      return;\n    }\n    this.postEvent(\"web_app_open_link\", {\n      url: s,\n      ...typeof e == \"boolean\" ? { try_instant_view: e } : {}\n    });\n  }\n  /**\n   * Opens a Telegram link inside Telegram app. The Mini App will be closed. It expects passing\n   * link in full format, with hostname \"t.me\".\n   * @param url - URL to be opened.\n   * @throws {Error} URL has not allowed hostname.\n   */\n  openTelegramLink(t) {\n    const {\n      hostname: e,\n      pathname: s,\n      search: n\n    } = new URL(t, window.location.href);\n    if (e !== \"t.me\")\n      throw new Error(`URL has not allowed hostname: ${e}. Only \"t.me\" is allowed`);\n    if (!A(\"web_app_open_tg_link\", this.version)) {\n      window.location.href = t;\n      return;\n    }\n    this.postEvent(\"web_app_open_tg_link\", { path_full: s + n });\n  }\n  /**\n   * Reads text from clipboard and returns string or null. null is returned\n   * in cases:\n   * - Value in clipboard is not text\n   * - Access to clipboard is not allowed\n   */\n  readTextFromClipboard() {\n    return m(\n      \"web_app_read_text_from_clipboard\",\n      { req_id: this.createRequestId() },\n      \"clipboard_text_received\",\n      { postEvent: this.postEvent }\n    ).then(({ data: t = null }) => t);\n  }\n}\nfunction ur(r = {}) {\n  const {\n    async: t = !1,\n    cssVars: e = !1,\n    acceptCustomStyles: s = !1\n  } = r;\n  try {\n    const {\n      launchParams: {\n        initData: n,\n        initDataRaw: i,\n        version: a,\n        platform: c,\n        themeParams: u,\n        botInline: p = !1\n      },\n      isPageReload: l\n    } = Ct(), b = De(), d = ye(a);\n    vt() && (s && Ae(), d(\"iframe_ready\", { reload_supported: !0 }), y(\"reload_iframe\", () => window.location.reload()));\n    const C = {\n      backButton: Re(l, a, d),\n      closingBehavior: Ve(l, d),\n      cloudStorage: new xe(a, b, d),\n      createRequestId: b,\n      hapticFeedback: new qe(a, d),\n      invoice: new ze(a, d),\n      mainButton: Le(\n        l,\n        u.buttonColor || \"#000000\",\n        u.buttonTextColor || \"#ffffff\",\n        d\n      ),\n      miniApp: Be(\n        l,\n        u.backgroundColor || \"#ffffff\",\n        a,\n        p,\n        b,\n        d\n      ),\n      popup: new Qe(a, d),\n      postEvent: d,\n      qrScanner: new Ze(a, d),\n      settingsButton: Ne(l, a, d),\n      themeParams: Oe(u),\n      utils: new Ke(a, b, d),\n      ...n ? {\n        initData: new Ut(n),\n        initDataRaw: i\n      } : {}\n    }, x = t ? Ue(l, c, d) : He(l, c, d);\n    return x instanceof Promise ? x.then((T) => (at(\n      e,\n      C.miniApp,\n      C.themeParams,\n      T\n    ), {\n      ...C,\n      viewport: T\n    })) : (at(\n      e,\n      C.miniApp,\n      C.themeParams,\n      x\n    ), { ...C, viewport: x });\n  } catch (n) {\n    if (t)\n      return Promise.reject(n);\n    throw n;\n  }\n}\nfunction W(r, t) {\n  return r.startsWith(t) ? r : `${t}${r}`;\n}\nfunction pr(r) {\n  const t = r.match(/#(.+)/);\n  return t ? t[1] : null;\n}\nasync function O(r) {\n  return r === 0 ? !0 : Promise.race([\n    new Promise((t) => {\n      window.addEventListener(\"popstate\", function e() {\n        window.removeEventListener(\"popstate\", e), t(!0);\n      }), window.history.go(r);\n    }),\n    // Usually, it takes about 1ms to emit this event, but we use some buffer.\n    new Promise((t) => {\n      setTimeout(t, 50, !1);\n    })\n  ]);\n}\nasync function Ye() {\n  if (window.history.length <= 1 || (window.history.pushState(null, \"\"), await O(1 - window.history.length)))\n    return;\n  let t = await O(-1);\n  for (; t; )\n    t = await O(-1);\n}\nclass Xe {\n  constructor(t, e, {\n    debug: s = !1,\n    loggerPrefix: n = \"Navigator\"\n  }) {\n    o(this, \"logger\");\n    o(this, \"entries\");\n    if (this.entriesCursor = e, t.length === 0)\n      throw new Error(\"Entries list should not be empty.\");\n    if (e >= t.length)\n      throw new Error(\"Cursor should be less than entries count.\");\n    this.entries = t.map(({ pathname: i = \"\", search: a, hash: c }) => {\n      if (!i.startsWith(\"/\") && i.length > 0)\n        throw new Error('Pathname should start with \"/\"');\n      return {\n        pathname: W(i, \"/\"),\n        search: a ? W(a, \"?\") : \"\",\n        hash: c ? W(c, \"#\") : \"\"\n      };\n    }), this.logger = new Pt(`[${n}]`, s);\n  }\n  /**\n   * Converts entry to the navigation entry.\n   * @param entry - entry data\n   */\n  formatEntry(t) {\n    let e;\n    if (typeof t == \"string\")\n      e = t;\n    else {\n      const {\n        pathname: a = \"\",\n        search: c,\n        hash: u\n      } = t;\n      e = a + (c ? W(c, \"?\") : \"\") + (u ? W(u, \"#\") : \"\");\n    }\n    const {\n      pathname: s,\n      search: n,\n      hash: i\n    } = new URL(e, `https://localhost${this.path}`);\n    return {\n      pathname: s,\n      search: n,\n      hash: i\n    };\n  }\n  /**\n   * Current entry.\n   */\n  get entry() {\n    return this.entries[this.entriesCursor];\n  }\n  /**\n   * Goes back in history.\n   */\n  back() {\n    return this.go(-1);\n  }\n  /**\n   * Current entries cursor.\n   */\n  get cursor() {\n    return this.entriesCursor;\n  }\n  /**\n   * True if navigator can go back.\n   */\n  get canGoBack() {\n    return this.entriesCursor > 0;\n  }\n  /**\n   * True if navigator can go forward.\n   */\n  get canGoForward() {\n    return this.entriesCursor !== this.entries.length - 1;\n  }\n  /**\n   * Goes forward in history.\n   */\n  forward() {\n    return this.go(1);\n  }\n  /**\n   * Moves entries cursor by specified delta.\n   * @param delta - cursor delta.\n   */\n  go(t) {\n    this.logger.log(`called go(${t})`);\n    const e = Math.min(\n      this.entries.length - 1,\n      Math.max(this.entriesCursor + t, 0)\n    );\n    if (this.entriesCursor === e)\n      return this.performGo({\n        updated: !1,\n        delta: t\n      });\n    const s = this.entry;\n    this.entriesCursor = e;\n    const n = this.entry;\n    return this.logger.log(\"State changed\", { before: s, after: n }), this.performGo({\n      updated: !0,\n      delta: t,\n      before: s,\n      after: n\n    });\n  }\n  /**\n   * Returns copy of navigator entries.\n   */\n  getEntries() {\n    return this.entries.map((t) => ({ ...t }));\n  }\n  /**\n   * Current hash.\n   * @example\n   * \"\", \"#\", \"#hash\"\n   */\n  get hash() {\n    return this.entry.hash;\n  }\n  /**\n   * Pushes new entry. Method replaces all entries after the current one with the inserted.\n   * @param entry - entry data.\n   *\n   * @example Pushing absolute pathname.\n   * push(\"/absolute-path\"); // \"/absolute-path\"\n   *\n   * @example Pushing relative pathname.\n   * // Pushing relative path replaces N last path parts, where N is pushed pathname parts count.\n   * // Pushing empty path is recognized as relative, but not replacing the last pathname part.\n   * push(\"relative\"); // \"/home/root\" -> \"/home/relative\"\n   *\n   * @example Pushing query parameters.\n   * push(\"/absolute?my-param=1\"); // \"/home\" -> \"/absolute?my-param=1\"\n   * push(\"relative?my-param=1\"); // \"/home/root\" -> \"/home/relative?my-param=1\"\n   * push(\"?my-param=1\"); // \"/home\" -> \"/home?my-param=1\"\n   *\n   * @example Pushing hash.\n   * push(\"#my-hash\"); // \"/home\" -> \"/home#my-hash\"\n   * push(\"johny#my-hash\"); // \"/home/root\" -> \"/home/johny#my-hash\"\n   */\n  push(t) {\n    this.entriesCursor !== this.entries.length - 1 && this.entries.splice(this.entriesCursor + 1);\n    const e = this.formatEntry(t), s = this.entry;\n    this.entriesCursor += 1, this.entries[this.entriesCursor] = e;\n    const n = this.entry;\n    return this.logger.log(\"State changed\", { before: s, after: n }), this.performPush({\n      before: s,\n      after: n\n    });\n  }\n  /**\n   * Current full path including pathname, query parameters and hash.\n   */\n  get path() {\n    return `${this.pathname}${this.search}${this.hash}`;\n  }\n  /**\n   * Current pathname.\n   * @example\n   * \"/\", \"/abc\"\n   */\n  get pathname() {\n    return this.entry.pathname;\n  }\n  /**\n   * Replaces current entry. Has the same logic as `push` method.\n   * @param entry - entry data.\n   * @see push\n   * @returns True if changes were done.\n   */\n  replace(t) {\n    const e = this.formatEntry(t);\n    if (this.search === e.search && this.pathname === e.pathname && this.hash === e.hash)\n      return this.performReplace({\n        updated: !1,\n        entry: e\n      });\n    const s = this.entry;\n    this.entries[this.entriesCursor] = e;\n    const n = this.entry;\n    return this.logger.log(\"State changed\", { before: s, after: n }), this.performReplace({\n      updated: !0,\n      before: s,\n      after: n\n    });\n  }\n  /**\n   * Current query parameters.\n   * @example\n   * \"\", \"?\", \"?a=1\"\n   */\n  get search() {\n    return this.entry.search;\n  }\n}\nconst ct = 0, Z = 1, K = 2;\nclass Lt extends Xe {\n  constructor(e, s, n = {}) {\n    super(e, s, {\n      ...n,\n      loggerPrefix: \"HashNavigator\"\n    });\n    o(this, \"ee\", new w());\n    o(this, \"attached\", !1);\n    /**\n     * Handles window \"popstate\" event.\n     * @param state - event state.\n     */\n    o(this, \"onPopState\", async ({ state: e }) => {\n      if (this.logger.log('\"popstate\" event received. State:', e), e === null)\n        return this.push(window.location.hash.slice(1));\n      if (e === ct) {\n        this.logger.log(\"Void reached. Moving history forward\"), window.history.forward();\n        return;\n      }\n      if (e === Z)\n        return this.back();\n      if (e === K)\n        return this.forward();\n    });\n    o(this, \"back\", () => super.back());\n    /**\n     * Adds new event listener.\n     */\n    o(this, \"on\", this.ee.on.bind(this.ee));\n    /**\n     * Removes event listener.\n     */\n    o(this, \"off\", this.ee.off.bind(this.ee));\n  }\n  /**\n   * Creates navigator from current window location hash.\n   * @param options - options passed to constructor.\n   */\n  static fromLocation(e) {\n    const {\n      search: s,\n      pathname: n,\n      hash: i\n    } = new URL(\n      window.location.hash.slice(1),\n      window.location.href\n    );\n    return new Lt([{ search: s, pathname: n, hash: i }], 0, e);\n  }\n  async performGo(e) {\n    e.updated && (this.attached && await this.syncHistory(), this.emitChanged(e.before, e.after));\n  }\n  async performPush({ before: e, after: s }) {\n    this.attached && await this.syncHistory(), this.emitChanged(e, s);\n  }\n  async performReplace(e) {\n    e.updated && (this.attached && window.history.replaceState(null, \"\", `#${this.path}`), this.emitChanged(e.before, e.after));\n  }\n  /**\n   * Synchronizes current navigator state with browser history.\n   */\n  async syncHistory() {\n    window.removeEventListener(\"popstate\", this.onPopState);\n    const e = `#${this.path}`;\n    await Ye(), f(\"web_app_setup_back_button\", { is_visible: this.canGoBack }), this.canGoBack && this.canGoForward ? (this.logger.log(\"Setting up history: [<-, *, ->]\"), window.history.replaceState(Z, \"\"), window.history.pushState(null, \"\", e), window.history.pushState(K, \"\"), await O(-1)) : this.canGoBack ? (this.logger.log(\"Setting up history: [<-, *]\"), window.history.replaceState(Z, \"\"), window.history.pushState(null, \"\", e)) : this.canGoForward ? (this.logger.log(\"Setting up history: [*, ->]\"), window.history.replaceState(null, e), window.history.pushState(K, \"\"), await O(-1)) : (this.logger.log(\"Setting up history: [~, *]\"), window.history.replaceState(ct, \"\"), window.history.pushState(null, \"\", e)), window.addEventListener(\"popstate\", this.onPopState);\n  }\n  emitChanged(e, s) {\n    this.ee.emit(\"change\", {\n      navigator: this,\n      from: e,\n      to: s\n    });\n  }\n  /**\n   * Attaches current navigator to the browser history allowing navigator to manipulate it.\n   */\n  async attach() {\n    if (!this.attached)\n      return this.logger.log(\"Attaching\", this), this.attached = !0, y(\"back_button_pressed\", this.back), this.syncHistory();\n  }\n  /**\n   * Detaches current navigator from the browser history.\n   */\n  detach() {\n    this.attached && (this.logger.log(\"Detaching\", this), this.attached = !1, window.removeEventListener(\"popstate\", this.onPopState), I(\"back_button_pressed\", this.back));\n  }\n}\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdG1hLmpzK3Nka0AxLjIuMC9ub2RlX21vZHVsZXMvQHRtYS5qcy9zZGsvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsMENBQTBDLDBEQUEwRDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CLElBQUk7QUFDM0Msa0NBQWtDLFdBQVcsRUFBRSxPQUFPLEtBQUssVUFBVTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0IsSUFBSTtBQUMzQyxvQ0FBb0MsRUFBRSxHQUFHLFdBQVcsRUFBRSxPQUFPLEtBQUssVUFBVTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZUFBZSxVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLEVBQUU7QUFDdEI7QUFDQTtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSw4QkFBOEIsSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSTtBQUN0SDtBQUNBLDhCQUE4QixFQUFFO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEVBQUU7QUFDN0M7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0IsMkNBQTJDLEVBQUU7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEYsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxFQUFFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixFQUFFLDRDQUE0QyxFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsZUFBZSxFQUFFLDRDQUE0QyxFQUFF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QSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsVUFBVTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QixpREFBaUQsNEJBQTRCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE0REU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRtYS5qcytzZGtAMS4yLjAvbm9kZV9tb2R1bGVzL0B0bWEuanMvc2RrL2Rpc3QvaW5kZXgubWpzP2JjZjMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyICR0ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIFR0ID0gKHIsIHQsIGUpID0+IHQgaW4gciA/ICR0KHIsIHQsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IGUgfSkgOiByW3RdID0gZTtcbnZhciBvID0gKHIsIHQsIGUpID0+IChUdChyLCB0eXBlb2YgdCAhPSBcInN5bWJvbFwiID8gdCArIFwiXCIgOiB0LCBlKSwgZSk7XG5mdW5jdGlvbiBIKHIpIHtcbiAgcmV0dXJuIHR5cGVvZiByID09IFwib2JqZWN0XCIgJiYgciAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShyKTtcbn1cbmZ1bmN0aW9uIGh0KCkge1xuICByZXR1cm4gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5VHlwZShcIm5hdmlnYXRpb25cIilbMF0gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIEJ0KCkge1xuICBjb25zdCByID0gaHQoKTtcbiAgcmV0dXJuIHIgPyByLnR5cGUgPT09IFwicmVsb2FkXCIgOiBudWxsO1xufVxuZnVuY3Rpb24gUigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJWYWx1ZSBoYXMgdW5leHBlY3RlZCB0eXBlXCIpO1xufVxuY2xhc3MgRiBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZSwgeyBjYXVzZTogcywgdHlwZTogbiB9ID0ge30pIHtcbiAgICBzdXBlcihgVW5hYmxlIHRvIHBhcnNlIHZhbHVlJHtuID8gYCBhcyAke259YCA6IFwiXCJ9YCwgeyBjYXVzZTogcyB9KTtcbiAgICAvKipcbiAgICAgKiBQYXJzZXIgbmFtZS5cbiAgICAgKi9cbiAgICBvKHRoaXMsIFwidHlwZVwiKTtcbiAgICB0aGlzLnZhbHVlID0gZSwgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEYucHJvdG90eXBlKSwgdGhpcy50eXBlID0gbjtcbiAgfVxufVxuY2xhc3MgeiB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIHMpIHtcbiAgICB0aGlzLnBhcnNlciA9IHQsIHRoaXMuaXNPcHRpb25hbCA9IGUsIHRoaXMudHlwZSA9IHM7XG4gIH1cbiAgcGFyc2UodCkge1xuICAgIGlmICghKHRoaXMuaXNPcHRpb25hbCAmJiB0ID09PSB2b2lkIDApKVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VyKHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRih0LCB7IHR5cGU6IHRoaXMudHlwZSwgY2F1c2U6IGUgfSk7XG4gICAgICB9XG4gIH1cbiAgb3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNPcHRpb25hbCA9ICEwLCB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBEdChyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKVxuICAgIHJldHVybiByO1xuICBpZiAodHlwZW9mIHIgPT0gXCJzdHJpbmdcIilcbiAgICB0cnkge1xuICAgICAgY29uc3QgdCA9IEpTT04ucGFyc2Uocik7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSlcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB0aHJvdyBSKCk7XG59XG5jbGFzcyBXdCBleHRlbmRzIHoge1xuICBjb25zdHJ1Y3RvcihlLCBzLCBuKSB7XG4gICAgc3VwZXIoRHQsIHMsIG4pO1xuICAgIG8odGhpcywgXCJpdGVtUGFyc2VyXCIpO1xuICAgIHRoaXMuaXRlbVBhcnNlciA9IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUgOiBlLnBhcnNlLmJpbmQoZSk7XG4gIH1cbiAgcGFyc2UoZSkge1xuICAgIGNvbnN0IHMgPSBzdXBlci5wYXJzZShlKTtcbiAgICByZXR1cm4gcyA9PT0gdm9pZCAwID8gcyA6IHMubWFwKHRoaXMuaXRlbVBhcnNlcik7XG4gIH1cbiAgb2YoZSkge1xuICAgIHJldHVybiB0aGlzLml0ZW1QYXJzZXIgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogZS5wYXJzZS5iaW5kKGUpLCB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBWKHIsIHQpIHtcbiAgcmV0dXJuICgpID0+IG5ldyB6KHIsICExLCB0KTtcbn1cbmNsYXNzIGogZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHQsIHsgY2F1c2U6IGUsIHR5cGU6IHMgfSA9IHt9KSB7XG4gICAgc3VwZXIoYFVuYWJsZSB0byBwYXJzZSBmaWVsZCBcIiR7dH1cIiR7cyA/IGAgYXMgJHtzfWAgOiBcIlwifWAsIHsgY2F1c2U6IGUgfSksIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBqLnByb3RvdHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHV0KHIsIHQpIHtcbiAgY29uc3QgZSA9IHt9O1xuICBmb3IgKGNvbnN0IHMgaW4gcikge1xuICAgIGNvbnN0IG4gPSByW3NdO1xuICAgIGlmICghbilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGxldCBpLCBhO1xuICAgIGlmICh0eXBlb2YgbiA9PSBcImZ1bmN0aW9uXCIgfHwgXCJwYXJzZVwiIGluIG4pXG4gICAgICBpID0gcywgYSA9IHR5cGVvZiBuID09IFwiZnVuY3Rpb25cIiA/IG4gOiBuLnBhcnNlLmJpbmQobik7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB7IHR5cGU6IHAgfSA9IG47XG4gICAgICBpID0gbi5mcm9tIHx8IHMsIGEgPSB0eXBlb2YgcCA9PSBcImZ1bmN0aW9uXCIgPyBwIDogcC5wYXJzZS5iaW5kKHApO1xuICAgIH1cbiAgICBsZXQgYztcbiAgICBjb25zdCB1ID0gdChpKTtcbiAgICB0cnkge1xuICAgICAgYyA9IGEodSk7XG4gICAgfSBjYXRjaCAocCkge1xuICAgICAgdGhyb3cgcCBpbnN0YW5jZW9mIEYgPyBuZXcgaihpLCB7XG4gICAgICAgIHR5cGU6IHAudHlwZSxcbiAgICAgICAgY2F1c2U6IHBcbiAgICAgIH0pIDogbmV3IGooaSwgeyBjYXVzZTogcCB9KTtcbiAgICB9XG4gICAgYyAhPT0gdm9pZCAwICYmIChlW3NdID0gYyk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBOdChyKSB7XG4gIHJldHVybiBuZXcgV3QoKHQpID0+IHQsICExLCByKTtcbn1cbmNvbnN0IFAgPSBWKChyKSA9PiB7XG4gIGlmICh0eXBlb2YgciA9PSBcImJvb2xlYW5cIilcbiAgICByZXR1cm4gcjtcbiAgY29uc3QgdCA9IFN0cmluZyhyKTtcbiAgaWYgKHQgPT09IFwiMVwiIHx8IHQgPT09IFwidHJ1ZVwiKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKHQgPT09IFwiMFwiIHx8IHQgPT09IFwiZmFsc2VcIilcbiAgICByZXR1cm4gITE7XG4gIHRocm93IFIoKTtcbn0sIFwiYm9vbGVhblwiKSwgayA9IFYoKHIpID0+IHtcbiAgaWYgKHR5cGVvZiByID09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIHI7XG4gIGlmICh0eXBlb2YgciA9PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgdCA9IE51bWJlcihyKTtcbiAgICBpZiAoIU51bWJlci5pc05hTih0KSlcbiAgICAgIHJldHVybiB0O1xuICB9XG4gIHRocm93IFIoKTtcbn0sIFwibnVtYmVyXCIpLCBwdCA9IFYoKHIpID0+IHIgaW5zdGFuY2VvZiBEYXRlID8gciA6IG5ldyBEYXRlKGsoKS5wYXJzZShyKSAqIDFlMyksIFwiRGF0ZVwiKTtcbmZ1bmN0aW9uIFkocikge1xuICBsZXQgdCA9IHI7XG4gIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmICh0ID0gSlNPTi5wYXJzZSh0KSksIHR5cGVvZiB0ICE9IFwib2JqZWN0XCIgfHwgdCA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KHQpKVxuICAgIHRocm93IFIoKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBnKHIsIHQpIHtcbiAgcmV0dXJuIG5ldyB6KChlKSA9PiB7XG4gICAgY29uc3QgcyA9IFkoZSk7XG4gICAgcmV0dXJuIHV0KHIsIChuKSA9PiBzW25dKTtcbiAgfSwgITEsIHQpO1xufVxuZnVuY3Rpb24gbHQocikge1xuICByZXR1cm4gL14jW1xcZGEtZl17Nn0kL2kudGVzdChyKTtcbn1cbmZ1bmN0aW9uIE90KHIpIHtcbiAgcmV0dXJuIC9eI1tcXGRhLWZdezN9JC9pLnRlc3Qocik7XG59XG5mdW5jdGlvbiBkdChyKSB7XG4gIGNvbnN0IHQgPSByLnJlcGxhY2UoL1xccy9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobHQodCkpXG4gICAgcmV0dXJuIHQ7XG4gIGlmIChPdCh0KSkge1xuICAgIGxldCBzID0gXCIjXCI7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCAzOyBuICs9IDEpXG4gICAgICBzICs9IHRbMSArIG5dLnJlcGVhdCgyKTtcbiAgICByZXR1cm4gcztcbiAgfVxuICBjb25zdCBlID0gdC5tYXRjaCgvXnJnYlxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pXFwpJC8pIHx8IHQubWF0Y2goL15yZ2JhXFwoKFxcZHsxLDN9KSwoXFxkezEsM30pLChcXGR7MSwzfSksXFxkezEsM31cXCkkLyk7XG4gIGlmIChlID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgXCIke3J9XCIgZG9lcyBub3Qgc2F0aXNmeSBhbnkgb2Yga25vd24gUkdCIGZvcm1hdHMuYCk7XG4gIHJldHVybiBlLnNsaWNlKDEpLnJlZHVjZSgocywgbikgPT4ge1xuICAgIGNvbnN0IGkgPSBwYXJzZUludChuLCAxMCkudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBzICsgKGkubGVuZ3RoID09PSAxID8gXCIwXCIgOiBcIlwiKSArIGk7XG4gIH0sIFwiI1wiKTtcbn1cbmZ1bmN0aW9uIGZ0KHIpIHtcbiAgY29uc3QgdCA9IGR0KHIpO1xuICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgIFswLjI5OSwgMC41ODcsIDAuMTE0XS5yZWR1Y2UoKHMsIG4sIGkpID0+IHtcbiAgICAgIGNvbnN0IGEgPSBwYXJzZUludCh0LnNsaWNlKDEgKyBpICogMiwgMSArIChpICsgMSkgKiAyKSwgMTYpO1xuICAgICAgcmV0dXJuIHMgKyBhICogYSAqIG47XG4gICAgfSwgMClcbiAgKSA8IDEyMDtcbn1cbmNvbnN0IGggPSBWKChyKSA9PiB7XG4gIGlmICh0eXBlb2YgciA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiByID09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIHIudG9TdHJpbmcoKTtcbiAgdGhyb3cgUigpO1xufSwgXCJzdHJpbmdcIiksIGd0ID0gVigocikgPT4gZHQoaCgpLnBhcnNlKHIpKSwgXCJyZ2JcIik7XG5mdW5jdGlvbiBYKHIsIHQpIHtcbiAgcmV0dXJuIG5ldyB6KChlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwic3RyaW5nXCIgJiYgIShlIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSlcbiAgICAgIHRocm93IFIoKTtcbiAgICBjb25zdCBzID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IG5ldyBVUkxTZWFyY2hQYXJhbXMoZSkgOiBlO1xuICAgIHJldHVybiB1dChyLCAobikgPT4ge1xuICAgICAgY29uc3QgaSA9IHMuZ2V0KG4pO1xuICAgICAgcmV0dXJuIGkgPT09IG51bGwgPyB2b2lkIDAgOiBpO1xuICAgIH0pO1xuICB9LCAhMSwgdCk7XG59XG5mdW5jdGlvbiBIdCgpIHtcbiAgcmV0dXJuIGcoe1xuICAgIGlkOiBrKCksXG4gICAgdHlwZTogaCgpLFxuICAgIHRpdGxlOiBoKCksXG4gICAgcGhvdG9Vcmw6IHtcbiAgICAgIHR5cGU6IGgoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJwaG90b191cmxcIlxuICAgIH0sXG4gICAgdXNlcm5hbWU6IGgoKS5vcHRpb25hbCgpXG4gIH0sIFwiQ2hhdFwiKTtcbn1cbmNsYXNzIFV0IHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHRoaXMuaW5pdERhdGEgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLmF1dGhEYXRlXG4gICAqL1xuICBnZXQgYXV0aERhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEuYXV0aERhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQuY2FuU2VuZEFmdGVyXG4gICAqL1xuICBnZXQgY2FuU2VuZEFmdGVyKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLmNhblNlbmRBZnRlcjtcbiAgfVxuICAvKipcbiAgICogRGF0ZSBhZnRlciB3aGljaCBpdCBpcyBhbGxvd2VkIHRvIGNhbGxcbiAgICogdGhlIFthbnN3ZXJXZWJBcHBRdWVyeV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNhbnN3ZXJ3ZWJhcHBxdWVyeSkgbWV0aG9kLlxuICAgKi9cbiAgZ2V0IGNhblNlbmRBZnRlckRhdGUoKSB7XG4gICAgY29uc3QgeyBjYW5TZW5kQWZ0ZXI6IHQgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5ldyBEYXRlKHRoaXMuYXV0aERhdGUuZ2V0VGltZSgpICsgdCAqIDFlMyk7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQuY2hhdFxuICAgKi9cbiAgZ2V0IGNoYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEuY2hhdDtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC5jaGF0VHlwZVxuICAgKi9cbiAgZ2V0IGNoYXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLmNoYXRUeXBlO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLmNoYXRJbnN0YW5jZVxuICAgKi9cbiAgZ2V0IGNoYXRJbnN0YW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0RGF0YS5jaGF0SW5zdGFuY2U7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQuaGFzaFxuICAgKi9cbiAgZ2V0IGhhc2goKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEuaGFzaDtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC5xdWVyeUlkXG4gICAqL1xuICBnZXQgcXVlcnlJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0RGF0YS5xdWVyeUlkO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLnJlY2VpdmVyXG4gICAqL1xuICBnZXQgcmVjZWl2ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEucmVjZWl2ZXI7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQuc3RhcnRQYXJhbVxuICAgKi9cbiAgZ2V0IHN0YXJ0UGFyYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEuc3RhcnRQYXJhbTtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC51c2VyXG4gICAqL1xuICBnZXQgdXNlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0RGF0YS51c2VyO1xuICB9XG59XG5mdW5jdGlvbiBydCgpIHtcbiAgcmV0dXJuIGcoe1xuICAgIGFkZGVkVG9BdHRhY2htZW50TWVudToge1xuICAgICAgdHlwZTogUCgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcImFkZGVkX3RvX2F0dGFjaG1lbnRfbWVudVwiXG4gICAgfSxcbiAgICBhbGxvd3NXcml0ZVRvUG06IHtcbiAgICAgIHR5cGU6IFAoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJhbGxvd3Nfd3JpdGVfdG9fcG1cIlxuICAgIH0sXG4gICAgZmlyc3ROYW1lOiB7XG4gICAgICB0eXBlOiBoKCksXG4gICAgICBmcm9tOiBcImZpcnN0X25hbWVcIlxuICAgIH0sXG4gICAgaWQ6IGsoKSxcbiAgICBpc0JvdDoge1xuICAgICAgdHlwZTogUCgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcImlzX2JvdFwiXG4gICAgfSxcbiAgICBpc1ByZW1pdW06IHtcbiAgICAgIHR5cGU6IFAoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJpc19wcmVtaXVtXCJcbiAgICB9LFxuICAgIGxhbmd1YWdlQ29kZToge1xuICAgICAgdHlwZTogaCgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcImxhbmd1YWdlX2NvZGVcIlxuICAgIH0sXG4gICAgbGFzdE5hbWU6IHtcbiAgICAgIHR5cGU6IGgoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJsYXN0X25hbWVcIlxuICAgIH0sXG4gICAgcGhvdG9Vcmw6IHtcbiAgICAgIHR5cGU6IGgoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJwaG90b191cmxcIlxuICAgIH0sXG4gICAgdXNlcm5hbWU6IGgoKS5vcHRpb25hbCgpXG4gIH0sIFwiVXNlclwiKTtcbn1cbmZ1bmN0aW9uIHd0KCkge1xuICByZXR1cm4gWCh7XG4gICAgYXV0aERhdGU6IHtcbiAgICAgIHR5cGU6IHB0KCksXG4gICAgICBmcm9tOiBcImF1dGhfZGF0ZVwiXG4gICAgfSxcbiAgICBjYW5TZW5kQWZ0ZXI6IHtcbiAgICAgIHR5cGU6IGsoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJjYW5fc2VuZF9hZnRlclwiXG4gICAgfSxcbiAgICBjaGF0OiBIdCgpLm9wdGlvbmFsKCksXG4gICAgY2hhdEluc3RhbmNlOiB7XG4gICAgICB0eXBlOiBoKCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwiY2hhdF9pbnN0YW5jZVwiXG4gICAgfSxcbiAgICBjaGF0VHlwZToge1xuICAgICAgdHlwZTogaCgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcImNoYXRfdHlwZVwiXG4gICAgfSxcbiAgICBoYXNoOiBoKCksXG4gICAgcXVlcnlJZDoge1xuICAgICAgdHlwZTogaCgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInF1ZXJ5X2lkXCJcbiAgICB9LFxuICAgIHJlY2VpdmVyOiBydCgpLm9wdGlvbmFsKCksXG4gICAgc3RhcnRQYXJhbToge1xuICAgICAgdHlwZTogaCgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInN0YXJ0X3BhcmFtXCJcbiAgICB9LFxuICAgIHVzZXI6IHJ0KCkub3B0aW9uYWwoKVxuICB9LCBcIkluaXREYXRhXCIpO1xufVxuZnVuY3Rpb24gZXIocikge1xuICByZXR1cm4gd3QoKS5wYXJzZShyKTtcbn1cbmZ1bmN0aW9uIE10KHIpIHtcbiAgcmV0dXJuIHIucmVwbGFjZSgvKF58XyliZy8sICh0LCBlKSA9PiBgJHtlfWJhY2tncm91bmRgKS5yZXBsYWNlKC9fKFthLXpdKS9nLCAodCwgZSkgPT4gZS50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGp0KHIpIHtcbiAgcmV0dXJuIHIucmVwbGFjZSgvW0EtWl0vZywgKHQpID0+IGBfJHt0LnRvTG93ZXJDYXNlKCl9YCkucmVwbGFjZSgvKF58XyliYWNrZ3JvdW5kLywgKHQsIGUpID0+IGAke2V9YmdgKTtcbn1cbmNvbnN0IF90ID0gVihcbiAgKHIpID0+IHtcbiAgICBjb25zdCB0ID0gZ3QoKS5vcHRpb25hbCgpO1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhZKHIpKS5yZWR1Y2UoKGUsIFtzLCBuXSkgPT4gKGVbTXQocyldID0gdC5wYXJzZShuKSwgZSksIHt9KTtcbiAgfSxcbiAgXCJUaGVtZVBhcmFtc1wiXG4pO1xuZnVuY3Rpb24gYnQocikge1xuICByZXR1cm4gX3QoKS5wYXJzZShyKTtcbn1cbmZ1bmN0aW9uIHJyKHIgPSB7fSkge1xuICByZXR1cm4gbShcIndlYl9hcHBfcmVxdWVzdF90aGVtZVwiLCBcInRoZW1lX2NoYW5nZWRcIiwgcikudGhlbihidCk7XG59XG5mdW5jdGlvbiBHdChyKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShcbiAgICBPYmplY3QuZW50cmllcyhyKS5yZWR1Y2UoKHQsIFtlLCBzXSkgPT4gKHMgJiYgKHRbanQoZSldID0gcyksIHQpLCB7fSlcbiAgKTtcbn1cbmNsYXNzIHcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBvKHRoaXMsIFwibGlzdGVuZXJzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIG8odGhpcywgXCJzdWJzY3JpYmVMaXN0ZW5lcnNcIiwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHNwZWNpZmllZCBldmVudCBsaXN0ZW5lci5cbiAgICogQHBhcmFtIGV2ZW50IC0gZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gZXZlbnQgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSBvbmNlIC0gc2hvdWxkIGxpc3RlbmVyIGNhbGxlZCBvbmx5IG9uY2UuXG4gICAqL1xuICBhZGRMaXN0ZW5lcih0LCBlLCBzKSB7XG4gICAgbGV0IG4gPSB0aGlzLmxpc3RlbmVycy5nZXQodCk7XG4gICAgcmV0dXJuIG4gfHwgKG4gPSBbXSwgdGhpcy5saXN0ZW5lcnMuc2V0KHQsIG4pKSwgbi5wdXNoKFtlLCBzXSksICgpID0+IHRoaXMub2ZmKHQsIGUpO1xuICB9XG4gIGVtaXQodCwgLi4uZSkge1xuICAgIHRoaXMuc3Vic2NyaWJlTGlzdGVuZXJzLmZvckVhY2goKG4pID0+IG4odCwgLi4uZSkpO1xuICAgIGNvbnN0IHMgPSB0aGlzLmxpc3RlbmVycy5nZXQodCk7XG4gICAgcyAmJiBzLmZvckVhY2goKFtuLCBpXSwgYSkgPT4ge1xuICAgICAgbiguLi5lKSwgaSAmJiBzLnNwbGljZShhLCAxKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBldmVudCBsaXN0ZW5lci5cbiAgICogQHBhcmFtIGV2ZW50IC0gZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gZXZlbnQgbGlzdGVuZXIuXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIG9uKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRMaXN0ZW5lcih0LCBlLCAhMSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgZXZlbnQgbGlzdGVuZXIgZm9sbG93aW5nIHRoZSBsb2dpYywgZGVzY3JpYmVkIGluIGBvbmAgbWV0aG9kLCBidXQgY2FsbHMgc3BlY2lmaWVkXG4gICAqIGxpc3RlbmVyIG9ubHkgb25jZSwgcmVtb3ZpbmcgaXQgYWZ0ZXIuXG4gICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIGV2ZW50IGxpc3RlbmVyLlxuICAgKiBAcmV0dXJucyBGdW5jdGlvbiB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXIuXG4gICAqIEBzZWUgb25cbiAgICovXG4gIG9uY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmFkZExpc3RlbmVyKHQsIGUsICEwKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lci4gSW4gY2FzZSwgc3BlY2lmaWVkIGxpc3RlbmVyIHdhcyBib3VuZCBzZXZlcmFsIHRpbWVzLCBpdCByZW1vdmVzXG4gICAqIG9ubHkgYSBzaW5nbGUgb25lLlxuICAgKiBAcGFyYW0gZXZlbnQgLSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIG9mZih0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMubGlzdGVuZXJzLmdldCh0KTtcbiAgICBpZiAocykge1xuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBzLmxlbmd0aDsgbiArPSAxKVxuICAgICAgICBpZiAoZSA9PT0gc1tuXVswXSkge1xuICAgICAgICAgIHMuc3BsaWNlKG4sIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkcyBldmVudCBsaXN0ZW5lciB0byBhbGwgZXZlbnRzLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBldmVudHMgbGlzdGVuZXIuXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lci5cbiAgICogQHNlZSBvblxuICAgKiBAc2VlIG9uY2VcbiAgICovXG4gIHN1YnNjcmliZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlTGlzdGVuZXJzLnB1c2godCksICgpID0+IHRoaXMudW5zdWJzY3JpYmUodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZ2xvYmFsIGV2ZW50IGxpc3RlbmVyLiBJbiBjYXNlLCBzcGVjaWZpZWQgbGlzdGVuZXIgd2FzIGJvdW5kIHNldmVyYWwgdGltZXMsIGl0IHJlbW92ZXNcbiAgICogb25seSBhIHNpbmdsZSBvbmUuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIGV2ZW50cyBsaXN0ZW5lci5cbiAgICogQHJldHVybnMgRnVuY3Rpb24gdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgdW5zdWJzY3JpYmUodCkge1xuICAgIGZvciAobGV0IGUgPSAwOyBlIDwgdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMubGVuZ3RoOyBlICs9IDEpXG4gICAgICBpZiAodGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnNbZV0gPT09IHQpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMuc3BsaWNlKGUsIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cbn1cbmNsYXNzIF8ge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHQsIHRoaXMuZWUgPSBlO1xuICB9XG4gIGludGVybmFsU2V0KHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVt0XSA9PT0gZSB8fCBlID09PSB2b2lkIDAgPyAhMSA6ICh0aGlzLnN0YXRlW3RdID0gZSwgdGhpcy5lZS5lbWl0KGBjaGFuZ2U6JHt0fWAsIGUpLCAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgY29weSBvZiBjdXJyZW50IHN0YXRlLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5zdGF0ZSB9O1xuICB9XG4gIHNldCh0LCBlKSB7XG4gICAgbGV0IHMgPSAhMTtcbiAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIilcbiAgICAgIHMgPSB0aGlzLmludGVybmFsU2V0KHQsIGUpO1xuICAgIGVsc2VcbiAgICAgIGZvciAoY29uc3QgbiBpbiB0KVxuICAgICAgICB0aGlzLmludGVybmFsU2V0KG4sIHRbbl0pICYmIChzID0gITApO1xuICAgIHMgJiYgdGhpcy5lZS5lbWl0KFwiY2hhbmdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHZhbHVlIGJ5IHNwZWNpZmllZCBrZXkuXG4gICAqIEBwYXJhbSBrZXkgLSBzdGF0ZSBrZXkuXG4gICAqL1xuICBnZXQodCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlW3RdO1xuICB9XG59XG5jbGFzcyBGdCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBvKHRoaXMsIFwiZWVcIiwgbmV3IHcoKSk7XG4gICAgbyh0aGlzLCBcInN0YXRlXCIpO1xuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIG8odGhpcywgXCJvblwiLCB0aGlzLmVlLm9uLmJpbmQodGhpcy5lZSkpO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgbyh0aGlzLCBcIm9mZlwiLCB0aGlzLmVlLm9mZi5iaW5kKHRoaXMuZWUpKTtcbiAgICB0aGlzLnN0YXRlID0gbmV3IF8odCwgdGhpcy5lZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSB2Ni4xMFxuICAgKi9cbiAgZ2V0IGFjY2VudFRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJhY2NlbnRUZXh0Q29sb3JcIik7XG4gIH1cbiAgZ2V0IGJhY2tncm91bmRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJiYWNrZ3JvdW5kQ29sb3JcIik7XG4gIH1cbiAgZ2V0IGJ1dHRvbkNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImJ1dHRvbkNvbG9yXCIpO1xuICB9XG4gIGdldCBidXR0b25UZXh0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYnV0dG9uVGV4dENvbG9yXCIpO1xuICB9XG4gIGdldCBkZXN0cnVjdGl2ZVRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJkZXN0cnVjdGl2ZVRleHRDb2xvclwiKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHBhbGV0dGUgY29sb3IgdmFsdWUgYnkgaXRzIG5hbWUuXG4gICAqIEBwYXJhbSBrZXkgLSBwYWxldHRlIGtleSBuYW1lLlxuICAgKi9cbiAgZ2V0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5nZXQodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvcHkgb2YgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBjdXJyZW50IGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICovXG4gIGdldFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmNsb25lKCk7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSB2Ni4xMFxuICAgKi9cbiAgZ2V0IGhlYWRlckJhY2tncm91bmRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJoZWFkZXJCYWNrZ3JvdW5kQ29sb3JcIik7XG4gIH1cbiAgZ2V0IGhpbnRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJoaW50Q29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpbiBjYXNlLCBjdXJyZW50IGNvbG9yIHNjaGVtZSBpcyByZWNvZ25pemVkIGFzIGRhcmsuIFRoaXNcbiAgICogdmFsdWUgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlbWUgYmFja2dyb3VuZCBjb2xvci5cbiAgICovXG4gIGdldCBpc0RhcmsoKSB7XG4gICAgcmV0dXJuICF0aGlzLmJhY2tncm91bmRDb2xvciB8fCBmdCh0aGlzLmJhY2tncm91bmRDb2xvcik7XG4gIH1cbiAgZ2V0IGxpbmtDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJsaW5rQ29sb3JcIik7XG4gIH1cbiAgZ2V0IHNlY29uZGFyeUJhY2tncm91bmRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJzZWNvbmRhcnlCYWNrZ3JvdW5kQ29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSB2Ni4xMFxuICAgKi9cbiAgZ2V0IHNlY3Rpb25CYWNrZ3JvdW5kQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwic2VjdGlvbkJhY2tncm91bmRDb2xvclwiKTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIHY2LjEwXG4gICAqL1xuICBnZXQgc2VjdGlvbkhlYWRlclRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJzZWN0aW9uSGVhZGVyVGV4dENvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgbGlzdGVuaW5nIHRvIHRoZW1lIGNoYW5nZXMgYW5kIGFwcGxpZXMgdGhlbS5cbiAgICogQHJldHVybnMgRnVuY3Rpb24gdG8gc3RvcCBsaXN0ZW5pbmcuXG4gICAqL1xuICBsaXN0ZW4oKSB7XG4gICAgcmV0dXJuIHkoXCJ0aGVtZV9jaGFuZ2VkXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLnN0YXRlLnNldChidCh0LnRoZW1lX3BhcmFtcykpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgdjYuMTBcbiAgICovXG4gIGdldCBzdWJ0aXRsZVRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJzdWJ0aXRsZVRleHRDb2xvclwiKTtcbiAgfVxuICBnZXQgdGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInRleHRDb2xvclwiKTtcbiAgfVxufVxuZnVuY3Rpb24gbXQoKSB7XG4gIHJldHVybiBYKHtcbiAgICBib3RJbmxpbmU6IHtcbiAgICAgIHR5cGU6IFAoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJ0Z1dlYkFwcEJvdElubGluZVwiXG4gICAgfSxcbiAgICBpbml0RGF0YToge1xuICAgICAgdHlwZTogd3QoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJ0Z1dlYkFwcERhdGFcIlxuICAgIH0sXG4gICAgaW5pdERhdGFSYXc6IHtcbiAgICAgIHR5cGU6IGgoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJ0Z1dlYkFwcERhdGFcIlxuICAgIH0sXG4gICAgcGxhdGZvcm06IHtcbiAgICAgIHR5cGU6IGgoKSxcbiAgICAgIGZyb206IFwidGdXZWJBcHBQbGF0Zm9ybVwiXG4gICAgfSxcbiAgICBzaG93U2V0dGluZ3M6IHtcbiAgICAgIHR5cGU6IFAoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJ0Z1dlYkFwcFNob3dTZXR0aW5nc1wiXG4gICAgfSxcbiAgICB0aGVtZVBhcmFtczoge1xuICAgICAgdHlwZTogX3QoKSxcbiAgICAgIGZyb206IFwidGdXZWJBcHBUaGVtZVBhcmFtc1wiXG4gICAgfSxcbiAgICB2ZXJzaW9uOiB7XG4gICAgICB0eXBlOiBoKCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwVmVyc2lvblwiXG4gICAgfVxuICB9LCBcIkxhdW5jaFBhcmFtc1wiKTtcbn1cbmZ1bmN0aW9uIHl0KHIpIHtcbiAgcmV0dXJuIG10KCkucGFyc2Uocik7XG59XG5mdW5jdGlvbiB6dCgpIHtcbiAgcmV0dXJuIHl0KHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpKTtcbn1cbmZ1bmN0aW9uIEp0KCkge1xuICBjb25zdCByID0gaHQoKTtcbiAgaWYgKCFyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBnZXQgZmlyc3QgbmF2aWdhdGlvbiBlbnRyeS5cIik7XG4gIGNvbnN0IHQgPSByLm5hbWUubWF0Y2goLyMoLiopLyk7XG4gIGlmICghdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBuYXZpZ2F0aW9uIGVudHJ5IGRvZXMgbm90IGNvbnRhaW4gaGFzaCBwYXJ0LlwiKTtcbiAgcmV0dXJuIHl0KHRbMV0pO1xufVxuZnVuY3Rpb24gUXQoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEp0KCk7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHp0KCk7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gWnQocikge1xuICBjb25zdCB7XG4gICAgaW5pdERhdGFSYXc6IHQsXG4gICAgdGhlbWVQYXJhbXM6IGUsXG4gICAgcGxhdGZvcm06IHMsXG4gICAgdmVyc2lvbjogbixcbiAgICBzaG93U2V0dGluZ3M6IGksXG4gICAgYm90SW5saW5lOiBhXG4gIH0gPSByLCBjID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICByZXR1cm4gdCAmJiBjLnNldChcInRnV2ViQXBwRGF0YVwiLCB0KSwgYy5zZXQoXCJ0Z1dlYkFwcFBsYXRmb3JtXCIsIHMpLCBjLnNldChcInRnV2ViQXBwVGhlbWVQYXJhbXNcIiwgR3QoZSkpLCBjLnNldChcInRnV2ViQXBwVmVyc2lvblwiLCBuKSwgdHlwZW9mIGkgPT0gXCJib29sZWFuXCIgJiYgYy5zZXQoXCJ0Z1dlYkFwcFNob3dTZXR0aW5nc1wiLCBpID8gXCIxXCIgOiBcIjBcIiksIHR5cGVvZiBhID09IFwiYm9vbGVhblwiICYmIGMuc2V0KFwidGdXZWJBcHBCb3RJbmxpbmVcIiwgYSA/IFwiMVwiIDogXCIwXCIpLCBjLnRvU3RyaW5nKCk7XG59XG5jb25zdCBFdCA9IFwidGVsZWdyYW0tbWluaS1hcHBzLWxhdW5jaC1wYXJhbXNcIjtcbmZ1bmN0aW9uIEt0KCkge1xuICBjb25zdCByID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShFdCk7XG4gIHJldHVybiByID8gbXQoKS5wYXJzZShyKSA6IG51bGw7XG59XG5mdW5jdGlvbiBZdChyKSB7XG4gIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oRXQsIFp0KHIpKTtcbn1cbmZ1bmN0aW9uIFh0KCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuc2VsZiAhPT0gd2luZG93LnRvcDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICEwO1xuICB9XG59XG5mdW5jdGlvbiB0ZSgpIHtcbiAgY29uc3QgciA9IEt0KCksIHQgPSBRdCgpLCBlID0gQnQoKTtcbiAgaWYgKHIpIHtcbiAgICBpZiAodClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhdW5jaFBhcmFtczogdCxcbiAgICAgICAgaXNQYWdlUmVsb2FkOiBYdCgpID8gZSB8fCByLmluaXREYXRhUmF3ID09PSB0LmluaXREYXRhUmF3IDogITBcbiAgICAgIH07XG4gICAgaWYgKGUpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYXVuY2hQYXJhbXM6IHIsXG4gICAgICAgIGlzUGFnZVJlbG9hZDogZVxuICAgICAgfTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmV0cmlldmUgY3VycmVudCBsYXVuY2ggcGFyYW1ldGVycywgd2hpY2ggbXVzdCBleGlzdC5cIik7XG4gIH1cbiAgaWYgKHQpXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhdW5jaFBhcmFtczogdCxcbiAgICAgIGlzUGFnZVJlbG9hZDogITFcbiAgICB9O1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmV0cmlldmUgYW55IGxhdW5jaCBwYXJhbWV0ZXJzLlwiKTtcbn1cbmNvbnN0IHN0ID0gXCJ0bWFqc0xhdW5jaERhdGFcIjtcbmZ1bmN0aW9uIEN0KCkge1xuICBjb25zdCByID0gd2luZG93W3N0XTtcbiAgaWYgKHIpXG4gICAgcmV0dXJuIHI7XG4gIGNvbnN0IHQgPSB0ZSgpO1xuICByZXR1cm4gd2luZG93W3N0XSA9IHQsIFl0KHQubGF1bmNoUGFyYW1zKSwgdDtcbn1cbmZ1bmN0aW9uIHNyKCkge1xuICB0cnkge1xuICAgIHJldHVybiBDdCgpLCAhMDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBlZShyKSB7XG4gIHJldHVybiBcImV4dGVybmFsXCIgaW4gciAmJiBIKHIuZXh0ZXJuYWwpICYmIFwibm90aWZ5XCIgaW4gci5leHRlcm5hbCAmJiB0eXBlb2Ygci5leHRlcm5hbC5ub3RpZnkgPT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gcmUocikge1xuICByZXR1cm4gXCJUZWxlZ3JhbVdlYnZpZXdQcm94eVwiIGluIHIgJiYgSChyLlRlbGVncmFtV2Vidmlld1Byb3h5KSAmJiBcInBvc3RFdmVudFwiIGluIHIuVGVsZWdyYW1XZWJ2aWV3UHJveHkgJiYgdHlwZW9mIHIuVGVsZWdyYW1XZWJ2aWV3UHJveHkucG9zdEV2ZW50ID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIHZ0KCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuc2VsZiAhPT0gd2luZG93LnRvcDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICEwO1xuICB9XG59XG5jbGFzcyB0dCBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKGBNZXRob2QgXCIke3R9XCIgaXMgdW5zdXBwb3J0ZWQgaW4gdGhlIE1pbmkgQXBwcyB2ZXJzaW9uICR7ZX0uYCksIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCB0dC5wcm90b3R5cGUpO1xuICB9XG59XG5jbGFzcyBldCBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IodCwgZSwgcykge1xuICAgIHN1cGVyKGBQYXJhbWV0ZXIgXCIke2V9XCIgaW4gbWV0aG9kIFwiJHt0fVwiIGlzIHVuc3VwcG9ydGVkIGluIHRoZSBNaW5pIEFwcHMgdmVyc2lvbiAke3N9LmApLCBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgZXQucHJvdG90eXBlKTtcbiAgfVxufVxuY2xhc3MgUHQge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5wcmVmaXggPSB0LCB0aGlzLmVuYWJsZWQgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBQcmludHMgbWVzc2FnZSBpbnRvIGEgY29uc29sZSBpbiBjYXNlLCBsb2dnZXIgaXMgY3VycmVudGx5IGVuYWJsZWQuXG4gICAqIEBwYXJhbSBsZXZlbCAtIGxvZyBsZXZlbC5cbiAgICogQHBhcmFtIGFyZ3MgLSBhcmd1bWVudHMuXG4gICAqL1xuICBwcmludCh0LCAuLi5lKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBuID0gSW50bC5EYXRlVGltZUZvcm1hdChcImVuLUdCXCIsIHtcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICAgIHNlY29uZDogXCIyLWRpZ2l0XCIsXG4gICAgICBmcmFjdGlvbmFsU2Vjb25kRGlnaXRzOiAzLFxuICAgICAgdGltZVpvbmU6IFwiVVRDXCJcbiAgICB9KS5mb3JtYXQocyk7XG4gICAgY29uc29sZVt0XShgWyR7bn1dYCwgdGhpcy5wcmVmaXgsIC4uLmUpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgbG9nZ2VyLlxuICAgKi9cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSAhMTtcbiAgfVxuICAvKipcbiAgICogUHJpbnRzIGVycm9yIG1lc3NhZ2UgaW50byBhIGNvbnNvbGUuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICBlcnJvciguLi50KSB7XG4gICAgdGhpcy5wcmludChcImVycm9yXCIsIC4uLnQpO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBsb2dnZXIuXG4gICAqL1xuICBlbmFibGUoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gITA7XG4gIH1cbiAgLyoqXG4gICAqIFByaW50cyBsb2cgbWVzc2FnZSBpbnRvIGEgY29uc29sZS5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIGxvZyguLi50KSB7XG4gICAgdGhpcy5wcmludChcImxvZ1wiLCAuLi50KTtcbiAgfVxuICAvKipcbiAgICogUHJpbnRzIHdhcm5pbmcgbWVzc2FnZSBpbnRvIGEgY29uc29sZS5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIHdhcm4oLi4udCkge1xuICAgIHRoaXMucHJpbnQoXCJ3YXJuXCIsIC4uLnQpO1xuICB9XG59XG5sZXQgU3QgPSBcImh0dHBzOi8vd2ViLnRlbGVncmFtLm9yZ1wiO1xuY29uc3QgcSA9IG5ldyBQdChcIltTREtdXCIsICExKTtcbmZ1bmN0aW9uIG5yKHIpIHtcbiAgaWYgKHIpIHtcbiAgICBxLmVuYWJsZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICBxLmRpc2FibGUoKTtcbn1cbmZ1bmN0aW9uIGlyKHIpIHtcbiAgU3QgPSByO1xufVxuZnVuY3Rpb24gc2UoKSB7XG4gIHJldHVybiBTdDtcbn1cbmNvbnN0IG5lID0gZyh7XG4gIGV2ZW50VHlwZTogaCgpLFxuICBldmVudERhdGE6IChyKSA9PiByXG59KTtcbmZ1bmN0aW9uIGllKHIsIHQpIHtcbiAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IE1lc3NhZ2VFdmVudChcIm1lc3NhZ2VcIiwge1xuICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHsgZXZlbnRUeXBlOiByLCBldmVudERhdGE6IHQgfSlcbiAgfSkpO1xufVxuZnVuY3Rpb24gb2UoKSB7XG4gIGNvbnN0IHIgPSB3aW5kb3c7XG4gIFwiVGVsZWdyYW1HYW1lUHJveHlfcmVjZWl2ZUV2ZW50XCIgaW4gciB8fCBbXG4gICAgW1wiVGVsZWdyYW1HYW1lUHJveHlfcmVjZWl2ZUV2ZW50XCJdLFxuICAgIC8vIFdpbmRvd3MgUGhvbmUuXG4gICAgW1wiVGVsZWdyYW1HYW1lUHJveHlcIiwgXCJyZWNlaXZlRXZlbnRcIl0sXG4gICAgLy8gRGVza3RvcC5cbiAgICBbXCJUZWxlZ3JhbVwiLCBcIldlYlZpZXdcIiwgXCJyZWNlaXZlRXZlbnRcIl1cbiAgICAvLyBBbmRyb2lkIGFuZCBpT1MuXG4gIF0uZm9yRWFjaCgodCkgPT4ge1xuICAgIGxldCBlID0gcjtcbiAgICB0LmZvckVhY2goKHMsIG4sIGkpID0+IHtcbiAgICAgIGlmIChuID09PSBpLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgZVtzXSA9IGllO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzIGluIGUgfHwgKGVbc10gPSB7fSksIGUgPSBlW3NdO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFlKHIpIHtcbiAgb2UoKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsICh0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXZlbnRUeXBlOiBlLCBldmVudERhdGE6IHMgfSA9IG5lLnBhcnNlKHQuZGF0YSk7XG4gICAgICByKGUsIHMpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjZSgpIHtcbiAgcmV0dXJuIGcoe1xuICAgIHJlcV9pZDogaCgpLFxuICAgIGRhdGE6IChyKSA9PiByID09PSBudWxsID8gciA6IGgoKS5vcHRpb25hbCgpLnBhcnNlKHIpXG4gIH0pO1xufVxuZnVuY3Rpb24gaGUoKSB7XG4gIHJldHVybiBnKHtcbiAgICByZXFfaWQ6IGgoKSxcbiAgICByZXN1bHQ6IChyKSA9PiByLFxuICAgIGVycm9yOiBoKCkub3B0aW9uYWwoKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVlKCkge1xuICByZXR1cm4gZyh7XG4gICAgc2x1ZzogaCgpLFxuICAgIHN0YXR1czogaCgpXG4gIH0pO1xufVxuZnVuY3Rpb24gcGUoKSB7XG4gIHJldHVybiBnKHsgc3RhdHVzOiBoKCkgfSk7XG59XG5mdW5jdGlvbiBsZSgpIHtcbiAgcmV0dXJuIGcoe1xuICAgIGJ1dHRvbl9pZDogKHIpID0+IHIgPT0gbnVsbCA/IHZvaWQgMCA6IGgoKS5wYXJzZShyKVxuICB9KTtcbn1cbmZ1bmN0aW9uIGRlKCkge1xuICByZXR1cm4gZyh7XG4gICAgZGF0YTogaCgpLm9wdGlvbmFsKClcbiAgfSk7XG59XG5mdW5jdGlvbiBmZSgpIHtcbiAgcmV0dXJuIGcoe1xuICAgIHRoZW1lX3BhcmFtczogKHIpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBndCgpLm9wdGlvbmFsKCk7XG4gICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoWShyKSkucmVkdWNlKChlLCBbcywgbl0pID0+IChlW3NdID0gdC5wYXJzZShuKSwgZSksIHt9KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2UoKSB7XG4gIHJldHVybiBnKHtcbiAgICBoZWlnaHQ6IGsoKSxcbiAgICB3aWR0aDogKHIpID0+IHIgPT0gbnVsbCA/IHdpbmRvdy5pbm5lcldpZHRoIDogaygpLnBhcnNlKHIpLFxuICAgIGlzX3N0YXRlX3N0YWJsZTogUCgpLFxuICAgIGlzX2V4cGFuZGVkOiBQKClcbiAgfSk7XG59XG5mdW5jdGlvbiB3ZSgpIHtcbiAgcmV0dXJuIGcoeyBzdGF0dXM6IGgoKSB9KTtcbn1cbmZ1bmN0aW9uIF9lKCkge1xuICBjb25zdCByID0gbmV3IHcoKSwgdCA9IChlLCAuLi5zKSA9PiB7XG4gICAgcS5sb2coXCJFbWl0dGluZyBwcm9jZXNzZWQgZXZlbnQ6XCIsIGUsIC4uLnMpLCByLmVtaXQoZSwgLi4ucyk7XG4gIH07XG4gIHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAoKSA9PiB7XG4gICAgdChcInZpZXdwb3J0X2NoYW5nZWRcIiwge1xuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICBpc19zdGF0ZV9zdGFibGU6ICEwLFxuICAgICAgaXNfZXhwYW5kZWQ6ICEwXG4gICAgfSk7XG4gIH0pLCBhZSgoZSwgcykgPT4ge1xuICAgIHEubG9nKFwiUmVjZWl2ZWQgcmF3IGV2ZW50OlwiLCBlLCBzKTtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgXCJ2aWV3cG9ydF9jaGFuZ2VkXCI6XG4gICAgICAgICAgcmV0dXJuIHQoZSwgZ2UoKS5wYXJzZShzKSk7XG4gICAgICAgIGNhc2UgXCJ0aGVtZV9jaGFuZ2VkXCI6XG4gICAgICAgICAgcmV0dXJuIHQoZSwgZmUoKS5wYXJzZShzKSk7XG4gICAgICAgIGNhc2UgXCJwb3B1cF9jbG9zZWRcIjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gU2VudCBvbiBkZXNrdG9wLlxuICAgICAgICAgICAgcyA9PSBudWxsID8gdChlLCB7fSkgOiB0KGUsIGxlKCkucGFyc2UocykpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcInNldF9jdXN0b21fc3R5bGVcIjpcbiAgICAgICAgICByZXR1cm4gdChlLCBoKCkucGFyc2UocykpO1xuICAgICAgICBjYXNlIFwicXJfdGV4dF9yZWNlaXZlZFwiOlxuICAgICAgICAgIHJldHVybiB0KGUsIGRlKCkucGFyc2UocykpO1xuICAgICAgICBjYXNlIFwiY2xpcGJvYXJkX3RleHRfcmVjZWl2ZWRcIjpcbiAgICAgICAgICByZXR1cm4gdChlLCBjZSgpLnBhcnNlKHMpKTtcbiAgICAgICAgY2FzZSBcImludm9pY2VfY2xvc2VkXCI6XG4gICAgICAgICAgcmV0dXJuIHQoZSwgdWUoKS5wYXJzZShzKSk7XG4gICAgICAgIGNhc2UgXCJwaG9uZV9yZXF1ZXN0ZWRcIjpcbiAgICAgICAgICByZXR1cm4gdChcInBob25lX3JlcXVlc3RlZFwiLCBwZSgpLnBhcnNlKHMpKTtcbiAgICAgICAgY2FzZSBcImN1c3RvbV9tZXRob2RfaW52b2tlZFwiOlxuICAgICAgICAgIHJldHVybiB0KFwiY3VzdG9tX21ldGhvZF9pbnZva2VkXCIsIGhlKCkucGFyc2UocykpO1xuICAgICAgICBjYXNlIFwid3JpdGVfYWNjZXNzX3JlcXVlc3RlZFwiOlxuICAgICAgICAgIHJldHVybiB0KFwid3JpdGVfYWNjZXNzX3JlcXVlc3RlZFwiLCB3ZSgpLnBhcnNlKHMpKTtcbiAgICAgICAgY2FzZSBcIm1haW5fYnV0dG9uX3ByZXNzZWRcIjpcbiAgICAgICAgY2FzZSBcImJhY2tfYnV0dG9uX3ByZXNzZWRcIjpcbiAgICAgICAgY2FzZSBcInNldHRpbmdzX2J1dHRvbl9wcmVzc2VkXCI6XG4gICAgICAgIGNhc2UgXCJzY2FuX3FyX3BvcHVwX2Nsb3NlZFwiOlxuICAgICAgICBjYXNlIFwicmVsb2FkX2lmcmFtZVwiOlxuICAgICAgICAgIHJldHVybiB0KGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0KGUsIHMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgIHEuZXJyb3IoXCJFcnJvciBwcm9jZXNzaW5nIGV2ZW50OlwiLCBuKTtcbiAgICB9XG4gIH0pLCByO1xufVxuY29uc3QgUSA9IFwidGVsZWdyYW0tbWluaS1hcHBzLWNhY2hlZC1lbWl0dGVyXCI7XG5mdW5jdGlvbiBVKCkge1xuICBjb25zdCByID0gd2luZG93O1xuICByZXR1cm4gcltRXSA9PT0gdm9pZCAwICYmIChyW1FdID0gX2UoKSksIHJbUV07XG59XG5mdW5jdGlvbiBJKHIsIHQpIHtcbiAgVSgpLm9mZihyLCB0KTtcbn1cbmZ1bmN0aW9uIHkociwgdCkge1xuICByZXR1cm4gVSgpLm9uKHIsIHQpLCAoKSA9PiBJKHIsIHQpO1xufVxuZnVuY3Rpb24gb3IociwgdCkge1xuICByZXR1cm4gVSgpLm9uY2UociwgdCksICgpID0+IEkociwgdCk7XG59XG5mdW5jdGlvbiBiZShyKSB7XG4gIFUoKS51bnN1YnNjcmliZShyKTtcbn1cbmZ1bmN0aW9uIGFyKHIpIHtcbiAgcmV0dXJuIFUoKS5zdWJzY3JpYmUociksICgpID0+IGJlKHIpO1xufVxuZnVuY3Rpb24gbWUociwgdCkge1xuICBjb25zdCBlID0gci5zcGxpdChcIi5cIiksIHMgPSB0LnNwbGl0KFwiLlwiKSwgbiA9IE1hdGgubWF4KGUubGVuZ3RoLCBzLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSArPSAxKSB7XG4gICAgY29uc3QgYSA9IHBhcnNlSW50KGVbaV0gfHwgXCIwXCIsIDEwKSwgYyA9IHBhcnNlSW50KHNbaV0gfHwgXCIwXCIsIDEwKTtcbiAgICBpZiAoYSAhPT0gYylcbiAgICAgIHJldHVybiBhID4gYyA/IDEgOiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHYociwgdCkge1xuICByZXR1cm4gbWUociwgdCkgPD0gMDtcbn1cbmZ1bmN0aW9uIEEociwgdCwgZSkge1xuICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChyID09PSBcIndlYl9hcHBfb3Blbl9saW5rXCIgJiYgdCA9PT0gXCJ0cnlfaW5zdGFudF92aWV3XCIpXG4gICAgICByZXR1cm4gdihcIjYuNFwiLCBlKTtcbiAgICBpZiAociA9PT0gXCJ3ZWJfYXBwX3NldF9oZWFkZXJfY29sb3JcIiAmJiB0ID09PSBcImNvbG9yXCIpXG4gICAgICByZXR1cm4gdihcIjYuOVwiLCBlKTtcbiAgfVxuICBzd2l0Y2ggKHIpIHtcbiAgICBjYXNlIFwid2ViX2FwcF9vcGVuX3RnX2xpbmtcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9vcGVuX2ludm9pY2VcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9zZXR1cF9iYWNrX2J1dHRvblwiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX3NldF9iYWNrZ3JvdW5kX2NvbG9yXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX3RyaWdnZXJfaGFwdGljX2ZlZWRiYWNrXCI6XG4gICAgICByZXR1cm4gdihcIjYuMVwiLCB0KTtcbiAgICBjYXNlIFwid2ViX2FwcF9vcGVuX3BvcHVwXCI6XG4gICAgICByZXR1cm4gdihcIjYuMlwiLCB0KTtcbiAgICBjYXNlIFwid2ViX2FwcF9jbG9zZV9zY2FuX3FyX3BvcHVwXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfb3Blbl9zY2FuX3FyX3BvcHVwXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfcmVhZF90ZXh0X2Zyb21fY2xpcGJvYXJkXCI6XG4gICAgICByZXR1cm4gdihcIjYuNFwiLCB0KTtcbiAgICBjYXNlIFwid2ViX2FwcF9zd2l0Y2hfaW5saW5lX3F1ZXJ5XCI6XG4gICAgICByZXR1cm4gdihcIjYuN1wiLCB0KTtcbiAgICBjYXNlIFwid2ViX2FwcF9pbnZva2VfY3VzdG9tX21ldGhvZFwiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX3JlcXVlc3Rfd3JpdGVfYWNjZXNzXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfcmVxdWVzdF9waG9uZVwiOlxuICAgICAgcmV0dXJuIHYoXCI2LjlcIiwgdCk7XG4gICAgY2FzZSBcIndlYl9hcHBfc2V0dXBfc2V0dGluZ3NfYnV0dG9uXCI6XG4gICAgICByZXR1cm4gdihcIjYuMTBcIiwgdCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAhMDtcbiAgfVxufVxuZnVuY3Rpb24gRShyLCB0KSB7XG4gIHJldHVybiAoZSkgPT4gQSh0W2VdLCByKTtcbn1cbmZ1bmN0aW9uIGt0KHIsIHQpIHtcbiAgcmV0dXJuIChlKSA9PiB7XG4gICAgY29uc3QgW3MsIG5dID0gdFtlXTtcbiAgICByZXR1cm4gQShzLCBuLCByKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGYociwgdCwgZSkge1xuICBsZXQgcyA9IHt9LCBuO1xuICB0ID09PSB2b2lkIDAgJiYgZSA9PT0gdm9pZCAwID8gcyA9IHt9IDogdCAhPT0gdm9pZCAwICYmIGUgIT09IHZvaWQgMCA/IChzID0gZSwgbiA9IHQpIDogdCAhPT0gdm9pZCAwICYmIChcInRhcmdldE9yaWdpblwiIGluIHQgPyBzID0gdCA6IG4gPSB0KTtcbiAgY29uc3QgeyB0YXJnZXRPcmlnaW46IGkgPSBzZSgpIH0gPSBzO1xuICBpZiAocS5sb2coYENhbGxpbmcgbWV0aG9kIFwiJHtyfVwiYCwgbiksIHZ0KCkpIHtcbiAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGV2ZW50VHlwZTogcixcbiAgICAgIGV2ZW50RGF0YTogblxuICAgIH0pLCBpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVlKHdpbmRvdykpIHtcbiAgICB3aW5kb3cuZXh0ZXJuYWwubm90aWZ5KEpTT04uc3RyaW5naWZ5KHsgZXZlbnRUeXBlOiByLCBldmVudERhdGE6IG4gfSkpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmUod2luZG93KSkge1xuICAgIHdpbmRvdy5UZWxlZ3JhbVdlYnZpZXdQcm94eS5wb3N0RXZlbnQociwgSlNPTi5zdHJpbmdpZnkobikpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJVbmFibGUgdG8gZGV0ZXJtaW5lIGN1cnJlbnQgZW52aXJvbm1lbnQgYW5kIHBvc3NpYmxlIHdheSB0byBzZW5kIGV2ZW50LlwiXG4gICk7XG59XG5mdW5jdGlvbiB5ZShyKSB7XG4gIHJldHVybiAodCwgZSkgPT4ge1xuICAgIGlmICghQSh0LCByKSlcbiAgICAgIHRocm93IG5ldyB0dCh0LCByKTtcbiAgICBpZiAoSChlKSkge1xuICAgICAgbGV0IHM7XG4gICAgICBpZiAodCA9PT0gXCJ3ZWJfYXBwX29wZW5fbGlua1wiICYmIFwidHJ5X2luc3RhbnRfdmlld1wiIGluIGUgPyBzID0gXCJ0cnlfaW5zdGFudF92aWV3XCIgOiB0ID09PSBcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiICYmIFwiY29sb3JcIiBpbiBlICYmIChzID0gXCJjb2xvclwiKSwgcyAmJiAhQSh0LCBzLCByKSlcbiAgICAgICAgdGhyb3cgbmV3IGV0KHQsIHMsIHIpO1xuICAgIH1cbiAgICByZXR1cm4gZih0LCBlKTtcbiAgfTtcbn1cbmNsYXNzIEogZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcihgQXN5bmMgY2FsbCB0aW1lb3V0IGV4Y2VlZGVkLiBUaW1lb3V0OiAke3R9YCksIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBKLnByb3RvdHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyKHIpIHtcbiAgcmV0dXJuIHIgaW5zdGFuY2VvZiBKO1xufVxuZnVuY3Rpb24gRWUocikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHQpID0+IHtcbiAgICBzZXRUaW1lb3V0KHQsIHIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIENlKHIpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKCh0LCBlKSA9PiB7XG4gICAgc2V0VGltZW91dChlLCByLCBuZXcgSihyKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24geHQociwgdCkge1xuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICByKCksXG4gICAgQ2UodClcbiAgXSk7XG59XG5mdW5jdGlvbiBtKHIsIHQsIGUsIHMpIHtcbiAgbGV0IG4sIGksIGEsIGM7XG4gIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSh0KSA/IChhID0gQXJyYXkuaXNBcnJheSh0KSA/IHQgOiBbdF0sIG4gPSBlKSA6IChpID0gdCwgYSA9IEFycmF5LmlzQXJyYXkoZSkgPyBlIDogW2VdLCBuID0gcyksIEgoaSkgJiYgdHlwZW9mIGkucmVxX2lkID09IFwic3RyaW5nXCIgJiYgKGMgPSBpLnJlcV9pZCk7XG4gIGNvbnN0IHsgcG9zdEV2ZW50OiB1ID0gZiwgdGltZW91dDogcCB9ID0gbiB8fCB7fSwgbCA9IG4gJiYgXCJjYXB0dXJlXCIgaW4gbiA/IG4uY2FwdHVyZSA6IG51bGwsIGIgPSAoKSA9PiBuZXcgUHJvbWlzZSgoZCwgQykgPT4ge1xuICAgIGNvbnN0IHggPSBhLm1hcCgoQikgPT4geShCLCAoTSkgPT4ge1xuICAgICAgYyAmJiAoIUgoTSkgfHwgTS5yZXFfaWQgIT09IGMpIHx8IHR5cGVvZiBsID09IFwiZnVuY3Rpb25cIiAmJiAhbChNKSB8fCAoVCgpLCBkKE0pKTtcbiAgICB9KSksIFQgPSAoKSA9PiB4LmZvckVhY2goKEIpID0+IEIoKSk7XG4gICAgdHJ5IHtcbiAgICAgIHUociwgaSk7XG4gICAgfSBjYXRjaCAoQikge1xuICAgICAgVCgpLCBDKEIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0eXBlb2YgcCA9PSBcIm51bWJlclwiID8geHQoYiwgcCkgOiBiKCk7XG59XG5hc3luYyBmdW5jdGlvbiBOKHIsIHQsIGUsIHMgPSB7fSkge1xuICBjb25zdCB7IHJlc3VsdDogbiwgZXJyb3I6IGkgfSA9IGF3YWl0IG0oXG4gICAgXCJ3ZWJfYXBwX2ludm9rZV9jdXN0b21fbWV0aG9kXCIsXG4gICAge1xuICAgICAgbWV0aG9kOiByLFxuICAgICAgcGFyYW1zOiB0LFxuICAgICAgcmVxX2lkOiBlXG4gICAgfSxcbiAgICBcImN1c3RvbV9tZXRob2RfaW52b2tlZFwiLFxuICAgIHNcbiAgKTtcbiAgaWYgKGkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGkpO1xuICByZXR1cm4gbjtcbn1cbmNsYXNzIHZlIHtcbiAgY29uc3RydWN0b3IodCwgZSwgcyA9IGYpIHtcbiAgICBvKHRoaXMsIFwiZWVcIiwgbmV3IHcoKSk7XG4gICAgbyh0aGlzLCBcInN0YXRlXCIpO1xuICAgIC8qKlxuICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIGV2ZW50IC0gZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBvKHRoaXMsIFwib25cIiwgKHQsIGUpID0+IHQgPT09IFwiY2xpY2tcIiA/IHkoXCJiYWNrX2J1dHRvbl9wcmVzc2VkXCIsIGUpIDogdGhpcy5lZS5vbih0LCBlKSk7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIG8odGhpcywgXCJvZmZcIiwgKHQsIGUpID0+IHQgPT09IFwiY2xpY2tcIiA/IEkoXCJiYWNrX2J1dHRvbl9wcmVzc2VkXCIsIGUpIDogdGhpcy5lZS5vZmYodCwgZSkpO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBzcGVjaWZpZWQgbWV0aG9kIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBvKHRoaXMsIFwic3VwcG9ydHNcIik7XG4gICAgdGhpcy5wb3N0RXZlbnQgPSBzLCB0aGlzLnN0YXRlID0gbmV3IF8oeyBpc1Zpc2libGU6IHQgfSwgdGhpcy5lZSksIHRoaXMuc3VwcG9ydHMgPSBFKGUsIHtcbiAgICAgIHNob3c6IFwid2ViX2FwcF9zZXR1cF9iYWNrX2J1dHRvblwiLFxuICAgICAgaGlkZTogXCJ3ZWJfYXBwX3NldHVwX2JhY2tfYnV0dG9uXCJcbiAgICB9KTtcbiAgfVxuICBzZXQgaXNWaXNpYmxlKHQpIHtcbiAgICB0aGlzLnN0YXRlLnNldChcImlzVmlzaWJsZVwiLCB0KSwgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3NldHVwX2JhY2tfYnV0dG9uXCIsIHsgaXNfdmlzaWJsZTogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBCYWNrQnV0dG9uIGlzIGN1cnJlbnRseSB2aXNpYmxlLlxuICAgKi9cbiAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5nZXQoXCJpc1Zpc2libGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBCYWNrQnV0dG9uLlxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLmlzVmlzaWJsZSA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB0aGUgQmFja0J1dHRvbi5cbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy5pc1Zpc2libGUgPSAhMDtcbiAgfVxufVxuZnVuY3Rpb24gbnQociwgdCkge1xuICByZXR1cm4gciArIChyLmxlbmd0aCA+IDAgJiYgdC5sZW5ndGggPiAwID8gYCAke3R9YCA6IHQpO1xufVxuZnVuY3Rpb24gUGUoLi4ucikge1xuICByZXR1cm4gci5yZWR1Y2UoKHQsIGUpID0+IHtcbiAgICBsZXQgcyA9IFwiXCI7XG4gICAgcmV0dXJuIHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBzID0gZSA6IHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiAocyA9IE9iamVjdC5lbnRyaWVzKGUpLnJlZHVjZSgobiwgW2ksIGFdKSA9PiBhID8gbnQobiwgaSkgOiBuLCBcIlwiKSksIG50KHQsIHMpO1xuICB9LCBcIlwiKTtcbn1cbmZ1bmN0aW9uIFNlKHIpIHtcbiAgcmV0dXJuIHR5cGVvZiByID09IFwib2JqZWN0XCIgJiYgciAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShudWxsKTtcbn1cbmZ1bmN0aW9uIGhyKC4uLnIpIHtcbiAgcmV0dXJuIHIucmVkdWNlKCh0LCBlKSA9PiAoU2UoZSkgJiYgT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW3MsIG5dKSA9PiB7XG4gICAgY29uc3QgaSA9IFBlKHRbc10sIG4pO1xuICAgIGkubGVuZ3RoID4gMCAmJiAodFtzXSA9IGkpO1xuICB9KSwgdCksIHt9KTtcbn1cbmNsYXNzIGtlIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IGYpIHtcbiAgICBvKHRoaXMsIFwiZWVcIiwgbmV3IHcoKSk7XG4gICAgbyh0aGlzLCBcInN0YXRlXCIpO1xuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIG8odGhpcywgXCJvblwiLCB0aGlzLmVlLm9uLmJpbmQodGhpcy5lZSkpO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgbyh0aGlzLCBcIm9mZlwiLCB0aGlzLmVlLm9mZi5iaW5kKHRoaXMuZWUpKTtcbiAgICB0aGlzLnBvc3RFdmVudCA9IGUsIHRoaXMuc3RhdGUgPSBuZXcgXyh7IGlzQ29uZmlybWF0aW9uTmVlZGVkOiB0IH0sIHRoaXMuZWUpO1xuICB9XG4gIHNldCBpc0NvbmZpcm1hdGlvbk5lZWRlZCh0KSB7XG4gICAgdGhpcy5zdGF0ZS5zZXQoXCJpc0NvbmZpcm1hdGlvbk5lZWRlZFwiLCB0KSwgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3NldHVwX2Nsb3NpbmdfYmVoYXZpb3JcIiwgeyBuZWVkX2NvbmZpcm1hdGlvbjogdCB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlLCBpZiB0aGUgY29uZmlybWF0aW9uIGRpYWxvZyBlbmFibGVkIHdoaWxlIHRoZSB1c2VyIGlzIHRyeWluZ1xuICAgKiB0byBjbG9zZSB0aGUgTWluaSBBcHAuXG4gICAqL1xuICBnZXQgaXNDb25maXJtYXRpb25OZWVkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZ2V0KFwiaXNDb25maXJtYXRpb25OZWVkZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBjb25maXJtYXRpb24gZGlhbG9nIHdoaWxlIHRoZSB1c2VyIGlzIHRyeWluZyB0byBjbG9zZSB0aGVcbiAgICogTWluaSBBcHAuXG4gICAqL1xuICBkaXNhYmxlQ29uZmlybWF0aW9uKCkge1xuICAgIHRoaXMuaXNDb25maXJtYXRpb25OZWVkZWQgPSAhMTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyB0aGUgY29uZmlybWF0aW9uIGRpYWxvZyB3aGlsZSB0aGUgdXNlciBpcyB0cnlpbmcgdG8gY2xvc2UgdGhlXG4gICAqIE1pbmkgQXBwLlxuICAgKi9cbiAgZW5hYmxlQ29uZmlybWF0aW9uKCkge1xuICAgIHRoaXMuaXNDb25maXJtYXRpb25OZWVkZWQgPSAhMDtcbiAgfVxufVxuZnVuY3Rpb24gaXQociwgdCkge1xuICByZXR1cm4gci5yZWR1Y2UoKGUsIHMpID0+IChlW3NdID0gdCwgZSksIHt9KTtcbn1cbmNsYXNzIHhlIHtcbiAgY29uc3RydWN0b3IodCwgZSwgcyA9IGYpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgc3BlY2lmaWVkIG1ldGhvZCBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBjb21wb25lbnQuXG4gICAgICovXG4gICAgbyh0aGlzLCBcInN1cHBvcnRzXCIpO1xuICAgIHRoaXMuY3JlYXRlUmVxdWVzdElkID0gZSwgdGhpcy5wb3N0RXZlbnQgPSBzLCB0aGlzLnN1cHBvcnRzID0gRSh0LCB7XG4gICAgICBkZWxldGU6IFwid2ViX2FwcF9pbnZva2VfY3VzdG9tX21ldGhvZFwiLFxuICAgICAgZ2V0OiBcIndlYl9hcHBfaW52b2tlX2N1c3RvbV9tZXRob2RcIixcbiAgICAgIGdldEtleXM6IFwid2ViX2FwcF9pbnZva2VfY3VzdG9tX21ldGhvZFwiLFxuICAgICAgc2V0OiBcIndlYl9hcHBfaW52b2tlX2N1c3RvbV9tZXRob2RcIlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIHNwZWNpZmllZCBrZXkgb3Iga2V5cyBmcm9tIHRoZSBjbG91ZCBzdG9yYWdlLlxuICAgKiBAcGFyYW0ga2V5T3JLZXlzIC0ga2V5IG9yIGtleXMgdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHJlcXVlc3QgZXhlY3V0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyBkZWxldGUodCwgZSA9IHt9KSB7XG4gICAgY29uc3QgcyA9IEFycmF5LmlzQXJyYXkodCkgPyB0IDogW3RdO1xuICAgIHMubGVuZ3RoICE9PSAwICYmIGF3YWl0IE4oXG4gICAgICBcImRlbGV0ZVN0b3JhZ2VWYWx1ZXNcIixcbiAgICAgIHsga2V5czogcyB9LFxuICAgICAgdGhpcy5jcmVhdGVSZXF1ZXN0SWQoKSxcbiAgICAgIHsgLi4uZSwgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudCB9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBsaXN0IG9mIGFsbCBrZXlzIHByZXNlbnRlZCBpbiB0aGUgY2xvdWQgc3RvcmFnZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSByZXF1ZXN0IGV4ZWN1dGlvbiBvcHRpb25zLlxuICAgKi9cbiAgYXN5bmMgZ2V0S2V5cyh0ID0ge30pIHtcbiAgICBjb25zdCBlID0gYXdhaXQgTihcbiAgICAgIFwiZ2V0U3RvcmFnZUtleXNcIixcbiAgICAgIHt9LFxuICAgICAgdGhpcy5jcmVhdGVSZXF1ZXN0SWQoKSxcbiAgICAgIHsgLi4udCwgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudCB9XG4gICAgKTtcbiAgICByZXR1cm4gTnQoKS5vZihoKCkpLnBhcnNlKGUpO1xuICB9XG4gIGFzeW5jIGdldCh0LCBlID0ge30pIHtcbiAgICBjb25zdCBzID0gQXJyYXkuaXNBcnJheSh0KSA/IHQgOiBbdF07XG4gICAgaWYgKHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIGl0KHMsIFwiXCIpO1xuICAgIGNvbnN0IG4gPSBnKFxuICAgICAgaXQocywgaCgpKVxuICAgICksIGkgPSBhd2FpdCBOKFxuICAgICAgXCJnZXRTdG9yYWdlVmFsdWVzXCIsXG4gICAgICB7IGtleXM6IHMgfSxcbiAgICAgIHRoaXMuY3JlYXRlUmVxdWVzdElkKCksXG4gICAgICB7IC4uLmUsIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQgfVxuICAgICkudGhlbigoYSkgPT4gbi5wYXJzZShhKSk7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyBpIDogaVt0XTtcbiAgfVxuICAvKipcbiAgICogU2F2ZXMgc3BlY2lmaWVkIHZhbHVlIGJ5IGtleS5cbiAgICogQHBhcmFtIGtleSAtIHN0b3JhZ2Uga2V5LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBzdG9yYWdlIHZhbHVlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHJlcXVlc3QgZXhlY3V0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyBzZXQodCwgZSwgcyA9IHt9KSB7XG4gICAgYXdhaXQgTihcbiAgICAgIFwic2F2ZVN0b3JhZ2VWYWx1ZVwiLFxuICAgICAgeyBrZXk6IHQsIHZhbHVlOiBlIH0sXG4gICAgICB0aGlzLmNyZWF0ZVJlcXVlc3RJZCgpLFxuICAgICAgeyAuLi5zLCBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50IH1cbiAgICApO1xuICB9XG59XG5jbGFzcyBxZSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSBmKSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHNwZWNpZmllZCBtZXRob2QgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIG8odGhpcywgXCJzdXBwb3J0c1wiKTtcbiAgICB0aGlzLnBvc3RFdmVudCA9IGUsIHRoaXMuc3VwcG9ydHMgPSBFKHQsIHtcbiAgICAgIGltcGFjdE9jY3VycmVkOiBcIndlYl9hcHBfdHJpZ2dlcl9oYXB0aWNfZmVlZGJhY2tcIixcbiAgICAgIG5vdGlmaWNhdGlvbk9jY3VycmVkOiBcIndlYl9hcHBfdHJpZ2dlcl9oYXB0aWNfZmVlZGJhY2tcIixcbiAgICAgIHNlbGVjdGlvbkNoYW5nZWQ6IFwid2ViX2FwcF90cmlnZ2VyX2hhcHRpY19mZWVkYmFja1wiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRlbGxzIHRoYXQgYW4gaW1wYWN0IG9jY3VycmVkLiBUaGUgVGVsZWdyYW0gYXBwIG1heSBwbGF5IHRoZVxuICAgKiBhcHByb3ByaWF0ZSBoYXB0aWNzIGJhc2VkIG9uIHN0eWxlIHZhbHVlIHBhc3NlZC5cbiAgICogQHBhcmFtIHN0eWxlIC0gaW1wYWN0IHN0eWxlLlxuICAgKi9cbiAgaW1wYWN0T2NjdXJyZWQodCkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF90cmlnZ2VyX2hhcHRpY19mZWVkYmFja1wiLCB7XG4gICAgICB0eXBlOiBcImltcGFjdFwiLFxuICAgICAgaW1wYWN0X3N0eWxlOiB0XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRlbGxzIHRoYXQgYSB0YXNrIG9yIGFjdGlvbiBoYXMgc3VjY2VlZGVkLCBmYWlsZWQsIG9yIHByb2R1Y2VkXG4gICAqIGEgd2FybmluZy4gVGhlIFRlbGVncmFtIGFwcCBtYXkgcGxheSB0aGUgYXBwcm9wcmlhdGUgaGFwdGljcyBiYXNlZCBvblxuICAgKiB0eXBlIHZhbHVlIHBhc3NlZC5cbiAgICogQHBhcmFtIHR5cGUgLSBub3RpZmljYXRpb24gdHlwZS5cbiAgICovXG4gIG5vdGlmaWNhdGlvbk9jY3VycmVkKHQpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfdHJpZ2dlcl9oYXB0aWNfZmVlZGJhY2tcIiwge1xuICAgICAgdHlwZTogXCJub3RpZmljYXRpb25cIixcbiAgICAgIG5vdGlmaWNhdGlvbl90eXBlOiB0XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRlbGxzIHRoYXQgdGhlIHVzZXIgaGFzIGNoYW5nZWQgYSBzZWxlY3Rpb24uIFRoZSBUZWxlZ3JhbSBhcHBcbiAgICogbWF5IHBsYXkgdGhlIGFwcHJvcHJpYXRlIGhhcHRpY3MuXG4gICAqXG4gICAqIERvIG5vdCB1c2UgdGhpcyBmZWVkYmFjayB3aGVuIHRoZSB1c2VyIG1ha2VzIG9yIGNvbmZpcm1zIGEgc2VsZWN0aW9uO1xuICAgKiB1c2UgaXQgb25seSB3aGVuIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy5cbiAgICovXG4gIHNlbGVjdGlvbkNoYW5nZWQoKSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3RyaWdnZXJfaGFwdGljX2ZlZWRiYWNrXCIsIHsgdHlwZTogXCJzZWxlY3Rpb25fY2hhbmdlXCIgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEFlKCkge1xuICBjb25zdCByID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICByLmlkID0gXCJ0ZWxlZ3JhbS1jdXN0b20tc3R5bGVzXCIsIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQociksIHkoXCJzZXRfY3VzdG9tX3N0eWxlXCIsICh0KSA9PiB7XG4gICAgci5pbm5lckhUTUwgPSB0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHF0KHIpIHtcbiAgcmV0dXJuIGB0ZWxlZ3JhbS1taW5pLWFwcHMtJHtyfWA7XG59XG5mdW5jdGlvbiBMKHIsIHQpIHtcbiAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShxdChyKSwgSlNPTi5zdHJpbmdpZnkodCkpO1xufVxuZnVuY3Rpb24gJChyKSB7XG4gIGNvbnN0IHQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHF0KHIpKTtcbiAgcmV0dXJuIHQgPyBKU09OLnBhcnNlKHQpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIFJlKHIsIHQsIGUpIHtcbiAgY29uc3QgeyBpc1Zpc2libGU6IHMgPSAhMSB9ID0gciA/ICQoXCJiYWNrLWJ1dHRvblwiKSB8fCB7fSA6IHt9LCBuID0gbmV3IHZlKHMsIHQsIGUpO1xuICByZXR1cm4gbi5vbihcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgTChcImJhY2stYnV0dG9uXCIsIHsgaXNWaXNpYmxlOiBuLmlzVmlzaWJsZSB9KTtcbiAgfSksIG47XG59XG5mdW5jdGlvbiBWZShyLCB0KSB7XG4gIGNvbnN0IHsgaXNDb25maXJtYXRpb25OZWVkZWQ6IGUgPSAhMSB9ID0gciA/ICQoXCJjbG9zaW5nLWJlaGF2aW9yXCIpIHx8IHt9IDoge30sIHMgPSBuZXcga2UoZSwgdCk7XG4gIHJldHVybiBzLm9uKFwiY2hhbmdlXCIsICgpID0+IEwoXCJjbG9zaW5nLWJlaGF2aW9yXCIsIHtcbiAgICBpc0NvbmZpcm1hdGlvbk5lZWRlZDogcy5pc0NvbmZpcm1hdGlvbk5lZWRlZFxuICB9KSksIHM7XG59XG5jbGFzcyBJZSB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBvKHRoaXMsIFwiZWVcIiwgbmV3IHcoKSk7XG4gICAgbyh0aGlzLCBcInN0YXRlXCIpO1xuICAgIG8odGhpcywgXCJwb3N0RXZlbnRcIik7XG4gICAgLyoqXG4gICAgICogQWRkcyBuZXcgZXZlbnQgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIGV2ZW50IC0gZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBvKHRoaXMsIFwib25cIiwgKHQsIGUpID0+IChcbiAgICAgIC8vIEZJWE1FOiBFdmVudCAnbWFpbl9idXR0b25fcHJlc3NlZCcgaXMgc3RpbGwgYmVpbmcgcmVjZWl2ZWQgb24gQW5kcm9pZFxuICAgICAgLy8gIGV2ZW4gaWYgdGhlIG1haW4gYnV0dG9uIGlzIGRpc2FibGVkLlxuICAgICAgLy8gIElzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vVGVsZWdyYW0tTWluaS1BcHBzL3RtYS5qcy9pc3N1ZXMvM1xuICAgICAgdCA9PT0gXCJjbGlja1wiID8geShcIm1haW5fYnV0dG9uX3ByZXNzZWRcIiwgZSkgOiB0aGlzLmVlLm9uKHQsIGUpXG4gICAgKSk7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIG8odGhpcywgXCJvZmZcIiwgKHQsIGUpID0+IHQgPT09IFwiY2xpY2tcIiA/IEkoXCJtYWluX2J1dHRvbl9wcmVzc2VkXCIsIGUpIDogdGhpcy5lZS5vZmYodCwgZSkpO1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc3RFdmVudDogZSA9IGYsXG4gICAgICB0ZXh0OiBzLFxuICAgICAgdGV4dENvbG9yOiBuLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBpLFxuICAgICAgaXNFbmFibGVkOiBhLFxuICAgICAgaXNWaXNpYmxlOiBjLFxuICAgICAgaXNMb2FkZXJWaXNpYmxlOiB1XG4gICAgfSA9IHQ7XG4gICAgdGhpcy5wb3N0RXZlbnQgPSBlLCB0aGlzLnN0YXRlID0gbmV3IF8oe1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBpLFxuICAgICAgaXNFbmFibGVkOiBhLFxuICAgICAgaXNWaXNpYmxlOiBjLFxuICAgICAgaXNMb2FkZXJWaXNpYmxlOiB1LFxuICAgICAgdGV4dDogcyxcbiAgICAgIHRleHRDb2xvcjogblxuICAgIH0sIHRoaXMuZWUpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBjdXJyZW50IGxvY2FsIHN0YXRlIHRvIFRlbGVncmFtIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgY29tbWl0KCkge1xuICAgIHRoaXMudGV4dCAhPT0gXCJcIiAmJiB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc2V0dXBfbWFpbl9idXR0b25cIiwge1xuICAgICAgaXNfdmlzaWJsZTogdGhpcy5pc1Zpc2libGUsXG4gICAgICBpc19hY3RpdmU6IHRoaXMuaXNFbmFibGVkLFxuICAgICAgaXNfcHJvZ3Jlc3NfdmlzaWJsZTogdGhpcy5pc0xvYWRlclZpc2libGUsXG4gICAgICB0ZXh0OiB0aGlzLnRleHQsXG4gICAgICBjb2xvcjogdGhpcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICB0ZXh0X2NvbG9yOiB0aGlzLnRleHRDb2xvclxuICAgIH0pO1xuICB9XG4gIHNldCBpc0VuYWJsZWQodCkge1xuICAgIHRoaXMuc2V0UGFyYW1zKHsgaXNFbmFibGVkOiB0IH0pO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBNYWluIEJ1dHRvbiBpcyBjdXJyZW50bHkgZW5hYmxlZC5cbiAgICovXG4gIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZ2V0KFwiaXNFbmFibGVkXCIpO1xuICB9XG4gIHNldCBpc0xvYWRlclZpc2libGUodCkge1xuICAgIHRoaXMuc2V0UGFyYW1zKHsgaXNMb2FkZXJWaXNpYmxlOiB0IH0pO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBNYWluIEJ1dHRvbiBsb2FkZXIgaXMgY3VycmVudGx5IHZpc2libGUuXG4gICAqL1xuICBnZXQgaXNMb2FkZXJWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmdldChcImlzTG9hZGVyVmlzaWJsZVwiKTtcbiAgfVxuICBzZXQgaXNWaXNpYmxlKHQpIHtcbiAgICB0aGlzLnNldFBhcmFtcyh7IGlzVmlzaWJsZTogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgTWFpbiBCdXR0b24gaXMgY3VycmVudGx5IHZpc2libGUuXG4gICAqL1xuICBnZXQgaXNWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmdldChcImlzVmlzaWJsZVwiKTtcbiAgfVxuICAvKipcbiAgICogVGhlIE1haW4gQnV0dG9uIGJhY2tncm91bmQgY29sb3IuXG4gICAqL1xuICBnZXQgYmFja2dyb3VuZENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmdldChcImJhY2tncm91bmRDb2xvclwiKTtcbiAgfVxuICAvKipcbiAgICogVGhlIE1haW4gQnV0dG9uIHRleHQuXG4gICAqL1xuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5nZXQoXCJ0ZXh0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgTWFpbiBCdXR0b24gdGV4dCBjb2xvci5cbiAgICovXG4gIGdldCB0ZXh0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZ2V0KFwidGV4dENvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgTWFpbiBCdXR0b24uXG4gICAqL1xuICBkaXNhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZCA9ICExLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBNYWluIEJ1dHRvbi5cbiAgICovXG4gIGVuYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VuYWJsZWQgPSAhMCwgdGhpcztcbiAgfVxuICAvKipcbiAgICogSGlkZXMgdGhlIE1haW4gQnV0dG9uLlxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1Zpc2libGUgPSAhMSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogSGlkZXMgdGhlIE1haW4gQnV0dG9uIGxvYWRlci5cbiAgICovXG4gIGhpZGVMb2FkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMb2FkZXJWaXNpYmxlID0gITEsIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBNYWluIEJ1dHRvbi4gTm90ZSB0aGF0IG9wZW5pbmcgdGhlIE1pbmkgQXBwIGZyb20gdGhlIGF0dGFjaG1lbnQgbWVudSBoaWRlcyB0aGVcbiAgICogbWFpbiBidXR0b24gdW50aWwgdGhlIHVzZXIgaW50ZXJhY3RzIHdpdGggdGhlIE1pbmkgQXBwIGludGVyZmFjZS5cbiAgICovXG4gIHNob3coKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWaXNpYmxlID0gITAsIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRvIHNob3cgYSBsb2FkaW5nIGluZGljYXRvciBvbiB0aGUgTWFpbiBCdXR0b24uIEl0IGlzIHJlY29tbWVuZGVkIHRvIGRpc3BsYXlcbiAgICogbG9hZGVyIGlmIHRoZSBhY3Rpb24gdGllZCB0byB0aGUgYnV0dG9uIG1heSB0YWtlIGEgbG9uZyB0aW1lLlxuICAgKi9cbiAgc2hvd0xvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xvYWRlclZpc2libGUgPSAhMCwgdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyBuZXcgTWFpbiBCdXR0b24gdGV4dC4gTWluaW1hbCBsZW5ndGggZm9yIHRleHQgaXMgMSBzeW1ib2wsIGFuZCBtYXhpbXVtIGlzIDY0IHN5bWJvbHMuXG4gICAqIEBwYXJhbSB0ZXh0IC0gbmV3IHRleHQuXG4gICAqL1xuICBzZXRUZXh0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRQYXJhbXMoeyB0ZXh0OiB0IH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIG5ldyBNYWluIEJ1dHRvbiB0ZXh0IGNvbG9yLlxuICAgKiBAcGFyYW0gdGV4dENvbG9yIC0gbmV3IHRleHQgY29sb3IuXG4gICAqL1xuICBzZXRUZXh0Q29sb3IodCkge1xuICAgIHJldHVybiB0aGlzLnNldFBhcmFtcyh7IHRleHRDb2xvcjogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBjdXJyZW50IE1haW4gQnV0dG9uIGNvbG9yLlxuICAgKiBAcGFyYW0gYmFja2dyb3VuZENvbG9yIC0gY29sb3IgdG8gc2V0LlxuICAgKi9cbiAgc2V0QmFja2dyb3VuZENvbG9yKHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRQYXJhbXMoeyBiYWNrZ3JvdW5kQ29sb3I6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93cyBzZXR0aW5nIG11bHRpcGxlIE1haW4gQnV0dG9uIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBNYWluIEJ1dHRvbiBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgc2V0UGFyYW1zKHQpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZXQodCksIHRoaXMuY29tbWl0KCksIHRoaXM7XG4gIH1cbn1cbmZ1bmN0aW9uIExlKHIsIHQsIGUsIHMpIHtcbiAgY29uc3Qge1xuICAgIGJhY2tncm91bmRDb2xvcjogbiA9IHQsXG4gICAgaXNFbmFibGVkOiBpID0gITEsXG4gICAgaXNWaXNpYmxlOiBhID0gITEsXG4gICAgaXNMb2FkZXJWaXNpYmxlOiBjID0gITEsXG4gICAgdGV4dENvbG9yOiB1ID0gZSxcbiAgICB0ZXh0OiBwID0gXCJcIlxuICB9ID0gciA/ICQoXCJtYWluLWJ1dHRvblwiKSB8fCB7fSA6IHt9LCBsID0gbmV3IEllKHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG4sXG4gICAgaXNFbmFibGVkOiBpLFxuICAgIGlzTG9hZGVyVmlzaWJsZTogYyxcbiAgICBpc1Zpc2libGU6IGEsXG4gICAgcG9zdEV2ZW50OiBzLFxuICAgIHRleHQ6IHAsXG4gICAgdGV4dENvbG9yOiB1XG4gIH0pLCBiID0gKCkgPT4gTChcIm1haW4tYnV0dG9uXCIsIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGwuYmFja2dyb3VuZENvbG9yLFxuICAgIGlzRW5hYmxlZDogbC5pc0VuYWJsZWQsXG4gICAgaXNMb2FkZXJWaXNpYmxlOiBsLmlzTG9hZGVyVmlzaWJsZSxcbiAgICBpc1Zpc2libGU6IGwuaXNWaXNpYmxlLFxuICAgIHRleHQ6IGwudGV4dCxcbiAgICB0ZXh0Q29sb3I6IGwudGV4dENvbG9yXG4gIH0pO1xuICByZXR1cm4gbC5vbihcImNoYW5nZVwiLCBiKSwgbDtcbn1cbmNvbnN0ICRlID0gWCh7XG4gIGNvbnRhY3Q6IGcoe1xuICAgIHVzZXJJZDoge1xuICAgICAgdHlwZTogaygpLFxuICAgICAgZnJvbTogXCJ1c2VyX2lkXCJcbiAgICB9LFxuICAgIHBob25lTnVtYmVyOiB7XG4gICAgICB0eXBlOiBoKCksXG4gICAgICBmcm9tOiBcInBob25lX251bWJlclwiXG4gICAgfSxcbiAgICBmaXJzdE5hbWU6IHtcbiAgICAgIHR5cGU6IGgoKSxcbiAgICAgIGZyb206IFwiZmlyc3RfbmFtZVwiXG4gICAgfSxcbiAgICBsYXN0TmFtZToge1xuICAgICAgdHlwZTogaCgpLFxuICAgICAgZnJvbTogXCJsYXN0X25hbWVcIlxuICAgIH1cbiAgfSksXG4gIGF1dGhEYXRlOiB7XG4gICAgdHlwZTogcHQoKSxcbiAgICBmcm9tOiBcImF1dGhfZGF0ZVwiXG4gIH0sXG4gIGhhc2g6IGgoKVxufSk7XG5jbGFzcyBUZSB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBvKHRoaXMsIFwiZWVcIiwgbmV3IHcoKSk7XG4gICAgbyh0aGlzLCBcInN0YXRlXCIpO1xuICAgIG8odGhpcywgXCJib3RJbmxpbmVcIik7XG4gICAgbyh0aGlzLCBcInBvc3RFdmVudFwiKTtcbiAgICBvKHRoaXMsIFwiY3JlYXRlUmVxdWVzdElkXCIpO1xuICAgIG8odGhpcywgXCJyZXF1ZXN0aW5nUGhvbmVBY2Nlc3NcIiwgITEpO1xuICAgIG8odGhpcywgXCJyZXF1ZXN0aW5nV3JpdGVBY2Nlc3NcIiwgITEpO1xuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIG8odGhpcywgXCJvblwiLCB0aGlzLmVlLm9uLmJpbmQodGhpcy5lZSkpO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgbyh0aGlzLCBcIm9mZlwiLCB0aGlzLmVlLm9mZi5iaW5kKHRoaXMuZWUpKTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgc3BlY2lmaWVkIG1ldGhvZCBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBjb21wb25lbnQuXG4gICAgICovXG4gICAgbyh0aGlzLCBcInN1cHBvcnRzXCIpO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBzcGVjaWZpZWQgbWV0aG9kIHBhcmFtZXRlciBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBjb21wb25lbnQuXG4gICAgICovXG4gICAgbyh0aGlzLCBcInN1cHBvcnRzUGFyYW1cIik7XG4gICAgY29uc3Qge1xuICAgICAgcG9zdEV2ZW50OiBlID0gZixcbiAgICAgIGhlYWRlckNvbG9yOiBzLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBuLFxuICAgICAgdmVyc2lvbjogaSxcbiAgICAgIGJvdElubGluZTogYSxcbiAgICAgIGNyZWF0ZVJlcXVlc3RJZDogY1xuICAgIH0gPSB0LCB1ID0gRShpLCB7XG4gICAgICByZXF1ZXN0UGhvbmVBY2Nlc3M6IFwid2ViX2FwcF9yZXF1ZXN0X3Bob25lXCIsXG4gICAgICByZXF1ZXN0V3JpdGVBY2Nlc3M6IFwid2ViX2FwcF9yZXF1ZXN0X3dyaXRlX2FjY2Vzc1wiLFxuICAgICAgc3dpdGNoSW5saW5lUXVlcnk6IFwid2ViX2FwcF9zd2l0Y2hfaW5saW5lX3F1ZXJ5XCIsXG4gICAgICBzZXRIZWFkZXJDb2xvcjogXCJ3ZWJfYXBwX3NldF9oZWFkZXJfY29sb3JcIixcbiAgICAgIHNldEJhY2tncm91bmRDb2xvcjogXCJ3ZWJfYXBwX3NldF9iYWNrZ3JvdW5kX2NvbG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLnBvc3RFdmVudCA9IGUsIHRoaXMuYm90SW5saW5lID0gYSwgdGhpcy5jcmVhdGVSZXF1ZXN0SWQgPSBjLCB0aGlzLnN1cHBvcnRzID0gKHApID0+ICEoIXUocCkgfHwgcCA9PT0gXCJzd2l0Y2hJbmxpbmVRdWVyeVwiICYmICFhKSwgdGhpcy5zdGF0ZSA9IG5ldyBfKHsgYmFja2dyb3VuZENvbG9yOiBuLCBoZWFkZXJDb2xvcjogcyB9LCB0aGlzLmVlKSwgdGhpcy5zdXBwb3J0c1BhcmFtID0ga3QoaSwge1xuICAgICAgXCJzZXRIZWFkZXJDb2xvci5jb2xvclwiOiBbXCJ3ZWJfYXBwX3NldF9oZWFkZXJfY29sb3JcIiwgXCJjb2xvclwiXVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBnZXQgcmVxdWVzdGVkIGNvbnRhY3QuXG4gICAqL1xuICBhc3luYyBnZXRSZXF1ZXN0ZWRDb250YWN0KCkge1xuICAgIHJldHVybiBOKFxuICAgICAgXCJnZXRSZXF1ZXN0ZWRDb250YWN0XCIsXG4gICAgICB7fSxcbiAgICAgIHRoaXMuY3JlYXRlUmVxdWVzdElkKCksXG4gICAgICB7XG4gICAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICAgIHRpbWVvdXQ6IDFlNFxuICAgICAgfVxuICAgICkudGhlbigodCkgPT4gJGUucGFyc2UodCkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgTWluaSBBcHAgYmFja2dyb3VuZCBjb2xvci5cbiAgICovXG4gIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZ2V0KFwiYmFja2dyb3VuZENvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIE1pbmkgQXBwLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX2Nsb3NlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgTWluaSBBcHAgaGVhZGVyIGNvbG9yLiBDb3VsZCBlaXRoZXIgYmUgYSBoZWFkZXIgY29sb3Iga2V5IG9yIFJHQiBjb2xvci5cbiAgICovXG4gIGdldCBoZWFkZXJDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5nZXQoXCJoZWFkZXJDb2xvclwiKTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBNaW5pIEFwcCBpcyBjdXJyZW50bHkgbGF1bmNoZWQgaW4gYm90IGlubGluZSBtb2RlLlxuICAgKi9cbiAgZ2V0IGlzQm90SW5saW5lKCkge1xuICAgIHJldHVybiB0aGlzLmJvdElubGluZTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBjdXJyZW50IE1pbmkgQXBwIGJhY2tncm91bmQgY29sb3IgcmVjb2duaXplZCBhcyBkYXJrLlxuICAgKi9cbiAgZ2V0IGlzRGFyaygpIHtcbiAgICByZXR1cm4gZnQodGhpcy5iYWNrZ3JvdW5kQ29sb3IpO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIHBob25lIGFjY2VzcyBpcyBjdXJyZW50bHkgYmVpbmcgcmVxdWVzdGVkLlxuICAgKi9cbiAgZ2V0IGlzUmVxdWVzdGluZ1Bob25lQWNjZXNzKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RpbmdQaG9uZUFjY2VzcztcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiB3cml0ZSBhY2Nlc3MgaXMgY3VycmVudGx5IGJlaW5nIHJlcXVlc3RlZC5cbiAgICovXG4gIGdldCBpc1JlcXVlc3RpbmdXcml0ZUFjY2VzcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0aW5nV3JpdGVBY2Nlc3M7XG4gIH1cbiAgLyoqXG4gICAqIEluZm9ybXMgdGhlIFRlbGVncmFtIGFwcCB0aGF0IHRoZSBNaW5pIEFwcCBpcyByZWFkeSB0byBiZSBkaXNwbGF5ZWQuXG4gICAqXG4gICAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIGNhbGwgdGhpcyBtZXRob2QgYXMgZWFybHkgYXMgcG9zc2libGUsIGFzIHNvb24gYXMgYWxsIGVzc2VudGlhbFxuICAgKiBpbnRlcmZhY2UgZWxlbWVudHMgbG9hZGVkLiBPbmNlIHRoaXMgbWV0aG9kIGNhbGxlZCwgdGhlIGxvYWRpbmcgcGxhY2Vob2xkZXIgaXMgaGlkZGVuXG4gICAqIGFuZCB0aGUgTWluaSBBcHAgc2hvd24uXG4gICAqXG4gICAqIElmIHRoZSBtZXRob2Qgbm90IGNhbGxlZCwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYmUgaGlkZGVuIG9ubHkgd2hlbiB0aGUgcGFnZSBmdWxseSBsb2FkZWQuXG4gICAqL1xuICByZWFkeSgpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfcmVhZHlcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGN1cnJlbnQgdXNlciBjb250YWN0IGluZm9ybWF0aW9uLiBJbiBjb250cmFyeSB0byByZXF1ZXN0UGhvbmVBY2Nlc3MsIHRoaXMgbWV0aG9kXG4gICAqIHJldHVybnMgcHJvbWlzZSB3aXRoIGNvbnRhY3QgaW5mb3JtYXRpb24gdGhhdCByZWplY3RzIGluIGNhc2UsIHVzZXIgZGVuaWVkIGFjY2Vzcywgb3IgcmVxdWVzdFxuICAgKiBmYWlsZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gYWRkaXRpb25hbCBvcHRpb25zLlxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdENvbnRhY3QoeyB0aW1lb3V0OiB0ID0gNWUzIH0gPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0ZWRDb250YWN0KCk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIGlmIChhd2FpdCB0aGlzLnJlcXVlc3RQaG9uZUFjY2VzcygpICE9PSBcInNlbnRcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY2VzcyBkZW5pZWQuXCIpO1xuICAgIGNvbnN0IHMgPSBEYXRlLm5vdygpICsgdDtcbiAgICBsZXQgbiA9IDUwO1xuICAgIHJldHVybiB4dChhc3luYyAoKSA9PiB7XG4gICAgICBmb3IgKDsgRGF0ZS5ub3coKSA8IHM7ICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFJlcXVlc3RlZENvbnRhY3QoKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgRWUobiksIG4gKz0gNTA7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmV0cmlldmUgcmVxdWVzdGVkIGNvbnRhY3QuXCIpO1xuICAgIH0sIHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBjdXJyZW50IHVzZXIgcGhvbmUgYWNjZXNzLiBNZXRob2QgcmV0dXJucyBwcm9taXNlLCB3aGljaCByZXNvbHZlc1xuICAgKiBzdGF0dXMgb2YgdGhlIHJlcXVlc3QuIEluIGNhc2UsIHVzZXIgYWNjZXB0ZWQgdGhlIHJlcXVlc3QsIE1pbmkgQXBwIGJvdCB3aWxsIHJlY2VpdmVcbiAgICogdGhlIGFjY29yZGluZyBub3RpZmljYXRpb24uXG4gICAqXG4gICAqIFRvIG9idGFpbiB0aGUgcmV0cmlldmVkIGluZm9ybWF0aW9uIGluc3RlYWQsIHV0aWxpemUgdGhlIHJlcXVlc3RDb250YWN0IG1ldGhvZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBhZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqIEBzZWUgcmVxdWVzdENvbnRhY3RcbiAgICovXG4gIHJlcXVlc3RQaG9uZUFjY2Vzcyh0ID0ge30pIHtcbiAgICBpZiAodGhpcy5yZXF1ZXN0aW5nUGhvbmVBY2Nlc3MpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQaG9uZSBhY2Nlc3MgaXMgYWxyZWFkeSBiZWluZyByZXF1ZXN0ZWQuXCIpO1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RpbmdQaG9uZUFjY2VzcyA9ICEwLCBtKFwid2ViX2FwcF9yZXF1ZXN0X3Bob25lXCIsIFwicGhvbmVfcmVxdWVzdGVkXCIsIHtcbiAgICAgIC4uLnQsXG4gICAgICBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50XG4gICAgfSkudGhlbigoZSkgPT4gZS5zdGF0dXMpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5yZXF1ZXN0aW5nUGhvbmVBY2Nlc3MgPSAhMTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgd3JpdGUgbWVzc2FnZSBhY2Nlc3MgdG8gY3VycmVudCB1c2VyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICovXG4gIHJlcXVlc3RXcml0ZUFjY2Vzcyh0ID0ge30pIHtcbiAgICBpZiAodGhpcy5yZXF1ZXN0aW5nV3JpdGVBY2Nlc3MpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcml0ZSBhY2Nlc3MgaXMgYWxyZWFkeSBiZWluZyByZXF1ZXN0ZWQuXCIpO1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RpbmdXcml0ZUFjY2VzcyA9ICEwLCBtKFwid2ViX2FwcF9yZXF1ZXN0X3dyaXRlX2FjY2Vzc1wiLCBcIndyaXRlX2FjY2Vzc19yZXF1ZXN0ZWRcIiwge1xuICAgICAgLi4udCxcbiAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnRcbiAgICB9KS50aGVuKChlKSA9PiBlLnN0YXR1cykuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLnJlcXVlc3RpbmdXcml0ZUFjY2VzcyA9ICExO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBIG1ldGhvZCB1c2VkIHRvIHNlbmQgZGF0YSB0byB0aGUgYm90LiBXaGVuIHRoaXMgbWV0aG9kIGNhbGxlZCwgYSBzZXJ2aWNlIG1lc3NhZ2Ugc2VudCB0b1xuICAgKiB0aGUgYm90IGNvbnRhaW5pbmcgdGhlIGRhdGEgb2YgdGhlIGxlbmd0aCB1cCB0byA0MDk2IGJ5dGVzLCBhbmQgdGhlIE1pbmkgQXBwIGNsb3NlZC4gU2VlIHRoZVxuICAgKiBmaWVsZCBgd2ViX2FwcF9kYXRhYCBpbiB0aGUgY2xhc3MgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBNaW5pIEFwcHMgbGF1bmNoZWQgdmlhIGEgS2V5Ym9hcmQgYnV0dG9uLlxuICAgKiBAcGFyYW0gZGF0YSAtIGRhdGEgdG8gc2VuZCB0byBib3QuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBkYXRhIGhhcyBpbmNvcnJlY3Qgc2l6ZS5cbiAgICovXG4gIHNlbmREYXRhKHQpIHtcbiAgICBjb25zdCB7IHNpemU6IGUgfSA9IG5ldyBCbG9iKFt0XSk7XG4gICAgaWYgKGUgPT09IDAgfHwgZSA+IDQwOTYpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhc3NlZCBkYXRhIGhhcyBpbmNvcnJlY3Qgc2l6ZTogJHtlfWApO1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9kYXRhX3NlbmRcIiwgeyBkYXRhOiB0IH0pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGN1cnJlbnQgTWluaSBBcHAgaGVhZGVyIGNvbG9yLlxuICAgKiBAcGFyYW0gY29sb3IgLSBjb2xvciBrZXkgb3IgUkdCIGNvbG9yLlxuICAgKi9cbiAgc2V0SGVhZGVyQ29sb3IodCkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9zZXRfaGVhZGVyX2NvbG9yXCIsIGx0KHQpID8geyBjb2xvcjogdCB9IDogeyBjb2xvcl9rZXk6IHQgfSksIHRoaXMuc3RhdGUuc2V0KFwiaGVhZGVyQ29sb3JcIiwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgY3VycmVudCBNaW5pIEFwcCBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgKiBAcGFyYW0gY29sb3IgLSBSR0IgY29sb3IuXG4gICAqL1xuICBzZXRCYWNrZ3JvdW5kQ29sb3IodCkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9zZXRfYmFja2dyb3VuZF9jb2xvclwiLCB7IGNvbG9yOiB0IH0pLCB0aGlzLnN0YXRlLnNldChcImJhY2tncm91bmRDb2xvclwiLCB0KTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyB0aGUgYm90J3MgdXNlcm5hbWUgYW5kIHRoZSBzcGVjaWZpZWQgaW5saW5lIHF1ZXJ5IGluIHRoZSBjdXJyZW50IGNoYXQncyBpbnB1dCBmaWVsZC5cbiAgICogUXVlcnkgbWF5IGJlIGVtcHR5LCBpbiB3aGljaCBjYXNlIG9ubHkgdGhlIGJvdCdzIHVzZXJuYW1lIHdpbGwgYmUgaW5zZXJ0ZWQuIFRoZSBjbGllbnQgcHJvbXB0c1xuICAgKiB0aGUgdXNlciB0byBjaG9vc2UgYSBzcGVjaWZpYyBjaGF0LCB0aGVuIG9wZW5zIHRoYXQgY2hhdCBhbmQgaW5zZXJ0cyB0aGUgYm90J3MgdXNlcm5hbWUgYW5kXG4gICAqIHRoZSBzcGVjaWZpZWQgaW5saW5lIHF1ZXJ5IGluIHRoZSBpbnB1dCBmaWVsZC5cbiAgICogQHBhcmFtIHRleHQgLSB0ZXh0IHdoaWNoIHNob3VsZCBiZSBpbnNlcnRlZCBpbiB0aGUgaW5wdXQgYWZ0ZXIgdGhlIGN1cnJlbnQgYm90IG5hbWUuIE1heFxuICAgKiBsZW5ndGggaXMgMjU2IHN5bWJvbHMuXG4gICAqIEBwYXJhbSBjaGF0VHlwZXMgLSBMaXN0IG9mIGNoYXQgdHlwZXMgd2hpY2ggY291bGQgYmUgY2hvc2VuIHRvIHNlbmQgdGhlIG1lc3NhZ2UuIENvdWxkIGJlXG4gICAqIGVtcHR5IGxpc3QuXG4gICAqL1xuICBzd2l0Y2hJbmxpbmVRdWVyeSh0LCBlID0gW10pIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMoXCJzd2l0Y2hJbmxpbmVRdWVyeVwiKSAmJiAhdGhpcy5pc0JvdElubGluZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBpcyB1bnN1cHBvcnRlZCBiZWNhdXNlIE1pbmkgQXBwIHNob3VsZCBiZSBsYXVuY2hlZCBpbiBpbmxpbmUgbW9kZS5cIik7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3N3aXRjaF9pbmxpbmVfcXVlcnlcIiwge1xuICAgICAgcXVlcnk6IHQsXG4gICAgICBjaGF0X3R5cGVzOiBlXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEJlKHIsIHQsIGUsIHMsIG4sIGkpIHtcbiAgY29uc3Qge1xuICAgIGJhY2tncm91bmRDb2xvcjogYSA9IHQsXG4gICAgaGVhZGVyQ29sb3I6IGMgPSBcImJnX2NvbG9yXCJcbiAgfSA9IHIgPyAkKFwibWluaS1hcHBcIikgfHwge30gOiB7fSwgdSA9IG5ldyBUZSh7XG4gICAgaGVhZGVyQ29sb3I6IGMsXG4gICAgYmFja2dyb3VuZENvbG9yOiBhLFxuICAgIHZlcnNpb246IGUsXG4gICAgYm90SW5saW5lOiBzLFxuICAgIGNyZWF0ZVJlcXVlc3RJZDogbixcbiAgICBwb3N0RXZlbnQ6IGlcbiAgfSksIHAgPSAoKSA9PiBMKFwibWluaS1hcHBcIiwge1xuICAgIGJhY2tncm91bmRDb2xvcjogdS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgaGVhZGVyQ29sb3I6IHUuaGVhZGVyQ29sb3JcbiAgfSk7XG4gIHJldHVybiB1Lm9uKFwiY2hhbmdlXCIsIHApLCB1O1xufVxuZnVuY3Rpb24gRGUoKSB7XG4gIGxldCByID0gMDtcbiAgcmV0dXJuICgpID0+IChyICs9IDEsIHIudG9TdHJpbmcoKSk7XG59XG5jbGFzcyBXZSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIHMgPSBmKSB7XG4gICAgbyh0aGlzLCBcImVlXCIsIG5ldyB3KCkpO1xuICAgIG8odGhpcywgXCJzdGF0ZVwiKTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgbyh0aGlzLCBcIm9uXCIsICh0LCBlKSA9PiB0ID09PSBcImNsaWNrXCIgPyB5KFwic2V0dGluZ3NfYnV0dG9uX3ByZXNzZWRcIiwgZSkgOiB0aGlzLmVlLm9uKHQsIGUpKTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgbyh0aGlzLCBcIm9mZlwiLCAodCwgZSkgPT4gdCA9PT0gXCJjbGlja1wiID8gSShcInNldHRpbmdzX2J1dHRvbl9wcmVzc2VkXCIsIGUpIDogdGhpcy5lZS5vZmYodCwgZSkpO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBzcGVjaWZpZWQgbWV0aG9kIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBvKHRoaXMsIFwic3VwcG9ydHNcIik7XG4gICAgdGhpcy5wb3N0RXZlbnQgPSBzLCB0aGlzLnN0YXRlID0gbmV3IF8oeyBpc1Zpc2libGU6IHQgfSwgdGhpcy5lZSksIHRoaXMuc3VwcG9ydHMgPSBFKGUsIHtcbiAgICAgIHNob3c6IFwid2ViX2FwcF9zZXR1cF9zZXR0aW5nc19idXR0b25cIixcbiAgICAgIGhpZGU6IFwid2ViX2FwcF9zZXR1cF9zZXR0aW5nc19idXR0b25cIlxuICAgIH0pO1xuICB9XG4gIHNldCBpc1Zpc2libGUodCkge1xuICAgIHRoaXMuc3RhdGUuc2V0KFwiaXNWaXNpYmxlXCIsIHQpLCB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc2V0dXBfc2V0dGluZ3NfYnV0dG9uXCIsIHsgaXNfdmlzaWJsZTogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBTZXR0aW5nc0J1dHRvbiBpcyBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICovXG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZ2V0KFwiaXNWaXNpYmxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgU2V0dGluZ3NCdXR0b24uXG4gICAqL1xuICBoaWRlKCkge1xuICAgIHRoaXMuaXNWaXNpYmxlID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBTZXR0aW5nc0J1dHRvbi5cbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy5pc1Zpc2libGUgPSAhMDtcbiAgfVxufVxuZnVuY3Rpb24gTmUociwgdCwgZSkge1xuICBjb25zdCB7IGlzVmlzaWJsZTogcyA9ICExIH0gPSByID8gJChcInNldHRpbmdzLWJ1dHRvblwiKSB8fCB7fSA6IHt9LCBuID0gbmV3IFdlKHMsIHQsIGUpO1xuICByZXR1cm4gbi5vbihcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgTChcInNldHRpbmdzLWJ1dHRvblwiLCB7IGlzVmlzaWJsZTogbi5pc1Zpc2libGUgfSk7XG4gIH0pLCBuO1xufVxuZnVuY3Rpb24gT2Uocikge1xuICBjb25zdCB0ID0gbmV3IEZ0KHIpO1xuICByZXR1cm4gdC5saXN0ZW4oKSwgdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIEF0KHIpIHtcbiAgY29uc3QgdCA9IGF3YWl0IG0oXCJ3ZWJfYXBwX3JlcXVlc3Rfdmlld3BvcnRcIiwgXCJ2aWV3cG9ydF9jaGFuZ2VkXCIsIHIpO1xuICByZXR1cm4ge1xuICAgIGhlaWdodDogdC5oZWlnaHQsXG4gICAgd2lkdGg6IHQud2lkdGgsXG4gICAgaXNFeHBhbmRlZDogdC5pc19leHBhbmRlZCxcbiAgICBpc1N0YXRlU3RhYmxlOiB0LmlzX3N0YXRlX3N0YWJsZVxuICB9O1xufVxuZnVuY3Rpb24gRChyKSB7XG4gIHJldHVybiByIDwgMCA/IDAgOiByO1xufVxuY2xhc3MgRyB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBvKHRoaXMsIFwiZWVcIiwgbmV3IHcoKSk7XG4gICAgbyh0aGlzLCBcInN0YXRlXCIpO1xuICAgIG8odGhpcywgXCJwb3N0RXZlbnRcIik7XG4gICAgLyoqXG4gICAgICogQWRkcyBuZXcgZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgbyh0aGlzLCBcIm9uXCIsIHRoaXMuZWUub24uYmluZCh0aGlzLmVlKSk7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBvKHRoaXMsIFwib2ZmXCIsIHRoaXMuZWUub2ZmLmJpbmQodGhpcy5lZSkpO1xuICAgIGNvbnN0IHtcbiAgICAgIGhlaWdodDogZSxcbiAgICAgIGlzRXhwYW5kZWQ6IHMsXG4gICAgICB3aWR0aDogbixcbiAgICAgIHN0YWJsZUhlaWdodDogaSxcbiAgICAgIHBvc3RFdmVudDogYSA9IGZcbiAgICB9ID0gdDtcbiAgICB0aGlzLnBvc3RFdmVudCA9IGEsIHRoaXMuc3RhdGUgPSBuZXcgXyh7XG4gICAgICBoZWlnaHQ6IEQoZSksXG4gICAgICBpc0V4cGFuZGVkOiBzLFxuICAgICAgc3RhYmxlSGVpZ2h0OiBEKGkpLFxuICAgICAgd2lkdGg6IEQobilcbiAgICB9LCB0aGlzLmVlKTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdCB2aWV3cG9ydCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBUZWxlZ3JhbSBhcHBsaWNhdGlvbiBhbmQgdXBkYXRlcyBjdXJyZW50IFZpZXdwb3J0XG4gICAqIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIG9wdGlvbnMgdG8gcmVxdWVzdCBmcmVzaCBkYXRhLlxuICAgKi9cbiAgc3luYyh0KSB7XG4gICAgcmV0dXJuIEF0KHQpLnRoZW4oKHsgaGVpZ2h0OiBlLCBpc0V4cGFuZGVkOiBzLCB3aWR0aDogbiwgaXNTdGF0ZVN0YWJsZTogaSB9KSA9PiB7XG4gICAgICB0aGlzLnN0YXRlLnNldCh7XG4gICAgICAgIGhlaWdodDogZSxcbiAgICAgICAgd2lkdGg6IG4sXG4gICAgICAgIGlzRXhwYW5kZWQ6IHMsXG4gICAgICAgIHN0YWJsZUhlaWdodDogaSA/IGUgOiB0aGlzLnN0YXRlLmdldChcInN0YWJsZUhlaWdodFwiKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgdmlzaWJsZSBhcmVhIG9mIHRoZSBNaW5pIEFwcC5cbiAgICpcbiAgICogVGhlIGFwcGxpY2F0aW9uIGNhbiBkaXNwbGF5IGp1c3QgdGhlIHRvcCBwYXJ0IG9mIHRoZSBNaW5pIEFwcCwgd2l0aCBpdHNcbiAgICogbG93ZXIgcGFydCByZW1haW5pbmcgb3V0c2lkZSB0aGUgc2NyZWVuIGFyZWEuIEZyb20gdGhpcyBwb3NpdGlvbiwgdGhlXG4gICAqIHVzZXIgY2FuIFwicHVsbFwiIHRoZSBNaW5pIEFwcCB0byBpdHMgbWF4aW11bSBoZWlnaHQsIHdoaWxlIHRoZSBib3QgY2FuIGRvXG4gICAqIHRoZSBzYW1lIGJ5IGNhbGxpbmcgYGV4cGFuZGAgbWV0aG9kLiBBcyB0aGUgcG9zaXRpb24gb2YgdGhlIE1pbmkgQXBwXG4gICAqIGNoYW5nZXMsIHRoZSBjdXJyZW50IGhlaWdodCB2YWx1ZSBvZiB0aGUgdmlzaWJsZSBhcmVhIHdpbGwgYmUgdXBkYXRlZFxuICAgKiBpbiByZWFsIHRpbWUuXG4gICAqXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIHJlZnJlc2ggcmF0ZSBvZiB0aGlzIHZhbHVlIGlzIG5vdCBzdWZmaWNpZW50XG4gICAqIHRvIHNtb290aGx5IGZvbGxvdyB0aGUgbG93ZXIgYm9yZGVyIG9mIHRoZSB3aW5kb3cuIEl0IHNob3VsZCBub3QgYmVcbiAgICogdXNlZCB0byBwaW4gaW50ZXJmYWNlIGVsZW1lbnRzIHRvIHRoZSBib3R0b20gb2YgdGhlIHZpc2libGUgYXJlYS4gSXQnc1xuICAgKiBtb3JlIGFwcHJvcHJpYXRlIHRvIHVzZSB0aGUgdmFsdWUgb2YgdGhlIGBzdGFibGVIZWlnaHRgXG4gICAqIGZpZWxkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmdldChcImhlaWdodFwiKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGhlaWdodCBvZiB0aGUgdmlzaWJsZSBhcmVhIG9mIHRoZSBNaW5pIEFwcCBpbiBpdHMgbGFzdCBzdGFibGUgc3RhdGUuXG4gICAqXG4gICAqIFRoZSBhcHBsaWNhdGlvbiBjYW4gZGlzcGxheSBqdXN0IHRoZSB0b3AgcGFydCBvZiB0aGUgTWluaSBBcHAsIHdpdGggaXRzXG4gICAqIGxvd2VyIHBhcnQgcmVtYWluaW5nIG91dHNpZGUgdGhlIHNjcmVlbiBhcmVhLiBGcm9tIHRoaXMgcG9zaXRpb24sXG4gICAqIHRoZSB1c2VyIGNhbiBcInB1bGxcIiB0aGUgTWluaSBBcHAgdG8gaXRzIG1heGltdW0gaGVpZ2h0LCB3aGlsZSB0aGUgYm90IGNhblxuICAgKiBkbyB0aGUgc2FtZSBieSBjYWxsaW5nIGBleHBhbmRgIG1ldGhvZC5cbiAgICpcbiAgICogVW5saWtlIHRoZSB2YWx1ZSBvZiBgaGVpZ2h0YCwgdGhlIHZhbHVlIG9mIGBzdGFibGVIZWlnaHRgXG4gICAqIGRvZXMgbm90IGNoYW5nZSBhcyB0aGUgcG9zaXRpb24gb2YgdGhlIE1pbmkgQXBwIGNoYW5nZXMgd2l0aCB1c2VyXG4gICAqIGdlc3R1cmVzIG9yIGR1cmluZyBhbmltYXRpb25zLiBUaGUgdmFsdWUgb2YgYHN0YWJsZUhlaWdodGBcbiAgICogd2lsbCBiZSB1cGRhdGVkIGFmdGVyIGFsbCBnZXN0dXJlcyBhbmQgYW5pbWF0aW9ucyBhcmUgY29tcGxldGVkIGFuZFxuICAgKiB0aGUgTWluaSBBcHAgcmVhY2hlcyBpdHMgZmluYWwgc2l6ZS5cbiAgICovXG4gIGdldCBzdGFibGVIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZ2V0KFwic3RhYmxlSGVpZ2h0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgbGlzdGVuaW5nIHRvIHZpZXdwb3J0IGNoYW5nZXMgYW5kIGFwcGxpZXMgdGhlbS5cbiAgICogQHJldHVybnMgRnVuY3Rpb24gdG8gc3RvcCBsaXN0ZW5pbmcuXG4gICAqL1xuICBsaXN0ZW4oKSB7XG4gICAgcmV0dXJuIHkoXCJ2aWV3cG9ydF9jaGFuZ2VkXCIsICh0KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhlaWdodDogZSxcbiAgICAgICAgd2lkdGg6IHMsXG4gICAgICAgIGlzX2V4cGFuZGVkOiBuLFxuICAgICAgICBpc19zdGF0ZV9zdGFibGU6IGlcbiAgICAgIH0gPSB0LCBhID0ge1xuICAgICAgICBoZWlnaHQ6IEQoZSksXG4gICAgICAgIGlzRXhwYW5kZWQ6IG4sXG4gICAgICAgIHdpZHRoOiBEKHMpXG4gICAgICB9O1xuICAgICAgaSAmJiAoYS5zdGFibGVIZWlnaHQgPSBhLmhlaWdodCksIHRoaXMuc3RhdGUuc2V0KGEpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIE1pbmkgQXBwIGlzIGV4cGFuZGVkIHRvIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSBoZWlnaHQuXG4gICAqIE90aGVyd2lzZSwgaWYgdGhlIE1pbmkgQXBwIG9jY3VwaWVzIHBhcnQgb2YgdGhlIHNjcmVlbiBhbmQgY2FuIGJlIGV4cGFuZGVkXG4gICAqIHRvIHRoZSBmdWxsIGhlaWdodCB1c2luZyBgZXhwYW5kYCBtZXRob2QuXG4gICAqIEBzZWUgZXhwYW5kXG4gICAqL1xuICBnZXQgaXNFeHBhbmRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5nZXQoXCJpc0V4cGFuZGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IHZpZXdwb3J0IHdpZHRoLlxuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmdldChcIndpZHRoXCIpO1xuICB9XG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0aGF0IGV4cGFuZHMgdGhlIE1pbmkgQXBwIHRvIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSBoZWlnaHQuIFRvXG4gICAqIGZpbmQgb3V0IGlmIHRoZSBNaW5pIEFwcCBpcyBleHBhbmRlZCB0byB0aGUgbWF4aW11bSBoZWlnaHQsIHJlZmVyIHRvIHRoZVxuICAgKiB2YWx1ZSBvZiB0aGUgYGlzRXhwYW5kZWRgLlxuICAgKiBAc2VlIGlzRXhwYW5kZWRcbiAgICovXG4gIGV4cGFuZCgpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfZXhwYW5kXCIpLCB0aGlzLnN0YXRlLnNldChcImlzRXhwYW5kZWRcIiwgITApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaW4gY2FzZSBjdXJyZW50IHZpZXdwb3J0IGhlaWdodCBpcyBzdGFibGUgYW5kIGlzIG5vdCBnb2luZyB0b1xuICAgKiBjaGFuZ2UgaW4gdGhlIG5leHQgbW9tZW50LlxuICAgKi9cbiAgZ2V0IGlzU3RhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWJsZUhlaWdodCA9PT0gdGhpcy5oZWlnaHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIFJ0KHIpIHtcbiAgcmV0dXJuICFbXCJtYWNvc1wiLCBcIndlYlwiLCBcIndlYmFcIl0uaW5jbHVkZXMocik7XG59XG5mdW5jdGlvbiBWdChyLCB0LCBlKSB7XG4gIGlmIChyIHx8ICFSdCh0KSlcbiAgICByZXR1cm4gbmV3IEcoe1xuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICBpc0V4cGFuZGVkOiAhMCxcbiAgICAgIHBvc3RFdmVudDogZSxcbiAgICAgIHN0YWJsZUhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgfSk7XG4gIGNvbnN0IHMgPSAkKFwidmlld3BvcnRcIik7XG4gIHJldHVybiBzID8gbmV3IEcoeyAuLi5zLCBwb3N0RXZlbnQ6IGUgfSkgOiBudWxsO1xufVxuZnVuY3Rpb24gSXQocikge1xuICByZXR1cm4gci5saXN0ZW4oKSwgci5vbihcImNoYW5nZVwiLCAoKSA9PiBMKFwidmlld3BvcnRcIiwge1xuICAgIGhlaWdodDogci5oZWlnaHQsXG4gICAgaXNFeHBhbmRlZDogci5pc0V4cGFuZGVkLFxuICAgIHN0YWJsZUhlaWdodDogci5zdGFibGVIZWlnaHQsXG4gICAgd2lkdGg6IHIud2lkdGhcbiAgfSkpLCByO1xufVxuZnVuY3Rpb24gSGUociwgdCwgZSkge1xuICBjb25zdCBzID0gSXQoXG4gICAgVnQociwgdCwgZSkgfHwgbmV3IEcoe1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBpc0V4cGFuZGVkOiAhMSxcbiAgICAgIHBvc3RFdmVudDogZSxcbiAgICAgIHN0YWJsZUhlaWdodDogMFxuICAgIH0pXG4gICk7XG4gIHJldHVybiBSdCh0KSAmJiBzLnN5bmMoeyBwb3N0RXZlbnQ6IGUsIHRpbWVvdXQ6IDEwMCB9KS5jYXRjaCgobikgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gYWN0dWFsaXplIHZpZXdwb3J0IHN0YXRlXCIsIG4pO1xuICB9KSwgcztcbn1cbmFzeW5jIGZ1bmN0aW9uIFVlKHIsIHQsIGUpIHtcbiAgcmV0dXJuIEl0KFxuICAgIFZ0KHIsIHQsIGUpIHx8IGF3YWl0IEF0KHsgcG9zdEV2ZW50OiBlLCB0aW1lb3V0OiAxMDAgfSkudGhlbigoeyBoZWlnaHQ6IHMsIGlzU3RhdGVTdGFibGU6IG4sIC4uLmkgfSkgPT4gbmV3IEcoe1xuICAgICAgLi4uaSxcbiAgICAgIGhlaWdodDogcyxcbiAgICAgIHN0YWJsZUhlaWdodDogbiA/IHMgOiAwXG4gICAgfSkpXG4gICk7XG59XG5mdW5jdGlvbiBTKHIsIHQpIHtcbiAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHIsIHQpO1xufVxuZnVuY3Rpb24gTWUociwgdCkge1xuICBjb25zdCBlID0gKCkgPT4ge1xuICAgIFMoXCItLXRnLWJhY2tncm91bmQtY29sb3JcIiwgci5iYWNrZ3JvdW5kQ29sb3IpO1xuICB9LCBzID0gKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogbixcbiAgICAgIHNlY29uZGFyeUJhY2tncm91bmRDb2xvcjogaVxuICAgIH0gPSB0O1xuICAgIHIuaGVhZGVyQ29sb3IgPT09IFwiYmdfY29sb3JcIiA/IG4gJiYgUyhcIi0tdGctaGVhZGVyLWNvbG9yXCIsIG4pIDogci5oZWFkZXJDb2xvciA9PT0gXCJzZWNvbmRhcnlfYmdfY29sb3JcIiA/IGkgJiYgUyhcIi0tdGctaGVhZGVyLWNvbG9yXCIsIGkpIDogUyhcIi0tdGctaGVhZGVyLWNvbG9yXCIsIHIuaGVhZGVyQ29sb3IpO1xuICB9O1xuICB0Lm9uKFwiY2hhbmdlXCIsIHMpLCByLm9uKFwiY2hhbmdlOmJhY2tncm91bmRDb2xvclwiLCBlKSwgci5vbihcImNoYW5nZTpoZWFkZXJDb2xvclwiLCBzKSwgZSgpLCBzKCk7XG59XG5mdW5jdGlvbiBqZShyKSB7XG4gIGNvbnN0IHQgPSAoKSA9PiB7XG4gICAgY29uc3QgZSA9IHIuZ2V0U3RhdGUoKTtcbiAgICBPYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChbcywgbl0pID0+IHtcbiAgICAgIGlmIChuKSB7XG4gICAgICAgIGNvbnN0IGkgPSBzLnJlcGxhY2UoL1tBLVpdL2csIChhKSA9PiBgLSR7YS50b0xvd2VyQ2FzZSgpfWApO1xuICAgICAgICBTKGAtLXRnLXRoZW1lLSR7aX1gLCBuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgci5vbihcImNoYW5nZVwiLCB0KSwgdCgpO1xufVxuZnVuY3Rpb24gb3Qocikge1xuICBjb25zdCB0ID0gKCkgPT4gUyhcIi0tdGctdmlld3BvcnQtaGVpZ2h0XCIsIGAke3IuaGVpZ2h0fXB4YCksIGUgPSAoKSA9PiBTKFwiLS10Zy12aWV3cG9ydC13aWR0aFwiLCBgJHtyLndpZHRofXB4YCksIHMgPSAoKSA9PiBTKFwiLS10Zy12aWV3cG9ydC1oZWlnaHRcIiwgYCR7ci5zdGFibGVIZWlnaHR9cHhgKTtcbiAgci5vbihcImNoYW5nZTpoZWlnaHRcIiwgdCksIHIub24oXCJjaGFuZ2U6d2lkdGhcIiwgZSksIHIub24oXCJjaGFuZ2U6c3RhYmxlSGVpZ2h0XCIsIHMpLCB0KCksIGUoKSwgcygpO1xufVxuZnVuY3Rpb24gR2Uocikge1xuICByZXR1cm4gdHlwZW9mIHIgPT0gXCJvYmplY3RcIiA/IHIgOiByID8ge1xuICAgIHRoZW1lUGFyYW1zOiAhMCxcbiAgICB2aWV3cG9ydDogITAsXG4gICAgbWluaUFwcDogITBcbiAgfSA6IHt9O1xufVxuZnVuY3Rpb24gYXQociwgdCwgZSwgcykge1xuICBjb25zdCBuID0gR2Uocik7XG4gIG4ubWluaUFwcCAmJiBNZSh0LCBlKSwgbi50aGVtZVBhcmFtcyAmJiBqZShlKSwgbi52aWV3cG9ydCAmJiAocyBpbnN0YW5jZW9mIFByb21pc2UgPyBzLnRoZW4ob3QpIDogb3QocykpO1xufVxuZnVuY3Rpb24gRmUocikge1xuICBjb25zdCB7IGhvc3RuYW1lOiB0LCBwYXRobmFtZTogZSB9ID0gbmV3IFVSTChyLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gIGlmICh0ICE9PSBcInQubWVcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29ycmVjdCBob3N0bmFtZTogJHt0fWApO1xuICBjb25zdCBzID0gZS5tYXRjaCgvXlxcLyhcXCR8aW52b2ljZVxcLykoW0EtWmEtejAtOVxcLV89XSspJC8pO1xuICBpZiAocyA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmsgcGF0aG5hbWUgaGFzIGluY29ycmVjdCBmb3JtYXQuIEV4cGVjdGVkIHRvIHJlY2VpdmUgXCIvaW52b2ljZS97c2x1Z31cIiBvciBcIi8ke3NsdWd9XCInKTtcbiAgcmV0dXJuIHNbMl07XG59XG5jbGFzcyB6ZSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSBmKSB7XG4gICAgbyh0aGlzLCBcImVlXCIsIG5ldyB3KCkpO1xuICAgIG8odGhpcywgXCJzdGF0ZVwiKTtcbiAgICAvKipcbiAgICAgKiBBZGRzIG5ldyBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBvKHRoaXMsIFwib25cIiwgdGhpcy5lZS5vbi5iaW5kKHRoaXMuZWUpKTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIG8odGhpcywgXCJvZmZcIiwgdGhpcy5lZS5vZmYuYmluZCh0aGlzLmVlKSk7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHNwZWNpZmllZCBtZXRob2QgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIG8odGhpcywgXCJzdXBwb3J0c1wiKTtcbiAgICB0aGlzLnBvc3RFdmVudCA9IGUsIHRoaXMuc3RhdGUgPSBuZXcgXyh7IGlzT3BlbmVkOiAhMSB9LCB0aGlzLmVlKSwgdGhpcy5zdXBwb3J0cyA9IEUodCwgeyBvcGVuOiBcIndlYl9hcHBfb3Blbl9pbnZvaWNlXCIgfSk7XG4gIH1cbiAgc2V0IGlzT3BlbmVkKHQpIHtcbiAgICB0aGlzLnN0YXRlLnNldChcImlzT3BlbmVkXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIGludm9pY2UgaXMgY3VycmVudGx5IG9wZW5lZC5cbiAgICovXG4gIGdldCBpc09wZW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5nZXQoXCJpc09wZW5lZFwiKTtcbiAgfVxuICBhc3luYyBvcGVuKHQsIGUpIHtcbiAgICBpZiAodGhpcy5pc09wZW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludm9pY2UgaXMgYWxyZWFkeSBvcGVuZWRcIik7XG4gICAgY29uc3QgcyA9IGUgPyBGZSh0KSA6IHQ7XG4gICAgdGhpcy5pc09wZW5lZCA9ICEwO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGF3YWl0IG0oXG4gICAgICAgIFwid2ViX2FwcF9vcGVuX2ludm9pY2VcIixcbiAgICAgICAgeyBzbHVnOiBzIH0sXG4gICAgICAgIFwiaW52b2ljZV9jbG9zZWRcIixcbiAgICAgICAge1xuICAgICAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICAgICAgY2FwdHVyZShpKSB7XG4gICAgICAgICAgICByZXR1cm4gcyA9PT0gaS5zbHVnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSkuc3RhdHVzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzT3BlbmVkID0gITE7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBKZShyKSB7XG4gIGNvbnN0IHQgPSByLm1lc3NhZ2UudHJpbSgpLCBlID0gKHIudGl0bGUgfHwgXCJcIikudHJpbSgpLCBzID0gci5idXR0b25zIHx8IFtdO1xuICBsZXQgbjtcbiAgaWYgKGUubGVuZ3RoID4gNjQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaXRsZSBoYXMgaW5jb3JyZWN0IHNpemU6ICR7ZS5sZW5ndGh9YCk7XG4gIGlmICh0Lmxlbmd0aCA9PT0gMCB8fCB0Lmxlbmd0aCA+IDI1NilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2UgaGFzIGluY29ycmVjdCBzaXplOiAke3QubGVuZ3RofWApO1xuICBpZiAocy5sZW5ndGggPiAzKVxuICAgIHRocm93IG5ldyBFcnJvcihgQnV0dG9ucyBoYXZlIGluY29ycmVjdCBzaXplOiAke3MubGVuZ3RofWApO1xuICByZXR1cm4gcy5sZW5ndGggPT09IDAgPyBuID0gW3sgdHlwZTogXCJjbG9zZVwiLCBpZDogXCJcIiB9XSA6IG4gPSBzLm1hcCgoaSkgPT4ge1xuICAgIGNvbnN0IHsgaWQ6IGEgPSBcIlwiIH0gPSBpO1xuICAgIGlmIChhLmxlbmd0aCA+IDY0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCdXR0b24gSUQgaGFzIGluY29ycmVjdCBzaXplOiAke2F9YCk7XG4gICAgaWYgKGkudHlwZSA9PT0gdm9pZCAwIHx8IGkudHlwZSA9PT0gXCJkZWZhdWx0XCIgfHwgaS50eXBlID09PSBcImRlc3RydWN0aXZlXCIpIHtcbiAgICAgIGNvbnN0IGMgPSBpLnRleHQudHJpbSgpO1xuICAgICAgaWYgKGMubGVuZ3RoID09PSAwIHx8IGMubGVuZ3RoID4gNjQpIHtcbiAgICAgICAgY29uc3QgdSA9IGkudHlwZSB8fCBcImRlZmF1bHRcIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCdXR0b24gdGV4dCB3aXRoIHR5cGUgXCIke3V9XCIgaGFzIGluY29ycmVjdCBzaXplOiAke2kudGV4dC5sZW5ndGh9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyAuLi5pLCB0ZXh0OiBjLCBpZDogYSB9O1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5pLCBpZDogYSB9O1xuICB9KSwgeyB0aXRsZTogZSwgbWVzc2FnZTogdCwgYnV0dG9uczogbiB9O1xufVxuY2xhc3MgUWUge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0gZikge1xuICAgIG8odGhpcywgXCJlZVwiLCBuZXcgdygpKTtcbiAgICBvKHRoaXMsIFwic3RhdGVcIik7XG4gICAgLyoqXG4gICAgICogQWRkcyBuZXcgZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgbyh0aGlzLCBcIm9uXCIsIHRoaXMuZWUub24uYmluZCh0aGlzLmVlKSk7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBvKHRoaXMsIFwib2ZmXCIsIHRoaXMuZWUub2ZmLmJpbmQodGhpcy5lZSkpO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBzcGVjaWZpZWQgbWV0aG9kIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBvKHRoaXMsIFwic3VwcG9ydHNcIik7XG4gICAgdGhpcy5wb3N0RXZlbnQgPSBlLCB0aGlzLnN0YXRlID0gbmV3IF8oeyBpc09wZW5lZDogITEgfSwgdGhpcy5lZSksIHRoaXMuc3VwcG9ydHMgPSBFKHQsIHsgb3BlbjogXCJ3ZWJfYXBwX29wZW5fcG9wdXBcIiB9KTtcbiAgfVxuICBzZXQgaXNPcGVuZWQodCkge1xuICAgIHRoaXMuc3RhdGUuc2V0KFwiaXNPcGVuZWRcIiwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgcG9wdXAgaXMgY3VycmVudGx5IG9wZW5lZC5cbiAgICovXG4gIGdldCBpc09wZW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5nZXQoXCJpc09wZW5lZFwiKTtcbiAgfVxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBzaG93cyBhIG5hdGl2ZSBwb3B1cCBkZXNjcmliZWQgYnkgdGhlIGBwYXJhbXNgIGFyZ3VtZW50LlxuICAgKiBQcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiBwb3B1cCBpcyBjbG9zZWQuIFJlc29sdmVkIHZhbHVlIHdpbGwgaGF2ZVxuICAgKiBhbiBpZGVudGlmaWVyIG9mIHByZXNzZWQgYnV0dG9uLlxuICAgKlxuICAgKiBJbiBjYXNlLCB1c2VyIGNsaWNrZWQgb3V0c2lkZSB0aGUgcG9wdXAgb3IgY2xpY2tlZCB0b3AgcmlnaHQgcG9wdXAgY2xvc2VcbiAgICogYnV0dG9uLCBudWxsIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEZJWE1FOiBJbiBkZXNrdG9wLCB0aGlzIGZ1bmN0aW9uIG1heSB3b3JrIGluY29ycmVjdGx5LlxuICAgKiAgSXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9UZWxlZ3JhbS1NaW5pLUFwcHMvdG1hLmpzL2lzc3Vlcy83XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gcG9wdXAgcGFyYW1ldGVycy5cbiAgICogQHRocm93cyB7RXJyb3J9IFBvcHVwIGlzIGFscmVhZHkgb3BlbmVkLlxuICAgKi9cbiAgb3Blbih0KSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3B1cCBpcyBhbHJlYWR5IG9wZW5lZC5cIik7XG4gICAgcmV0dXJuIHRoaXMuaXNPcGVuZWQgPSAhMCwgbShcbiAgICAgIFwid2ViX2FwcF9vcGVuX3BvcHVwXCIsXG4gICAgICBKZSh0KSxcbiAgICAgIFwicG9wdXBfY2xvc2VkXCIsXG4gICAgICB7IHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQgfVxuICAgICkudGhlbigoeyBidXR0b25faWQ6IGUgPSBudWxsIH0pID0+IGUpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5pc09wZW5lZCA9ICExO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBaZSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSBmKSB7XG4gICAgbyh0aGlzLCBcImVlXCIsIG5ldyB3KCkpO1xuICAgIG8odGhpcywgXCJzdGF0ZVwiKTtcbiAgICAvKipcbiAgICAgKiBBZGRzIG5ldyBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBvKHRoaXMsIFwib25cIiwgdGhpcy5lZS5vbi5iaW5kKHRoaXMuZWUpKTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIG8odGhpcywgXCJvZmZcIiwgdGhpcy5lZS5vZmYuYmluZCh0aGlzLmVlKSk7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHNwZWNpZmllZCBtZXRob2QgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIG8odGhpcywgXCJzdXBwb3J0c1wiKTtcbiAgICB0aGlzLnBvc3RFdmVudCA9IGUsIHRoaXMuc3RhdGUgPSBuZXcgXyh7IGlzT3BlbmVkOiAhMSB9LCB0aGlzLmVlKSwgdGhpcy5zdXBwb3J0cyA9IEUodCwge1xuICAgICAgY2xvc2U6IFwid2ViX2FwcF9jbG9zZV9zY2FuX3FyX3BvcHVwXCIsXG4gICAgICBvcGVuOiBcIndlYl9hcHBfb3Blbl9zY2FuX3FyX3BvcHVwXCJcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHNjYW5uZXIuXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfY2xvc2Vfc2Nhbl9xcl9wb3B1cFwiKSwgdGhpcy5pc09wZW5lZCA9ICExO1xuICB9XG4gIHNldCBpc09wZW5lZCh0KSB7XG4gICAgdGhpcy5zdGF0ZS5zZXQoXCJpc09wZW5lZFwiLCB0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGluIGNhc2UsIFFSIHNjYW5uZXIgaXMgY3VycmVudGx5IG9wZW5lZC5cbiAgICovXG4gIGdldCBpc09wZW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5nZXQoXCJpc09wZW5lZFwiKTtcbiAgfVxuICAvKipcbiAgICogT3BlbnMgc2Nhbm5lciB3aXRoIHNwZWNpZmllZCB0aXRsZSBzaG93biB0byB1c2VyLiBNZXRob2QgcmV0dXJucyBwcm9taXNlXG4gICAqIHdpdGggc2Nhbm5lZCBRUiBjb250ZW50IGluIGNhc2UsIGl0IHdhcyBzY2FubmVkLiBJdCB3aWxsIGNvbnRhaW4gbnVsbCBpblxuICAgKiBjYXNlLCBzY2FubmVyIHdhcyBjbG9zZWQuXG4gICAqIEBwYXJhbSB0ZXh0IC0gdGl0bGUgdG8gZGlzcGxheS5cbiAgICovXG4gIGFzeW5jIG9wZW4odCkge1xuICAgIGlmICh0aGlzLmlzT3BlbmVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUVIgc2Nhbm5lciBpcyBhbHJlYWR5IG9wZW5lZC5cIik7XG4gICAgdGhpcy5pc09wZW5lZCA9ICEwO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlID0gYXdhaXQgbShcbiAgICAgICAgXCJ3ZWJfYXBwX29wZW5fc2Nhbl9xcl9wb3B1cFwiLFxuICAgICAgICB7IHRleHQ6IHQgfSxcbiAgICAgICAgW1wicXJfdGV4dF9yZWNlaXZlZFwiLCBcInNjYW5fcXJfcG9wdXBfY2xvc2VkXCJdLFxuICAgICAgICB7IHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBlLmRhdGEgPT0gXCJzdHJpbmdcIiA/IGUuZGF0YSA6IG51bGw7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaXNPcGVuZWQgPSAhMTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEtlIHtcbiAgY29uc3RydWN0b3IodCwgZSwgcyA9IGYpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgc3BlY2lmaWVkIG1ldGhvZCBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBjb21wb25lbnQuXG4gICAgICovXG4gICAgbyh0aGlzLCBcInN1cHBvcnRzXCIpO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBzcGVjaWZpZWQgbWV0aG9kIHBhcmFtZXRlciBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBjb21wb25lbnQuXG4gICAgICovXG4gICAgbyh0aGlzLCBcInN1cHBvcnRzUGFyYW1cIik7XG4gICAgdGhpcy52ZXJzaW9uID0gdCwgdGhpcy5jcmVhdGVSZXF1ZXN0SWQgPSBlLCB0aGlzLnBvc3RFdmVudCA9IHMsIHRoaXMuc3VwcG9ydHMgPSBFKHQsIHtcbiAgICAgIHJlYWRUZXh0RnJvbUNsaXBib2FyZDogXCJ3ZWJfYXBwX3JlYWRfdGV4dF9mcm9tX2NsaXBib2FyZFwiXG4gICAgfSksIHRoaXMuc3VwcG9ydHNQYXJhbSA9IGt0KHQsIHtcbiAgICAgIFwib3BlbkxpbmsudHJ5SW5zdGFudFZpZXdcIjogW1wid2ViX2FwcF9vcGVuX2xpbmtcIiwgXCJ0cnlfaW5zdGFudF92aWV3XCJdXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW5zIGEgbGluayBpbiBhbiBleHRlcm5hbCBicm93c2VyLiBUaGUgTWluaSBBcHAgd2lsbCBub3QgYmUgY2xvc2VkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBvbmx5IGluIHJlc3BvbnNlIHRvIHRoZSB1c2VyXG4gICAqIGludGVyYWN0aW9uIHdpdGggdGhlIE1pbmkgQXBwIGludGVyZmFjZSAoZS5nLiBjbGljayBpbnNpZGUgdGhlIE1pbmkgQXBwXG4gICAqIG9yIG9uIHRoZSBtYWluIGJ1dHRvbikuXG4gICAqIEBwYXJhbSB1cmwgLSBVUkwgdG8gYmUgb3BlbmVkLlxuICAgKiBAcGFyYW0gdHJ5SW5zdGFudFZpZXdcbiAgICovXG4gIG9wZW5MaW5rKHQsIGUpIHtcbiAgICBjb25zdCBzID0gbmV3IFVSTCh0LCB3aW5kb3cubG9jYXRpb24uaHJlZikudG9TdHJpbmcoKTtcbiAgICBpZiAoIUEoXCJ3ZWJfYXBwX29wZW5fbGlua1wiLCB0aGlzLnZlcnNpb24pKSB7XG4gICAgICB3aW5kb3cub3BlbihzLCBcIl9ibGFua1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX29wZW5fbGlua1wiLCB7XG4gICAgICB1cmw6IHMsXG4gICAgICAuLi50eXBlb2YgZSA9PSBcImJvb2xlYW5cIiA/IHsgdHJ5X2luc3RhbnRfdmlldzogZSB9IDoge31cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogT3BlbnMgYSBUZWxlZ3JhbSBsaW5rIGluc2lkZSBUZWxlZ3JhbSBhcHAuIFRoZSBNaW5pIEFwcCB3aWxsIGJlIGNsb3NlZC4gSXQgZXhwZWN0cyBwYXNzaW5nXG4gICAqIGxpbmsgaW4gZnVsbCBmb3JtYXQsIHdpdGggaG9zdG5hbWUgXCJ0Lm1lXCIuXG4gICAqIEBwYXJhbSB1cmwgLSBVUkwgdG8gYmUgb3BlbmVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVVJMIGhhcyBub3QgYWxsb3dlZCBob3N0bmFtZS5cbiAgICovXG4gIG9wZW5UZWxlZ3JhbUxpbmsodCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhvc3RuYW1lOiBlLFxuICAgICAgcGF0aG5hbWU6IHMsXG4gICAgICBzZWFyY2g6IG5cbiAgICB9ID0gbmV3IFVSTCh0LCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgaWYgKGUgIT09IFwidC5tZVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVUkwgaGFzIG5vdCBhbGxvd2VkIGhvc3RuYW1lOiAke2V9LiBPbmx5IFwidC5tZVwiIGlzIGFsbG93ZWRgKTtcbiAgICBpZiAoIUEoXCJ3ZWJfYXBwX29wZW5fdGdfbGlua1wiLCB0aGlzLnZlcnNpb24pKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9vcGVuX3RnX2xpbmtcIiwgeyBwYXRoX2Z1bGw6IHMgKyBuIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkcyB0ZXh0IGZyb20gY2xpcGJvYXJkIGFuZCByZXR1cm5zIHN0cmluZyBvciBudWxsLiBudWxsIGlzIHJldHVybmVkXG4gICAqIGluIGNhc2VzOlxuICAgKiAtIFZhbHVlIGluIGNsaXBib2FyZCBpcyBub3QgdGV4dFxuICAgKiAtIEFjY2VzcyB0byBjbGlwYm9hcmQgaXMgbm90IGFsbG93ZWRcbiAgICovXG4gIHJlYWRUZXh0RnJvbUNsaXBib2FyZCgpIHtcbiAgICByZXR1cm4gbShcbiAgICAgIFwid2ViX2FwcF9yZWFkX3RleHRfZnJvbV9jbGlwYm9hcmRcIixcbiAgICAgIHsgcmVxX2lkOiB0aGlzLmNyZWF0ZVJlcXVlc3RJZCgpIH0sXG4gICAgICBcImNsaXBib2FyZF90ZXh0X3JlY2VpdmVkXCIsXG4gICAgICB7IHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQgfVxuICAgICkudGhlbigoeyBkYXRhOiB0ID0gbnVsbCB9KSA9PiB0KTtcbiAgfVxufVxuZnVuY3Rpb24gdXIociA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBhc3luYzogdCA9ICExLFxuICAgIGNzc1ZhcnM6IGUgPSAhMSxcbiAgICBhY2NlcHRDdXN0b21TdHlsZXM6IHMgPSAhMVxuICB9ID0gcjtcbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBsYXVuY2hQYXJhbXM6IHtcbiAgICAgICAgaW5pdERhdGE6IG4sXG4gICAgICAgIGluaXREYXRhUmF3OiBpLFxuICAgICAgICB2ZXJzaW9uOiBhLFxuICAgICAgICBwbGF0Zm9ybTogYyxcbiAgICAgICAgdGhlbWVQYXJhbXM6IHUsXG4gICAgICAgIGJvdElubGluZTogcCA9ICExXG4gICAgICB9LFxuICAgICAgaXNQYWdlUmVsb2FkOiBsXG4gICAgfSA9IEN0KCksIGIgPSBEZSgpLCBkID0geWUoYSk7XG4gICAgdnQoKSAmJiAocyAmJiBBZSgpLCBkKFwiaWZyYW1lX3JlYWR5XCIsIHsgcmVsb2FkX3N1cHBvcnRlZDogITAgfSksIHkoXCJyZWxvYWRfaWZyYW1lXCIsICgpID0+IHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKSkpO1xuICAgIGNvbnN0IEMgPSB7XG4gICAgICBiYWNrQnV0dG9uOiBSZShsLCBhLCBkKSxcbiAgICAgIGNsb3NpbmdCZWhhdmlvcjogVmUobCwgZCksXG4gICAgICBjbG91ZFN0b3JhZ2U6IG5ldyB4ZShhLCBiLCBkKSxcbiAgICAgIGNyZWF0ZVJlcXVlc3RJZDogYixcbiAgICAgIGhhcHRpY0ZlZWRiYWNrOiBuZXcgcWUoYSwgZCksXG4gICAgICBpbnZvaWNlOiBuZXcgemUoYSwgZCksXG4gICAgICBtYWluQnV0dG9uOiBMZShcbiAgICAgICAgbCxcbiAgICAgICAgdS5idXR0b25Db2xvciB8fCBcIiMwMDAwMDBcIixcbiAgICAgICAgdS5idXR0b25UZXh0Q29sb3IgfHwgXCIjZmZmZmZmXCIsXG4gICAgICAgIGRcbiAgICAgICksXG4gICAgICBtaW5pQXBwOiBCZShcbiAgICAgICAgbCxcbiAgICAgICAgdS5iYWNrZ3JvdW5kQ29sb3IgfHwgXCIjZmZmZmZmXCIsXG4gICAgICAgIGEsXG4gICAgICAgIHAsXG4gICAgICAgIGIsXG4gICAgICAgIGRcbiAgICAgICksXG4gICAgICBwb3B1cDogbmV3IFFlKGEsIGQpLFxuICAgICAgcG9zdEV2ZW50OiBkLFxuICAgICAgcXJTY2FubmVyOiBuZXcgWmUoYSwgZCksXG4gICAgICBzZXR0aW5nc0J1dHRvbjogTmUobCwgYSwgZCksXG4gICAgICB0aGVtZVBhcmFtczogT2UodSksXG4gICAgICB1dGlsczogbmV3IEtlKGEsIGIsIGQpLFxuICAgICAgLi4ubiA/IHtcbiAgICAgICAgaW5pdERhdGE6IG5ldyBVdChuKSxcbiAgICAgICAgaW5pdERhdGFSYXc6IGlcbiAgICAgIH0gOiB7fVxuICAgIH0sIHggPSB0ID8gVWUobCwgYywgZCkgOiBIZShsLCBjLCBkKTtcbiAgICByZXR1cm4geCBpbnN0YW5jZW9mIFByb21pc2UgPyB4LnRoZW4oKFQpID0+IChhdChcbiAgICAgIGUsXG4gICAgICBDLm1pbmlBcHAsXG4gICAgICBDLnRoZW1lUGFyYW1zLFxuICAgICAgVFxuICAgICksIHtcbiAgICAgIC4uLkMsXG4gICAgICB2aWV3cG9ydDogVFxuICAgIH0pKSA6IChhdChcbiAgICAgIGUsXG4gICAgICBDLm1pbmlBcHAsXG4gICAgICBDLnRoZW1lUGFyYW1zLFxuICAgICAgeFxuICAgICksIHsgLi4uQywgdmlld3BvcnQ6IHggfSk7XG4gIH0gY2F0Y2ggKG4pIHtcbiAgICBpZiAodClcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuKTtcbiAgICB0aHJvdyBuO1xuICB9XG59XG5mdW5jdGlvbiBXKHIsIHQpIHtcbiAgcmV0dXJuIHIuc3RhcnRzV2l0aCh0KSA/IHIgOiBgJHt0fSR7cn1gO1xufVxuZnVuY3Rpb24gcHIocikge1xuICBjb25zdCB0ID0gci5tYXRjaCgvIyguKykvKTtcbiAgcmV0dXJuIHQgPyB0WzFdIDogbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIE8ocikge1xuICByZXR1cm4gciA9PT0gMCA/ICEwIDogUHJvbWlzZS5yYWNlKFtcbiAgICBuZXcgUHJvbWlzZSgodCkgPT4ge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBmdW5jdGlvbiBlKCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIGUpLCB0KCEwKTtcbiAgICAgIH0pLCB3aW5kb3cuaGlzdG9yeS5nbyhyKTtcbiAgICB9KSxcbiAgICAvLyBVc3VhbGx5LCBpdCB0YWtlcyBhYm91dCAxbXMgdG8gZW1pdCB0aGlzIGV2ZW50LCBidXQgd2UgdXNlIHNvbWUgYnVmZmVyLlxuICAgIG5ldyBQcm9taXNlKCh0KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KHQsIDUwLCAhMSk7XG4gICAgfSlcbiAgXSk7XG59XG5hc3luYyBmdW5jdGlvbiBZZSgpIHtcbiAgaWYgKHdpbmRvdy5oaXN0b3J5Lmxlbmd0aCA8PSAxIHx8ICh3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgXCJcIiksIGF3YWl0IE8oMSAtIHdpbmRvdy5oaXN0b3J5Lmxlbmd0aCkpKVxuICAgIHJldHVybjtcbiAgbGV0IHQgPSBhd2FpdCBPKC0xKTtcbiAgZm9yICg7IHQ7IClcbiAgICB0ID0gYXdhaXQgTygtMSk7XG59XG5jbGFzcyBYZSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIHtcbiAgICBkZWJ1ZzogcyA9ICExLFxuICAgIGxvZ2dlclByZWZpeDogbiA9IFwiTmF2aWdhdG9yXCJcbiAgfSkge1xuICAgIG8odGhpcywgXCJsb2dnZXJcIik7XG4gICAgbyh0aGlzLCBcImVudHJpZXNcIik7XG4gICAgaWYgKHRoaXMuZW50cmllc0N1cnNvciA9IGUsIHQubGVuZ3RoID09PSAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW50cmllcyBsaXN0IHNob3VsZCBub3QgYmUgZW1wdHkuXCIpO1xuICAgIGlmIChlID49IHQubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIHNob3VsZCBiZSBsZXNzIHRoYW4gZW50cmllcyBjb3VudC5cIik7XG4gICAgdGhpcy5lbnRyaWVzID0gdC5tYXAoKHsgcGF0aG5hbWU6IGkgPSBcIlwiLCBzZWFyY2g6IGEsIGhhc2g6IGMgfSkgPT4ge1xuICAgICAgaWYgKCFpLnN0YXJ0c1dpdGgoXCIvXCIpICYmIGkubGVuZ3RoID4gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRobmFtZSBzaG91bGQgc3RhcnQgd2l0aCBcIi9cIicpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IFcoaSwgXCIvXCIpLFxuICAgICAgICBzZWFyY2g6IGEgPyBXKGEsIFwiP1wiKSA6IFwiXCIsXG4gICAgICAgIGhhc2g6IGMgPyBXKGMsIFwiI1wiKSA6IFwiXCJcbiAgICAgIH07XG4gICAgfSksIHRoaXMubG9nZ2VyID0gbmV3IFB0KGBbJHtufV1gLCBzKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgZW50cnkgdG8gdGhlIG5hdmlnYXRpb24gZW50cnkuXG4gICAqIEBwYXJhbSBlbnRyeSAtIGVudHJ5IGRhdGFcbiAgICovXG4gIGZvcm1hdEVudHJ5KHQpIHtcbiAgICBsZXQgZTtcbiAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIilcbiAgICAgIGUgPSB0O1xuICAgIGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXRobmFtZTogYSA9IFwiXCIsXG4gICAgICAgIHNlYXJjaDogYyxcbiAgICAgICAgaGFzaDogdVxuICAgICAgfSA9IHQ7XG4gICAgICBlID0gYSArIChjID8gVyhjLCBcIj9cIikgOiBcIlwiKSArICh1ID8gVyh1LCBcIiNcIikgOiBcIlwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGF0aG5hbWU6IHMsXG4gICAgICBzZWFyY2g6IG4sXG4gICAgICBoYXNoOiBpXG4gICAgfSA9IG5ldyBVUkwoZSwgYGh0dHBzOi8vbG9jYWxob3N0JHt0aGlzLnBhdGh9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGhuYW1lOiBzLFxuICAgICAgc2VhcmNoOiBuLFxuICAgICAgaGFzaDogaVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgZW50cnkuXG4gICAqL1xuICBnZXQgZW50cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllc1t0aGlzLmVudHJpZXNDdXJzb3JdO1xuICB9XG4gIC8qKlxuICAgKiBHb2VzIGJhY2sgaW4gaGlzdG9yeS5cbiAgICovXG4gIGJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuZ28oLTEpO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IGVudHJpZXMgY3Vyc29yLlxuICAgKi9cbiAgZ2V0IGN1cnNvcigpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzQ3Vyc29yO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIG5hdmlnYXRvciBjYW4gZ28gYmFjay5cbiAgICovXG4gIGdldCBjYW5Hb0JhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllc0N1cnNvciA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgbmF2aWdhdG9yIGNhbiBnbyBmb3J3YXJkLlxuICAgKi9cbiAgZ2V0IGNhbkdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzQ3Vyc29yICE9PSB0aGlzLmVudHJpZXMubGVuZ3RoIC0gMTtcbiAgfVxuICAvKipcbiAgICogR29lcyBmb3J3YXJkIGluIGhpc3RvcnkuXG4gICAqL1xuICBmb3J3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLmdvKDEpO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlcyBlbnRyaWVzIGN1cnNvciBieSBzcGVjaWZpZWQgZGVsdGEuXG4gICAqIEBwYXJhbSBkZWx0YSAtIGN1cnNvciBkZWx0YS5cbiAgICovXG4gIGdvKHQpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYGNhbGxlZCBnbygke3R9KWApO1xuICAgIGNvbnN0IGUgPSBNYXRoLm1pbihcbiAgICAgIHRoaXMuZW50cmllcy5sZW5ndGggLSAxLFxuICAgICAgTWF0aC5tYXgodGhpcy5lbnRyaWVzQ3Vyc29yICsgdCwgMClcbiAgICApO1xuICAgIGlmICh0aGlzLmVudHJpZXNDdXJzb3IgPT09IGUpXG4gICAgICByZXR1cm4gdGhpcy5wZXJmb3JtR28oe1xuICAgICAgICB1cGRhdGVkOiAhMSxcbiAgICAgICAgZGVsdGE6IHRcbiAgICAgIH0pO1xuICAgIGNvbnN0IHMgPSB0aGlzLmVudHJ5O1xuICAgIHRoaXMuZW50cmllc0N1cnNvciA9IGU7XG4gICAgY29uc3QgbiA9IHRoaXMuZW50cnk7XG4gICAgcmV0dXJuIHRoaXMubG9nZ2VyLmxvZyhcIlN0YXRlIGNoYW5nZWRcIiwgeyBiZWZvcmU6IHMsIGFmdGVyOiBuIH0pLCB0aGlzLnBlcmZvcm1Hbyh7XG4gICAgICB1cGRhdGVkOiAhMCxcbiAgICAgIGRlbHRhOiB0LFxuICAgICAgYmVmb3JlOiBzLFxuICAgICAgYWZ0ZXI6IG5cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBjb3B5IG9mIG5hdmlnYXRvciBlbnRyaWVzLlxuICAgKi9cbiAgZ2V0RW50cmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzLm1hcCgodCkgPT4gKHsgLi4udCB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgaGFzaC5cbiAgICogQGV4YW1wbGVcbiAgICogXCJcIiwgXCIjXCIsIFwiI2hhc2hcIlxuICAgKi9cbiAgZ2V0IGhhc2goKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cnkuaGFzaDtcbiAgfVxuICAvKipcbiAgICogUHVzaGVzIG5ldyBlbnRyeS4gTWV0aG9kIHJlcGxhY2VzIGFsbCBlbnRyaWVzIGFmdGVyIHRoZSBjdXJyZW50IG9uZSB3aXRoIHRoZSBpbnNlcnRlZC5cbiAgICogQHBhcmFtIGVudHJ5IC0gZW50cnkgZGF0YS5cbiAgICpcbiAgICogQGV4YW1wbGUgUHVzaGluZyBhYnNvbHV0ZSBwYXRobmFtZS5cbiAgICogcHVzaChcIi9hYnNvbHV0ZS1wYXRoXCIpOyAvLyBcIi9hYnNvbHV0ZS1wYXRoXCJcbiAgICpcbiAgICogQGV4YW1wbGUgUHVzaGluZyByZWxhdGl2ZSBwYXRobmFtZS5cbiAgICogLy8gUHVzaGluZyByZWxhdGl2ZSBwYXRoIHJlcGxhY2VzIE4gbGFzdCBwYXRoIHBhcnRzLCB3aGVyZSBOIGlzIHB1c2hlZCBwYXRobmFtZSBwYXJ0cyBjb3VudC5cbiAgICogLy8gUHVzaGluZyBlbXB0eSBwYXRoIGlzIHJlY29nbml6ZWQgYXMgcmVsYXRpdmUsIGJ1dCBub3QgcmVwbGFjaW5nIHRoZSBsYXN0IHBhdGhuYW1lIHBhcnQuXG4gICAqIHB1c2goXCJyZWxhdGl2ZVwiKTsgLy8gXCIvaG9tZS9yb290XCIgLT4gXCIvaG9tZS9yZWxhdGl2ZVwiXG4gICAqXG4gICAqIEBleGFtcGxlIFB1c2hpbmcgcXVlcnkgcGFyYW1ldGVycy5cbiAgICogcHVzaChcIi9hYnNvbHV0ZT9teS1wYXJhbT0xXCIpOyAvLyBcIi9ob21lXCIgLT4gXCIvYWJzb2x1dGU/bXktcGFyYW09MVwiXG4gICAqIHB1c2goXCJyZWxhdGl2ZT9teS1wYXJhbT0xXCIpOyAvLyBcIi9ob21lL3Jvb3RcIiAtPiBcIi9ob21lL3JlbGF0aXZlP215LXBhcmFtPTFcIlxuICAgKiBwdXNoKFwiP215LXBhcmFtPTFcIik7IC8vIFwiL2hvbWVcIiAtPiBcIi9ob21lP215LXBhcmFtPTFcIlxuICAgKlxuICAgKiBAZXhhbXBsZSBQdXNoaW5nIGhhc2guXG4gICAqIHB1c2goXCIjbXktaGFzaFwiKTsgLy8gXCIvaG9tZVwiIC0+IFwiL2hvbWUjbXktaGFzaFwiXG4gICAqIHB1c2goXCJqb2hueSNteS1oYXNoXCIpOyAvLyBcIi9ob21lL3Jvb3RcIiAtPiBcIi9ob21lL2pvaG55I215LWhhc2hcIlxuICAgKi9cbiAgcHVzaCh0KSB7XG4gICAgdGhpcy5lbnRyaWVzQ3Vyc29yICE9PSB0aGlzLmVudHJpZXMubGVuZ3RoIC0gMSAmJiB0aGlzLmVudHJpZXMuc3BsaWNlKHRoaXMuZW50cmllc0N1cnNvciArIDEpO1xuICAgIGNvbnN0IGUgPSB0aGlzLmZvcm1hdEVudHJ5KHQpLCBzID0gdGhpcy5lbnRyeTtcbiAgICB0aGlzLmVudHJpZXNDdXJzb3IgKz0gMSwgdGhpcy5lbnRyaWVzW3RoaXMuZW50cmllc0N1cnNvcl0gPSBlO1xuICAgIGNvbnN0IG4gPSB0aGlzLmVudHJ5O1xuICAgIHJldHVybiB0aGlzLmxvZ2dlci5sb2coXCJTdGF0ZSBjaGFuZ2VkXCIsIHsgYmVmb3JlOiBzLCBhZnRlcjogbiB9KSwgdGhpcy5wZXJmb3JtUHVzaCh7XG4gICAgICBiZWZvcmU6IHMsXG4gICAgICBhZnRlcjogblxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IGZ1bGwgcGF0aCBpbmNsdWRpbmcgcGF0aG5hbWUsIHF1ZXJ5IHBhcmFtZXRlcnMgYW5kIGhhc2guXG4gICAqL1xuICBnZXQgcGF0aCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5wYXRobmFtZX0ke3RoaXMuc2VhcmNofSR7dGhpcy5oYXNofWA7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgcGF0aG5hbWUuXG4gICAqIEBleGFtcGxlXG4gICAqIFwiL1wiLCBcIi9hYmNcIlxuICAgKi9cbiAgZ2V0IHBhdGhuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJ5LnBhdGhuYW1lO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyBjdXJyZW50IGVudHJ5LiBIYXMgdGhlIHNhbWUgbG9naWMgYXMgYHB1c2hgIG1ldGhvZC5cbiAgICogQHBhcmFtIGVudHJ5IC0gZW50cnkgZGF0YS5cbiAgICogQHNlZSBwdXNoXG4gICAqIEByZXR1cm5zIFRydWUgaWYgY2hhbmdlcyB3ZXJlIGRvbmUuXG4gICAqL1xuICByZXBsYWNlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5mb3JtYXRFbnRyeSh0KTtcbiAgICBpZiAodGhpcy5zZWFyY2ggPT09IGUuc2VhcmNoICYmIHRoaXMucGF0aG5hbWUgPT09IGUucGF0aG5hbWUgJiYgdGhpcy5oYXNoID09PSBlLmhhc2gpXG4gICAgICByZXR1cm4gdGhpcy5wZXJmb3JtUmVwbGFjZSh7XG4gICAgICAgIHVwZGF0ZWQ6ICExLFxuICAgICAgICBlbnRyeTogZVxuICAgICAgfSk7XG4gICAgY29uc3QgcyA9IHRoaXMuZW50cnk7XG4gICAgdGhpcy5lbnRyaWVzW3RoaXMuZW50cmllc0N1cnNvcl0gPSBlO1xuICAgIGNvbnN0IG4gPSB0aGlzLmVudHJ5O1xuICAgIHJldHVybiB0aGlzLmxvZ2dlci5sb2coXCJTdGF0ZSBjaGFuZ2VkXCIsIHsgYmVmb3JlOiBzLCBhZnRlcjogbiB9KSwgdGhpcy5wZXJmb3JtUmVwbGFjZSh7XG4gICAgICB1cGRhdGVkOiAhMCxcbiAgICAgIGJlZm9yZTogcyxcbiAgICAgIGFmdGVyOiBuXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgcXVlcnkgcGFyYW1ldGVycy5cbiAgICogQGV4YW1wbGVcbiAgICogXCJcIiwgXCI/XCIsIFwiP2E9MVwiXG4gICAqL1xuICBnZXQgc2VhcmNoKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJ5LnNlYXJjaDtcbiAgfVxufVxuY29uc3QgY3QgPSAwLCBaID0gMSwgSyA9IDI7XG5jbGFzcyBMdCBleHRlbmRzIFhlIHtcbiAgY29uc3RydWN0b3IoZSwgcywgbiA9IHt9KSB7XG4gICAgc3VwZXIoZSwgcywge1xuICAgICAgLi4ubixcbiAgICAgIGxvZ2dlclByZWZpeDogXCJIYXNoTmF2aWdhdG9yXCJcbiAgICB9KTtcbiAgICBvKHRoaXMsIFwiZWVcIiwgbmV3IHcoKSk7XG4gICAgbyh0aGlzLCBcImF0dGFjaGVkXCIsICExKTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdpbmRvdyBcInBvcHN0YXRlXCIgZXZlbnQuXG4gICAgICogQHBhcmFtIHN0YXRlIC0gZXZlbnQgc3RhdGUuXG4gICAgICovXG4gICAgbyh0aGlzLCBcIm9uUG9wU3RhdGVcIiwgYXN5bmMgKHsgc3RhdGU6IGUgfSkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9nZ2VyLmxvZygnXCJwb3BzdGF0ZVwiIGV2ZW50IHJlY2VpdmVkLiBTdGF0ZTonLCBlKSwgZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh3aW5kb3cubG9jYXRpb24uaGFzaC5zbGljZSgxKSk7XG4gICAgICBpZiAoZSA9PT0gY3QpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiVm9pZCByZWFjaGVkLiBNb3ZpbmcgaGlzdG9yeSBmb3J3YXJkXCIpLCB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlID09PSBaKVxuICAgICAgICByZXR1cm4gdGhpcy5iYWNrKCk7XG4gICAgICBpZiAoZSA9PT0gSylcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yd2FyZCgpO1xuICAgIH0pO1xuICAgIG8odGhpcywgXCJiYWNrXCIsICgpID0+IHN1cGVyLmJhY2soKSk7XG4gICAgLyoqXG4gICAgICogQWRkcyBuZXcgZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgbyh0aGlzLCBcIm9uXCIsIHRoaXMuZWUub24uYmluZCh0aGlzLmVlKSk7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBvKHRoaXMsIFwib2ZmXCIsIHRoaXMuZWUub2ZmLmJpbmQodGhpcy5lZSkpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIG5hdmlnYXRvciBmcm9tIGN1cnJlbnQgd2luZG93IGxvY2F0aW9uIGhhc2guXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyBwYXNzZWQgdG8gY29uc3RydWN0b3IuXG4gICAqL1xuICBzdGF0aWMgZnJvbUxvY2F0aW9uKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzZWFyY2g6IHMsXG4gICAgICBwYXRobmFtZTogbixcbiAgICAgIGhhc2g6IGlcbiAgICB9ID0gbmV3IFVSTChcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpLFxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICApO1xuICAgIHJldHVybiBuZXcgTHQoW3sgc2VhcmNoOiBzLCBwYXRobmFtZTogbiwgaGFzaDogaSB9XSwgMCwgZSk7XG4gIH1cbiAgYXN5bmMgcGVyZm9ybUdvKGUpIHtcbiAgICBlLnVwZGF0ZWQgJiYgKHRoaXMuYXR0YWNoZWQgJiYgYXdhaXQgdGhpcy5zeW5jSGlzdG9yeSgpLCB0aGlzLmVtaXRDaGFuZ2VkKGUuYmVmb3JlLCBlLmFmdGVyKSk7XG4gIH1cbiAgYXN5bmMgcGVyZm9ybVB1c2goeyBiZWZvcmU6IGUsIGFmdGVyOiBzIH0pIHtcbiAgICB0aGlzLmF0dGFjaGVkICYmIGF3YWl0IHRoaXMuc3luY0hpc3RvcnkoKSwgdGhpcy5lbWl0Q2hhbmdlZChlLCBzKTtcbiAgfVxuICBhc3luYyBwZXJmb3JtUmVwbGFjZShlKSB7XG4gICAgZS51cGRhdGVkICYmICh0aGlzLmF0dGFjaGVkICYmIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCBcIlwiLCBgIyR7dGhpcy5wYXRofWApLCB0aGlzLmVtaXRDaGFuZ2VkKGUuYmVmb3JlLCBlLmFmdGVyKSk7XG4gIH1cbiAgLyoqXG4gICAqIFN5bmNocm9uaXplcyBjdXJyZW50IG5hdmlnYXRvciBzdGF0ZSB3aXRoIGJyb3dzZXIgaGlzdG9yeS5cbiAgICovXG4gIGFzeW5jIHN5bmNIaXN0b3J5KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5vblBvcFN0YXRlKTtcbiAgICBjb25zdCBlID0gYCMke3RoaXMucGF0aH1gO1xuICAgIGF3YWl0IFllKCksIGYoXCJ3ZWJfYXBwX3NldHVwX2JhY2tfYnV0dG9uXCIsIHsgaXNfdmlzaWJsZTogdGhpcy5jYW5Hb0JhY2sgfSksIHRoaXMuY2FuR29CYWNrICYmIHRoaXMuY2FuR29Gb3J3YXJkID8gKHRoaXMubG9nZ2VyLmxvZyhcIlNldHRpbmcgdXAgaGlzdG9yeTogWzwtLCAqLCAtPl1cIiksIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShaLCBcIlwiKSwgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIFwiXCIsIGUpLCB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoSywgXCJcIiksIGF3YWl0IE8oLTEpKSA6IHRoaXMuY2FuR29CYWNrID8gKHRoaXMubG9nZ2VyLmxvZyhcIlNldHRpbmcgdXAgaGlzdG9yeTogWzwtLCAqXVwiKSwgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFosIFwiXCIpLCB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgXCJcIiwgZSkpIDogdGhpcy5jYW5Hb0ZvcndhcmQgPyAodGhpcy5sb2dnZXIubG9nKFwiU2V0dGluZyB1cCBoaXN0b3J5OiBbKiwgLT5dXCIpLCB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUobnVsbCwgZSksIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShLLCBcIlwiKSwgYXdhaXQgTygtMSkpIDogKHRoaXMubG9nZ2VyLmxvZyhcIlNldHRpbmcgdXAgaGlzdG9yeTogW34sICpdXCIpLCB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoY3QsIFwiXCIpLCB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgXCJcIiwgZSkpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMub25Qb3BTdGF0ZSk7XG4gIH1cbiAgZW1pdENoYW5nZWQoZSwgcykge1xuICAgIHRoaXMuZWUuZW1pdChcImNoYW5nZVwiLCB7XG4gICAgICBuYXZpZ2F0b3I6IHRoaXMsXG4gICAgICBmcm9tOiBlLFxuICAgICAgdG86IHNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoZXMgY3VycmVudCBuYXZpZ2F0b3IgdG8gdGhlIGJyb3dzZXIgaGlzdG9yeSBhbGxvd2luZyBuYXZpZ2F0b3IgdG8gbWFuaXB1bGF0ZSBpdC5cbiAgICovXG4gIGFzeW5jIGF0dGFjaCgpIHtcbiAgICBpZiAoIXRoaXMuYXR0YWNoZWQpXG4gICAgICByZXR1cm4gdGhpcy5sb2dnZXIubG9nKFwiQXR0YWNoaW5nXCIsIHRoaXMpLCB0aGlzLmF0dGFjaGVkID0gITAsIHkoXCJiYWNrX2J1dHRvbl9wcmVzc2VkXCIsIHRoaXMuYmFjayksIHRoaXMuc3luY0hpc3RvcnkoKTtcbiAgfVxuICAvKipcbiAgICogRGV0YWNoZXMgY3VycmVudCBuYXZpZ2F0b3IgZnJvbSB0aGUgYnJvd3NlciBoaXN0b3J5LlxuICAgKi9cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuYXR0YWNoZWQgJiYgKHRoaXMubG9nZ2VyLmxvZyhcIkRldGFjaGluZ1wiLCB0aGlzKSwgdGhpcy5hdHRhY2hlZCA9ICExLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMub25Qb3BTdGF0ZSksIEkoXCJiYWNrX2J1dHRvbl9wcmVzc2VkXCIsIHRoaXMuYmFjaykpO1xuICB9XG59XG5leHBvcnQge1xuICB2ZSBhcyBCYWNrQnV0dG9uLFxuICBrZSBhcyBDbG9zaW5nQmVoYXZpb3IsXG4gIHhlIGFzIENsb3VkU3RvcmFnZSxcbiAgcWUgYXMgSGFwdGljRmVlZGJhY2ssXG4gIEx0IGFzIEhhc2hOYXZpZ2F0b3IsXG4gIFV0IGFzIEluaXREYXRhLFxuICB6ZSBhcyBJbnZvaWNlLFxuICBJZSBhcyBNYWluQnV0dG9uLFxuICB0dCBhcyBNZXRob2RVbnN1cHBvcnRlZEVycm9yLFxuICBUZSBhcyBNaW5pQXBwLFxuICBYZSBhcyBOYXZpZ2F0b3IsXG4gIGV0IGFzIFBhcmFtZXRlclVuc3VwcG9ydGVkRXJyb3IsXG4gIFFlIGFzIFBvcHVwLFxuICBaZSBhcyBRUlNjYW5uZXIsXG4gIFdlIGFzIFNldHRpbmdzQnV0dG9uLFxuICBGdCBhcyBUaGVtZVBhcmFtcyxcbiAgSiBhcyBUaW1lb3V0RXJyb3IsXG4gIEtlIGFzIFV0aWxzLFxuICBHIGFzIFZpZXdwb3J0LFxuICBIdCBhcyBjaGF0UGFyc2VyLFxuICBQZSBhcyBjbGFzc05hbWVzLFxuICBtZSBhcyBjb21wYXJlVmVyc2lvbnMsXG4gIHllIGFzIGNyZWF0ZVBvc3RFdmVudCxcbiAgcHIgYXMgZ2V0SGFzaCxcbiAgdXIgYXMgaW5pdCxcbiAgd3QgYXMgaW5pdERhdGFQYXJzZXIsXG4gIE4gYXMgaW52b2tlQ3VzdG9tTWV0aG9kLFxuICBmdCBhcyBpc0NvbG9yRGFyayxcbiAgdnQgYXMgaXNJZnJhbWUsXG4gIGx0IGFzIGlzUkdCLFxuICBPdCBhcyBpc1JHQlNob3J0LFxuICBIIGFzIGlzUmVjb3JkLFxuICBzciBhcyBpc1RNQSxcbiAgY3IgYXMgaXNUaW1lb3V0RXJyb3IsXG4gIG10IGFzIGxhdW5jaFBhcmFtc1BhcnNlcixcbiAgaHIgYXMgbWVyZ2VDbGFzc05hbWVzLFxuICBJIGFzIG9mZixcbiAgeSBhcyBvbixcbiAgb3IgYXMgb25jZSxcbiAgZXIgYXMgcGFyc2VJbml0RGF0YSxcbiAgeXQgYXMgcGFyc2VMYXVuY2hQYXJhbXMsXG4gIGJ0IGFzIHBhcnNlVGhlbWVQYXJhbXMsXG4gIGYgYXMgcG9zdEV2ZW50LFxuICBtIGFzIHJlcXVlc3QsXG4gIHJyIGFzIHJlcXVlc3RUaGVtZVBhcmFtcyxcbiAgQXQgYXMgcmVxdWVzdFZpZXdwb3J0LFxuICBDdCBhcyByZXRyaWV2ZUxhdW5jaERhdGEsXG4gIFp0IGFzIHNlcmlhbGl6ZUxhdW5jaFBhcmFtcyxcbiAgR3QgYXMgc2VyaWFsaXplVGhlbWVQYXJhbXMsXG4gIG5yIGFzIHNldERlYnVnLFxuICBpciBhcyBzZXRUYXJnZXRPcmlnaW4sXG4gIGFyIGFzIHN1YnNjcmliZSxcbiAgQSBhcyBzdXBwb3J0cyxcbiAgX3QgYXMgdGhlbWVQYXJhbXNQYXJzZXIsXG4gIGR0IGFzIHRvUkdCLFxuICBiZSBhcyB1bnN1YnNjcmliZSxcbiAgcnQgYXMgdXNlclBhcnNlcixcbiAgeHQgYXMgd2l0aFRpbWVvdXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tma.js+sdk@1.2.0/node_modules/@tma.js/sdk/dist/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Ccode%5CTelegram-App%5Cminiapp%5Cnode_modules%5C.pnpm%5Cnext%4014.0.4_react-dom%4018.2.0_react%4018.2.0%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22src%5C%5Capp%5C%5Clayout.tsx%22%2C%22import%22%3A%22Inter%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%7D%5D%2C%22variableName%22%3A%22inter%22%7D&modules=C%3A%5Ccode%5CTelegram-App%5Cminiapp%5Csrc%5Capp%5Cglobals.css&modules=C%3A%5Ccode%5CTelegram-App%5Cminiapp%5Csrc%5Capp%5CTmaSDKLoader.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);